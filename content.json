{"meta":{"title":"阿龙的小型博客","subtitle":null,"description":null,"author":"along","url":"https://WLL-1017065322.github.io/blog","root":"/blog/"},"pages":[{"title":"简历","date":"2019-06-28T12:03:54.575Z","updated":"2019-06-28T12:03:54.575Z","comments":true,"path":"about/index.html","permalink":"https://WLL-1017065322.github.io/blog/about/index.html","excerpt":"","text":"💘个人信息 姓名：王履龙 性别：男 兴趣爱好：编程，看书，养花。 座右铭：但行前路，莫问前途。 💪技能素养 ☺擅长skills 熟悉HTML5与CSS3，网页常规布局有一定的实践经验 熟悉Vue，jQuery，BootStrap等前端框架的使用 熟悉JavaScript，对于ES6/7/8特性较为熟悉 熟悉git分布式版本控制系统 😟短板skills 网站SEO Linux操作系统 Nuxt服务端渲染 react/angluar 数据库（Mysql，nosql） 📕常用框架锦集 BootStrap jQuery Vue BootStrap-Vue Element-UI mint 🔨人生目标 活得潇洒，不枉此生。 📝个人感悟 然岁月蹉跎，终感到天下人力有尽头。但年少轻狂，可以为天下事无不可为。"},{"title":"Gallery","date":"2017-01-17T13:39:03.000Z","updated":"2019-05-12T03:46:36.020Z","comments":true,"path":"gallery/index.html","permalink":"https://WLL-1017065322.github.io/blog/gallery/index.html","excerpt":"","text":"图库"},{"title":"tags","date":"2017-01-17T13:39:14.000Z","updated":"2019-05-12T03:46:36.031Z","comments":true,"path":"tag/index.html","permalink":"https://WLL-1017065322.github.io/blog/tag/index.html","excerpt":"","text":"tags"},{"title":"group","date":"2017-01-17T13:05:04.000Z","updated":"2019-05-12T03:46:36.026Z","comments":true,"path":"group/index.html","permalink":"https://WLL-1017065322.github.io/blog/group/index.html","excerpt":"","text":"团队"}],"posts":[{"title":"hexo报错","slug":"hexo报错","date":"2019-10-24T16:00:00.000Z","updated":"2019-10-28T10:00:25.450Z","comments":true,"path":"2019/10/25/hexo报错/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/10/25/hexo报错/","excerpt":"","text":"报错: 123Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlTemplate render error: (unknown path) [Line 17, Column 21] unexpected token: &#125;&#125; 发现:剪切每个文件,依次放入发现是微信小程序.md 的问题原因:这个是 hexo 转义时候发生的错误，你文章中可能出现了 {{}}，{% %}。你可以将出现的代码，用 `进行注释下就可以了。解决:需要显示符号的地方用如下代码包围 123&#123;% raw %&#125;&#123;% endraw %&#125;","categories":[{"name":"hexo","slug":"hexo","permalink":"https://WLL-1017065322.github.io/blog/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://WLL-1017065322.github.io/blog/tags/hexo/"},{"name":"问题","slug":"问题","permalink":"https://WLL-1017065322.github.io/blog/tags/问题/"}],"author":"along"},{"title":"flex 最后一行","slug":"flex 最后一行","date":"2019-10-20T16:00:00.000Z","updated":"2019-10-28T10:13:22.692Z","comments":true,"path":"2019/10/21/flex 最后一行/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/10/21/flex 最后一行/","excerpt":"","text":"flex布局 justify-content：space-between; 解决最后一排数量不够自动向两端排列问题 justify-content: flex-start; flex 布局两端对齐当最后一排数量不够时，会出现以下布局情况 原图 实现效果 方案1：父级添加after伪类法，解决最后一排数量不够两端分布的情况 html 1234&lt;div class=&quot;tem-flex&quot;&gt; &lt;div class=&quot;tem-list&quot; v-for=&quot;item in len&quot;&gt;列表&lt;/div&gt;&lt;/div&gt;123 js 123456data()&#123; return &#123; len : 14 &#125;&#125;12345 css 123456789101112131415161718.tem-flex&#123; display: flex; flex-wrap: wrap; justify-content:space-between; text-align: justify; &#125; &lt;!--加上after伪类，解决最后一排数量不够两端分布的情况--&gt; .tem-flex:after&#123; content: &apos;&apos;; width: 30%; border:1px solid transparent; &#125; .tem-list&#123; width:30%; border:1px solid #ff6600; margin-bottom: 10px; &#125;1234567891011121314151617 完美解决两端对齐布局混乱的情况 当然，这种解决方案只适合每列有3个的分布情况，如果布局每列有4个，5个，可参考方案2 方案2：补位添加节点法，这种方案适用于多种排列方式。 原图 实现效果 html 12345&lt;div class=&quot;tem-flex&quot;&gt; &lt;div class=&quot;tem-list&quot; v-for=&quot;item in len&quot;&gt;列表&lt;/div&gt; &lt;div class=&quot;list&quot; v-for=&quot;item in (row-len%row)&quot; v-if=&quot;len%row &gt; 0&quot;&gt;&lt;/div&gt;&lt;/div&gt;1234 js 1234567data()&#123; return &#123; len : 14, row: 4 &#125;&#125;123456 css 1234567891011121314151617181920212223.tem-flex&#123; display: flex; flex-wrap: wrap; justify-content:space-between; justify-items: center; text-align: justify;&#125;.list&#123; content: &apos;&apos;; width: 20%; border:1px solid transparent; padding: 5px; overflow: hidden;&#125;.tem-list&#123; width:20%; border:1px solid #ff6600; margin-bottom: 10px; padding: 10px 5px; display: flex; justify-content: center;&#125;12345678910111213141516171819202122 这里的 row 即是每列元素的个数，4列，5列。。。更改这个值即可","categories":[{"name":"css","slug":"css","permalink":"https://WLL-1017065322.github.io/blog/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://WLL-1017065322.github.io/blog/tags/css/"},{"name":"flex","slug":"flex","permalink":"https://WLL-1017065322.github.io/blog/tags/flex/"}],"author":"along"},{"title":"loading","slug":"loading","date":"2019-10-20T16:00:00.000Z","updated":"2019-10-28T10:14:29.544Z","comments":true,"path":"2019/10/21/loading/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/10/21/loading/","excerpt":"","text":"1，开头动画，vue ， 在 div#app里添加 &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;nihao&lt;/h1&gt; &lt;/div&gt; ​ 2，app 设置 display：none create(){ setTimeout(function() { document.getElementById(‘app’).style.display = ‘block’; }, 500) }","categories":[{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/tags/vue/"},{"name":"项目","slug":"项目","permalink":"https://WLL-1017065322.github.io/blog/tags/项目/"}],"author":"along"},{"title":"exports、module.exports和export、export default","slug":"exports、module.exports和export、export default","date":"2019-10-18T16:00:00.000Z","updated":"2019-10-28T10:13:17.078Z","comments":true,"path":"2019/10/19/exports、module.exports和export、export default/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/10/19/exports、module.exports和export、export default/","excerpt":"","text":"前言难得有空，今天开始重新规范的学习一下node编程。但是引入模块我看到用 require的方式，再联想到咱们的ES6各种export 、export default。 阿西吧，头都大了…. 头大完了，那我们坐下先理理他们的使用范围。 require: node 和 es6 都支持的引入export / import : 只有es6 支持的导出引入module.exports / exports: 只有 node 支持的导出 这一刻起，我觉得是时候要把它们之间的关系都给捋清楚了，不然我得混乱死。话不多少，咱们开干！！ node模块Node里面的模块系统遵循的是CommonJS规范。那问题又来了，什么是CommonJS规范呢？由于js以前比较混乱，各写各的代码，没有一个模块的概念，而这个规范出来其实就是对模块的一个定义。 CommonJS定义的模块分为: 模块标识(module)、模块定义(exports) 、模块引用(require) 先解释 exports 和 module.exports在一个node执行一个文件时，会给这个文件内生成一个 exports和module对象，而module又有一个exports属性。他们之间的关系如下图，都指向一块{}内存区域。 1exports = module.exports = &#123;&#125;; 那下面我们来看看代码的吧。 1234567891011121314//utils.jslet a = 100;console.log(module.exports); //能打印出结果为：&#123;&#125;console.log(exports); //能打印出结果为：&#123;&#125;exports.a = 200; //这里辛苦劳作帮 module.exports 的内容给改成 &#123;a : 200&#125;exports = &apos;指向其他内存区&apos;; //这里把exports的指向指走//test.jsvar a = require(&apos;/utils&apos;);console.log(a) // 打印为 &#123;a : 200&#125; 从上面可以看出，其实require导出的内容是module.exports的指向的内存块内容，并不是exports的。简而言之，区分他们之间的区别就是 exports 只是 module.exports的引用，辅助后者添加内容用的。 用白话讲就是，exports只辅助module.exports操作内存中的数据，辛辛苦苦各种操作数据完，累得要死，结果到最后真正被require出去的内容还是module.exports的，真是好苦逼啊。 其实大家用内存块的概念去理解，就会很清楚了。 然后呢，为了避免糊涂，尽量都用 module.exports 导出，然后用require导入。 ES中的模块导出导入说实话，在es中的模块，就非常清晰了。不过也有一些细节的东西需要搞清楚。比如 export 和 export default，还有 导入的时候，import a from ..,import {a} from ..，总之也有点乱，那么下面我们就开始把它们捋清楚吧。 export 和 export default首先我们讲这两个导出，下面我们讲讲它们的区别 export与export default均可用于导出常量、函数、文件、模块等 在一个文件或模块中，export、import可以有多个，export default仅有一个 通过export方式导出，在导入时要加{ }，export default则不需要 export能直接导出变量表达式，export default不行。 下面咱们看看代码去验证一下 testEs6Export.js12345678910111213141516171819&apos;use strict&apos;//导出变量export const a = &apos;100&apos;; //导出方法export const dogSay = function()&#123; console.log(&apos;wang wang&apos;);&#125; //导出方法第二种function catSay()&#123; console.log(&apos;miao miao&apos;); &#125;export &#123; catSay &#125;;//export default导出const m = 100;export default m; //export defult const m = 100;// 这里不能写这种格式。 index.js123456789101112131415161718192021222324//index.js&apos;use strict&apos;var express = require(&apos;express&apos;);var router = express.Router();import &#123; dogSay, catSay &#125; from &apos;./testEs6Export&apos;; //导出了 export 方法 import m from &apos;./testEs6Export&apos;; //导出了 export default import * as testModule from &apos;./testEs6Export&apos;; //as 集合成对象导出/* GET home page. */router.get(&apos;/&apos;, function(req, res, next) &#123; dogSay(); catSay(); console.log(m); testModule.dogSay(); console.log(testModule.m); // undefined , 因为 as 导出是 把 零散的 export 聚集在一起作为一个对象，而export default 是导出为 default属性。 console.log(testModule.default); // 100 res.send(&apos;恭喜你，成功验证&apos;);&#125;);module.exports = router; 从上面可以看出，确实感觉 ES6的模块系统非常灵活的。","categories":[{"name":"node","slug":"node","permalink":"https://WLL-1017065322.github.io/blog/categories/node/"}],"tags":[{"name":"node","slug":"node","permalink":"https://WLL-1017065322.github.io/blog/tags/node/"},{"name":"export","slug":"export","permalink":"https://WLL-1017065322.github.io/blog/tags/export/"}],"author":"along"},{"title":"eslint常用规则","slug":"eslint常用规则","date":"2019-10-16T16:00:00.000Z","updated":"2019-10-28T10:13:04.483Z","comments":true,"path":"2019/10/17/eslint常用规则/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/10/17/eslint常用规则/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174&quot;no-alert&quot;: 0,//禁止使用alert confirm prompt&quot;no-array-constructor&quot;: 2,//禁止使用数组构造器&quot;no-bitwise&quot;: 0,//禁止使用按位运算符&quot;no-caller&quot;: 1,//禁止使用arguments.caller或arguments.callee&quot;no-catch-shadow&quot;: 2,//禁止catch子句参数与外部作用域变量同名&quot;no-class-assign&quot;: 2,//禁止给类赋值&quot;no-cond-assign&quot;: 2,//禁止在条件表达式中使用赋值语句&quot;no-console&quot;: 2,//禁止使用console&quot;no-const-assign&quot;: 2,//禁止修改const声明的变量&quot;no-constant-condition&quot;: 2,//禁止在条件中使用常量表达式 if(true) if(1)&quot;no-continue&quot;: 0,//禁止使用continue&quot;no-control-regex&quot;: 2,//禁止在正则表达式中使用控制字符&quot;no-debugger&quot;: 2,//禁止使用debugger&quot;no-delete-var&quot;: 2,//不能对var声明的变量使用delete操作符&quot;no-div-regex&quot;: 1,//不能使用看起来像除法的正则表达式/=foo/&quot;no-dupe-keys&quot;: 2,//在创建对象字面量时不允许键重复 &#123;a:1,a:1&#125;&quot;no-dupe-args&quot;: 2,//函数参数不能重复&quot;no-duplicate-case&quot;: 2,//switch中的case标签不能重复&quot;no-else-return&quot;: 2,//如果if语句里面有return,后面不能跟else语句&quot;no-empty&quot;: 2,//块语句中的内容不能为空&quot;no-empty-character-class&quot;: 2,//正则表达式中的[]内容不能为空&quot;no-empty-label&quot;: 2,//禁止使用空label&quot;no-eq-null&quot;: 2,//禁止对null使用==或!=运算符&quot;no-eval&quot;: 1,//禁止使用eval&quot;no-ex-assign&quot;: 2,//禁止给catch语句中的异常参数赋值&quot;no-extend-native&quot;: 2,//禁止扩展native对象&quot;no-extra-bind&quot;: 2,//禁止不必要的函数绑定&quot;no-extra-boolean-cast&quot;: 2,//禁止不必要的bool转换&quot;no-extra-parens&quot;: 2,//禁止非必要的括号&quot;no-extra-semi&quot;: 2,//禁止多余的冒号&quot;no-fallthrough&quot;: 1,//禁止switch穿透&quot;no-floating-decimal&quot;: 2,//禁止省略浮点数中的0 .5 3.&quot;no-func-assign&quot;: 2,//禁止重复的函数声明&quot;no-implicit-coercion&quot;: 1,//禁止隐式转换&quot;no-implied-eval&quot;: 2,//禁止使用隐式eval&quot;no-inline-comments&quot;: 0,//禁止行内备注&quot;no-inner-declarations&quot;: [2, &quot;functions&quot;],//禁止在块语句中使用声明（变量或函数）&quot;no-invalid-regexp&quot;: 2,//禁止无效的正则表达式&quot;no-invalid-this&quot;: 2,//禁止无效的this，只能用在构造器，类，对象字面量&quot;no-irregular-whitespace&quot;: 2,//不能有不规则的空格&quot;no-iterator&quot;: 2,//禁止使用__iterator__ 属性&quot;no-label-var&quot;: 2,//label名不能与var声明的变量名相同&quot;no-labels&quot;: 2,//禁止标签声明&quot;no-lone-blocks&quot;: 2,//禁止不必要的嵌套块&quot;no-lonely-if&quot;: 2,//禁止else语句内只有if语句&quot;no-loop-func&quot;: 1,//禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以）&quot;no-mixed-requires&quot;: [0, false],//声明时不能混用声明类型&quot;no-mixed-spaces-and-tabs&quot;: [2, false],//禁止混用tab和空格&quot;linebreak-style&quot;: [0, &quot;windows&quot;],//换行风格&quot;no-multi-spaces&quot;: 1,//不能用多余的空格&quot;no-multi-str&quot;: 2,//字符串不能用\\换行&quot;no-multiple-empty-lines&quot;: [1, &#123;&quot;max&quot;: 2&#125;],//空行最多不能超过2行&quot;no-native-reassign&quot;: 2,//不能重写native对象&quot;no-negated-in-lhs&quot;: 2,//in 操作符的左边不能有!&quot;no-nested-ternary&quot;: 0,//禁止使用嵌套的三目运算&quot;no-new&quot;: 1,//禁止在使用new构造一个实例后不赋值&quot;no-new-func&quot;: 1,//禁止使用new Function&quot;no-new-object&quot;: 2,//禁止使用new Object()&quot;no-new-require&quot;: 2,//禁止使用new require&quot;no-new-wrappers&quot;: 2,//禁止使用new创建包装实例，new String new Boolean new Number&quot;no-obj-calls&quot;: 2,//不能调用内置的全局对象，比如Math() JSON()&quot;no-octal&quot;: 2,//禁止使用八进制数字&quot;no-octal-escape&quot;: 2,//禁止使用八进制转义序列&quot;no-param-reassign&quot;: 2,//禁止给参数重新赋值&quot;no-path-concat&quot;: 0,//node中不能使用__dirname或__filename做路径拼接&quot;no-plusplus&quot;: 0,//禁止使用++，--&quot;no-process-env&quot;: 0,//禁止使用process.env&quot;no-process-exit&quot;: 0,//禁止使用process.exit()&quot;no-proto&quot;: 2,//禁止使用__proto__属性&quot;no-redeclare&quot;: 2,//禁止重复声明变量&quot;no-regex-spaces&quot;: 2,//禁止在正则表达式字面量中使用多个空格 /foo bar/&quot;no-restricted-modules&quot;: 0,//如果禁用了指定模块，使用就会报错&quot;no-return-assign&quot;: 1,//return 语句中不能有赋值表达式&quot;no-script-url&quot;: 0,//禁止使用javascript:void(0)&quot;no-self-compare&quot;: 2,//不能比较自身&quot;no-sequences&quot;: 0,//禁止使用逗号运算符&quot;no-shadow&quot;: 2,//外部作用域中的变量不能与它所包含的作用域中的变量或参数同名&quot;no-shadow-restricted-names&quot;: 2,//严格模式中规定的限制标识符不能作为声明时的变量名使用&quot;no-spaced-func&quot;: 2,//函数调用时 函数名与()之间不能有空格&quot;no-sparse-arrays&quot;: 2,//禁止稀疏数组， [1,,2]&quot;no-sync&quot;: 0,//nodejs 禁止同步方法&quot;no-ternary&quot;: 0,//禁止使用三目运算符&quot;no-trailing-spaces&quot;: 1,//一行结束后面不要有空格&quot;no-this-before-super&quot;: 0,//在调用super()之前不能使用this或super&quot;no-throw-literal&quot;: 2,//禁止抛出字面量错误 throw &quot;error&quot;;&quot;no-undef&quot;: 1,//不能有未定义的变量&quot;no-undef-init&quot;: 2,//变量初始化时不能直接给它赋值为undefined&quot;no-undefined&quot;: 2,//不能使用undefined&quot;no-unexpected-multiline&quot;: 2,//避免多行表达式&quot;no-underscore-dangle&quot;: 1,//标识符不能以_开头或结尾&quot;no-unneeded-ternary&quot;: 2,//禁止不必要的嵌套 var isYes = answer === 1 ? true : false;&quot;no-unreachable&quot;: 2,//不能有无法执行的代码&quot;no-unused-expressions&quot;: 2,//禁止无用的表达式&quot;no-unused-vars&quot;: [2, &#123;&quot;vars&quot;: &quot;all&quot;, &quot;args&quot;: &quot;after-used&quot;&#125;],//不能有声明后未被使用的变量或参数&quot;no-use-before-define&quot;: 2,//未定义前不能使用&quot;no-useless-call&quot;: 2,//禁止不必要的call和apply&quot;no-void&quot;: 2,//禁用void操作符&quot;no-var&quot;: 0,//禁用var，用let和const代替&quot;no-warning-comments&quot;: [1, &#123; &quot;terms&quot;: [&quot;todo&quot;, &quot;fixme&quot;, &quot;xxx&quot;], &quot;location&quot;: &quot;start&quot; &#125;],//不能有警告备注&quot;no-with&quot;: 2,//禁用with&quot;array-bracket-spacing&quot;: [2, &quot;never&quot;],//是否允许非空数组里面有多余的空格&quot;arrow-parens&quot;: 0,//箭头函数用小括号括起来&quot;arrow-spacing&quot;: 0,//=&gt;的前/后括号&quot;accessor-pairs&quot;: 0,//在对象中使用getter/setter&quot;block-scoped-var&quot;: 0,//块语句中使用var&quot;brace-style&quot;: [1, &quot;1tbs&quot;],//大括号风格&quot;callback-return&quot;: 1,//避免多次调用回调什么的&quot;camelcase&quot;: 2,//强制驼峰法命名&quot;comma-dangle&quot;: [2, &quot;never&quot;],//对象字面量项尾不能有逗号&quot;comma-spacing&quot;: 0,//逗号前后的空格&quot;comma-style&quot;: [2, &quot;last&quot;],//逗号风格，换行时在行首还是行尾&quot;complexity&quot;: [0, 11],//循环复杂度&quot;computed-property-spacing&quot;: [0, &quot;never&quot;],//是否允许计算后的键名什么的&quot;consistent-return&quot;: 0,//return 后面是否允许省略&quot;consistent-this&quot;: [2, &quot;that&quot;],//this别名&quot;constructor-super&quot;: 0,//非派生类不能调用super，派生类必须调用super&quot;curly&quot;: [2, &quot;all&quot;],//必须使用 if()&#123;&#125; 中的&#123;&#125;&quot;default-case&quot;: 2,//switch语句最后必须有default&quot;dot-location&quot;: 0,//对象访问符的位置，换行的时候在行首还是行尾&quot;dot-notation&quot;: [0, &#123; &quot;allowKeywords&quot;: true &#125;],//避免不必要的方括号&quot;eol-last&quot;: 0,//文件以单一的换行符结束&quot;eqeqeq&quot;: 2,//必须使用全等&quot;func-names&quot;: 0,//函数表达式必须有名字&quot;func-style&quot;: [0, &quot;declaration&quot;],//函数风格，规定只能使用函数声明/函数表达式&quot;generator-star-spacing&quot;: 0,//生成器函数*的前后空格&quot;guard-for-in&quot;: 0,//for in循环要用if语句过滤&quot;handle-callback-err&quot;: 0,//nodejs 处理错误&quot;id-length&quot;: 0,//变量名长度&quot;indent&quot;: [2, 4],//缩进风格&quot;init-declarations&quot;: 0,//声明时必须赋初值&quot;key-spacing&quot;: [0, &#123; &quot;beforeColon&quot;: false, &quot;afterColon&quot;: true &#125;],//对象字面量中冒号的前后空格&quot;lines-around-comment&quot;: 0,//行前/行后备注&quot;max-depth&quot;: [0, 4],//嵌套块深度&quot;max-len&quot;: [0, 80, 4],//字符串最大长度&quot;max-nested-callbacks&quot;: [0, 2],//回调嵌套深度&quot;max-params&quot;: [0, 3],//函数最多只能有3个参数&quot;max-statements&quot;: [0, 10],//函数内最多有几个声明&quot;new-cap&quot;: 2,//函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用&quot;new-parens&quot;: 2,//new时必须加小括号&quot;newline-after-var&quot;: 2,//变量声明后是否需要空一行&quot;object-curly-spacing&quot;: [0, &quot;never&quot;],//大括号内是否允许不必要的空格&quot;object-shorthand&quot;: 0,//强制对象字面量缩写语法&quot;one-var&quot;: 1,//连续声明&quot;operator-assignment&quot;: [0, &quot;always&quot;],//赋值运算符 += -=什么的&quot;operator-linebreak&quot;: [2, &quot;after&quot;],//换行时运算符在行尾还是行首&quot;padded-blocks&quot;: 0,//块语句内行首行尾是否要空行&quot;prefer-const&quot;: 0,//首选const&quot;prefer-spread&quot;: 0,//首选展开运算&quot;prefer-reflect&quot;: 0,//首选Reflect的方法&quot;quotes&quot;: [1, &quot;single&quot;],//引号类型 `` &quot;&quot; &apos;&apos;&quot;quote-props&quot;:[2, &quot;always&quot;],//对象字面量中的属性名是否强制双引号&quot;radix&quot;: 2,//parseInt必须指定第二个参数&quot;id-match&quot;: 0,//命名检测&quot;require-yield&quot;: 0,//生成器函数必须有yield&quot;semi&quot;: [2, &quot;always&quot;],//语句强制分号结尾&quot;semi-spacing&quot;: [0, &#123;&quot;before&quot;: false, &quot;after&quot;: true&#125;],//分号前后空格&quot;sort-vars&quot;: 0,//变量声明时排序&quot;space-after-keywords&quot;: [0, &quot;always&quot;],//关键字后面是否要空一格&quot;space-before-blocks&quot;: [0, &quot;always&quot;],//不以新行开始的块&#123;前面要不要有空格&quot;space-before-function-paren&quot;: [0, &quot;always&quot;],//函数定义时括号前面要不要有空格&quot;space-in-parens&quot;: [0, &quot;never&quot;],//小括号里面要不要有空格&quot;space-infix-ops&quot;: 0,//中缀操作符周围要不要有空格&quot;space-return-throw-case&quot;: 2,//return throw case后面要不要加空格&quot;space-unary-ops&quot;: [0, &#123; &quot;words&quot;: true, &quot;nonwords&quot;: false &#125;],//一元运算符的前/后要不要加空格&quot;spaced-comment&quot;: 0,//注释风格要不要有空格什么的&quot;strict&quot;: 2,//使用严格模式&quot;use-isnan&quot;: 2,//禁止比较时使用NaN，只能用isNaN()&quot;valid-jsdoc&quot;: 0,//jsdoc规则&quot;valid-typeof&quot;: 2,//必须使用合法的typeof的值&quot;vars-on-top&quot;: 2,//var必须放在作用域顶部&quot;wrap-iife&quot;: [2, &quot;inside&quot;],//立即执行函数表达式的小括号风格&quot;wrap-regex&quot;: 0,//正则表达式字面量用小括号包起来&quot;yoda&quot;: [2, &quot;never&quot;]//禁止尤达条件","categories":[{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/tags/vue/"},{"name":"eslint","slug":"eslint","permalink":"https://WLL-1017065322.github.io/blog/tags/eslint/"}],"author":"along"},{"title":"eslint报错","slug":"eslint报错","date":"2019-10-14T16:00:00.000Z","updated":"2019-10-28T10:12:58.246Z","comments":true,"path":"2019/10/15/eslint报错/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/10/15/eslint报错/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// .eslintrc.js module.exports = &#123; &quot;extends&quot;: &quot;airbnb&quot;, &quot;rules&quot;: &#123; &quot;semi&quot;: [2, &quot;never&quot;], &quot;no-console&quot;: 0, &quot;comma-dangle&quot;: [2, &quot;always-multiline&quot;], &quot;max-len&quot;: 0, &quot;react/jsx-first-prop-new-line&quot;: 0, &quot;react/jsx-filename-extension&quot;: 0, &quot;space-before-function-paren&quot;: [2, &quot;always&quot;], &quot;no-unused-expressions&quot;: [0, &#123; &quot;allowShortCircuit&quot;: true, &quot;allowTernary&quot;: true &#125;], &quot;arrow-body-style&quot;: [0, &quot;never&quot;], &quot;func-names&quot;: 0, &quot;prefer-const&quot;: 0, &quot;no-extend-native&quot;: 0, &quot;no-param-reassign&quot;: 0, &quot;no-restricted-syntax&quot;: 0, &quot;no-eval&quot;: 0, &quot;no-continue&quot;: 0, &quot;react/jsx-no-bind&quot;: 0, &quot;no-unused-vars&quot;: [2, &#123; &quot;ignoreRestSiblings&quot;: true &#125;], &quot;no-underscore-dangle&quot;: 0, &quot;global-require&quot;: 0, &quot;import/no-unresolved&quot;: 0, &quot;import/extensions&quot;: 0, &quot;jsx-a11y/href-no-hash&quot;: 0, &quot;react/no-array-index-key&quot;: 0, &quot;react/require-default-props&quot;: 0, &quot;react/forbid-prop-types&quot;: 0, &quot;react/no-string-refs&quot;: 0, &quot;react/no-find-dom-node&quot;: 0, &quot;import/no-extraneous-dependencies&quot;: 0, &quot;import/prefer-default-export&quot;: 0, &quot;react/no-danger&quot;: 0, &quot;jsx-a11y/no-static-element-interactions&quot;: 0, &#125;, &quot;parser&quot;: &quot;babel-eslint&quot;, &quot;parserOptions&quot;: &#123; &quot;sourceType&quot;: &quot;module&quot;, &quot;ecmaVersion&quot;: 8, &quot;ecmaFeatures&quot;: &#123; &quot;jsx&quot;: true, &quot;experimentalObjectRestSpread&quot;: true &#125; &#125;, &quot;settings&quot;: &#123; &quot;import/resolver&quot;: &quot;node&quot; &#125;&#125;; Do not use ‘new’ for side effects (no-new) :方法一：定义一个变量xxx(可为任意值)接收新创建的Vue 12345678let xxx = new Vue(&#123; el: &apos;#app&apos;, render: h =&gt; h(App), router&#125;)Vue.use(&#123; xxx&#125;) 方法二：在new Vue的上方添加一行注视，让eslint不检查”no-new” 123456789import Vue from &apos;vue&apos;import App from &apos;./App.vue&apos;import router from &apos;./router&apos;/* eslint-disable no-new */new Vue(&#123; el: &apos;#app&apos;, render: h =&gt; h(App), router&#125;) 全局 如果您确实需要为整个项目禁用此规则，请在.eslintrc的&quot;rules&quot;部分中将此规则的值设置为0： 1234567&#123; // ... \"rules\": &#123; \"no-new\": 0, // ... &#125;&#125; Line 10 exceeds the maximum line length of 100方法一 .eslintrc.js ，设置 “max-len” : [“error”, {code : 300}] 123rules: &#123; &apos;max-len&apos;:[&quot;error&quot;,&#123;&quot;code&quot;:300&#125;],&#125; 方法二 通过eslint-disable设置忽略本次Eslit语法规范，最后通过eslint-enable结束本次忽略。 方法三: .editorconfig: 1234567[*.&#123;js,jsx,ts,tsx,vue&#125;]indent_style = spaceindent_size = 2end_of_line = lftrim_trailing_whitespace = trueinsert_final_newline = truemax_line_length = 300 Missing file extension(文件后缀)123456rules: &#123; &apos;import/extensions&apos;: [&apos;error&apos;, &apos;always&apos;, &#123; &apos;js&apos;: &apos;never&apos;, &apos;vue&apos;: &apos;never&apos; &#125;]&#125; ‘vuex’ should be listed in the project’s dependenciesimport / no-extraneous-dependencies”：[“ error”，{“ devDependencies”：true}] 1234567891011121314151617181920212223/* eslint import/no-extraneous-dependencies: [&quot;error&quot;, &#123;&quot;devDependencies&quot;: false&#125;] */import test from &apos;ava&apos;;var test = require(&apos;ava&apos;);/* eslint import/no-extraneous-dependencies: [&quot;error&quot;, &#123;&quot;optionalDependencies&quot;: false&#125;] */import isArray from &apos;lodash.isarray&apos;;var isArray = require(&apos;lodash.isarray&apos;);/* eslint import/no-extraneous-dependencies: [&quot;error&quot;, &#123;&quot;bundledDependencies&quot;: false&#125;] */import foo from &apos;&quot;@generated/foo&quot;&apos;;var foo = require(&apos;&quot;@generated/foo&quot;&apos;);// Builtin and internal modules are finevar path = require(&apos;path&apos;);var foo = require(&apos;./foo&apos;);import test from &apos;ava&apos;;import find from &apos;lodash.find&apos;;import isArray from &apos;lodash.isarray&apos;;import foo from &apos;&quot;@generated/foo&quot;&apos;;/* eslint import/no-extraneous-dependencies: [&quot;error&quot;, &#123;&quot;peerDependencies&quot;: true&#125;] */import react from &apos;react&apos;; 1、关闭eslint直接注释掉package.json文件中eslint的配置就可以了（以下是vue-cli的默认配置） 12345678910111213141516\"eslintConfig\": &#123; \"root\": true,////此项是用来告诉eslint找当前配置文件不能往父级查找 \"env\": &#123; \"node\": true//此项指定环境的全局变量，下面的配置指定为node环境 &#125;, \"extends\": [// 此项是用来配置vue.js风格，就是说写代码的时候要规范的写，如果你使用vs-code我觉得应该可以避免出错 \"plugin:vue/essential\", \"@vue/standard\" ], \"rules\": &#123;//规则配置写在这里 \"indent\": [1, 4] &#125;, \"parserOptions\": &#123; \"parser\": \"babel-eslint\"//此项是用来指定eslint解析器的，解析器必须符合规则，babel-eslint解析器是对babel解析器的包装使其与ESLint解析 &#125; &#125;, 或者vue.config.js中将以下三项设置为false 1234567devServer: &#123; overlay: &#123; warnings: false, errors: false &#125;, lintOnSave: false&#125; 2 修改eslint的语法检测，文件为根目录下的 package.json文件（规则写在rules内）格式： 123rules: &#123; \"规则名\": [规则值, 规则配置]&#125; 规则值： 123\"off\"或者0 //关闭规则关闭\"warn\"或者1 //在打开的规则作为警告（不影响退出代码）\"error\"或者2 //把规则作为一个错误（退出代码触发时为1） 3、eslint 规则配置参数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174\"no-alert\": 0,//禁止使用alert confirm prompt\"no-array-constructor\": 2,//禁止使用数组构造器\"no-bitwise\": 0,//禁止使用按位运算符\"no-caller\": 1,//禁止使用arguments.caller或arguments.callee\"no-catch-shadow\": 2,//禁止catch子句参数与外部作用域变量同名\"no-class-assign\": 2,//禁止给类赋值\"no-cond-assign\": 2,//禁止在条件表达式中使用赋值语句\"no-console\": 2,//禁止使用console\"no-const-assign\": 2,//禁止修改const声明的变量\"no-constant-condition\": 2,//禁止在条件中使用常量表达式 if(true) if(1)\"no-continue\": 0,//禁止使用continue\"no-control-regex\": 2,//禁止在正则表达式中使用控制字符\"no-debugger\": 2,//禁止使用debugger\"no-delete-var\": 2,//不能对var声明的变量使用delete操作符\"no-div-regex\": 1,//不能使用看起来像除法的正则表达式/=foo/\"no-dupe-keys\": 2,//在创建对象字面量时不允许键重复 &#123;a:1,a:1&#125;\"no-dupe-args\": 2,//函数参数不能重复\"no-duplicate-case\": 2,//switch中的case标签不能重复\"no-else-return\": 2,//如果if语句里面有return,后面不能跟else语句\"no-empty\": 2,//块语句中的内容不能为空\"no-empty-character-class\": 2,//正则表达式中的[]内容不能为空\"no-empty-label\": 2,//禁止使用空label\"no-eq-null\": 2,//禁止对null使用==或!=运算符\"no-eval\": 1,//禁止使用eval\"no-ex-assign\": 2,//禁止给catch语句中的异常参数赋值\"no-extend-native\": 2,//禁止扩展native对象\"no-extra-bind\": 2,//禁止不必要的函数绑定\"no-extra-boolean-cast\": 2,//禁止不必要的bool转换\"no-extra-parens\": 2,//禁止非必要的括号\"no-extra-semi\": 2,//禁止多余的冒号\"no-fallthrough\": 1,//禁止switch穿透\"no-floating-decimal\": 2,//禁止省略浮点数中的0 .5 3.\"no-func-assign\": 2,//禁止重复的函数声明\"no-implicit-coercion\": 1,//禁止隐式转换\"no-implied-eval\": 2,//禁止使用隐式eval\"no-inline-comments\": 0,//禁止行内备注\"no-inner-declarations\": [2, \"functions\"],//禁止在块语句中使用声明（变量或函数）\"no-invalid-regexp\": 2,//禁止无效的正则表达式\"no-invalid-this\": 2,//禁止无效的this，只能用在构造器，类，对象字面量\"no-irregular-whitespace\": 2,//不能有不规则的空格\"no-iterator\": 2,//禁止使用__iterator__ 属性\"no-label-var\": 2,//label名不能与var声明的变量名相同\"no-labels\": 2,//禁止标签声明\"no-lone-blocks\": 2,//禁止不必要的嵌套块\"no-lonely-if\": 2,//禁止else语句内只有if语句\"no-loop-func\": 1,//禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以）\"no-mixed-requires\": [0, false],//声明时不能混用声明类型\"no-mixed-spaces-and-tabs\": [2, false],//禁止混用tab和空格\"linebreak-style\": [0, \"windows\"],//换行风格\"no-multi-spaces\": 1,//不能用多余的空格\"no-multi-str\": 2,//字符串不能用\\换行\"no-multiple-empty-lines\": [1, &#123;\"max\": 2&#125;],//空行最多不能超过2行\"no-native-reassign\": 2,//不能重写native对象\"no-negated-in-lhs\": 2,//in 操作符的左边不能有!\"no-nested-ternary\": 0,//禁止使用嵌套的三目运算\"no-new\": 1,//禁止在使用new构造一个实例后不赋值\"no-new-func\": 1,//禁止使用new Function\"no-new-object\": 2,//禁止使用new Object()\"no-new-require\": 2,//禁止使用new require\"no-new-wrappers\": 2,//禁止使用new创建包装实例，new String new Boolean new Number\"no-obj-calls\": 2,//不能调用内置的全局对象，比如Math() JSON()\"no-octal\": 2,//禁止使用八进制数字\"no-octal-escape\": 2,//禁止使用八进制转义序列\"no-param-reassign\": 2,//禁止给参数重新赋值\"no-path-concat\": 0,//node中不能使用__dirname或__filename做路径拼接\"no-plusplus\": 0,//禁止使用++，--\"no-process-env\": 0,//禁止使用process.env\"no-process-exit\": 0,//禁止使用process.exit()\"no-proto\": 2,//禁止使用__proto__属性\"no-redeclare\": 2,//禁止重复声明变量\"no-regex-spaces\": 2,//禁止在正则表达式字面量中使用多个空格 /foo bar/\"no-restricted-modules\": 0,//如果禁用了指定模块，使用就会报错\"no-return-assign\": 1,//return 语句中不能有赋值表达式\"no-script-url\": 0,//禁止使用javascript:void(0)\"no-self-compare\": 2,//不能比较自身\"no-sequences\": 0,//禁止使用逗号运算符\"no-shadow\": 2,//外部作用域中的变量不能与它所包含的作用域中的变量或参数同名\"no-shadow-restricted-names\": 2,//严格模式中规定的限制标识符不能作为声明时的变量名使用\"no-spaced-func\": 2,//函数调用时 函数名与()之间不能有空格\"no-sparse-arrays\": 2,//禁止稀疏数组， [1,,2]\"no-sync\": 0,//nodejs 禁止同步方法\"no-ternary\": 0,//禁止使用三目运算符\"no-trailing-spaces\": 1,//一行结束后面不要有空格\"no-this-before-super\": 0,//在调用super()之前不能使用this或super\"no-throw-literal\": 2,//禁止抛出字面量错误 throw \"error\";\"no-undef\": 1,//不能有未定义的变量\"no-undef-init\": 2,//变量初始化时不能直接给它赋值为undefined\"no-undefined\": 2,//不能使用undefined\"no-unexpected-multiline\": 2,//避免多行表达式\"no-underscore-dangle\": 1,//标识符不能以_开头或结尾\"no-unneeded-ternary\": 2,//禁止不必要的嵌套 var isYes = answer === 1 ? true : false;\"no-unreachable\": 2,//不能有无法执行的代码\"no-unused-expressions\": 2,//禁止无用的表达式\"no-unused-vars\": [2, &#123;\"vars\": \"all\", \"args\": \"after-used\"&#125;],//不能有声明后未被使用的变量或参数\"no-use-before-define\": 2,//未定义前不能使用\"no-useless-call\": 2,//禁止不必要的call和apply\"no-void\": 2,//禁用void操作符\"no-var\": 0,//禁用var，用let和const代替\"no-warning-comments\": [1, &#123; \"terms\": [\"todo\", \"fixme\", \"xxx\"], \"location\": \"start\" &#125;],//不能有警告备注\"no-with\": 2,//禁用with\"array-bracket-spacing\": [2, \"never\"],//是否允许非空数组里面有多余的空格\"arrow-parens\": 0,//箭头函数用小括号括起来\"arrow-spacing\": 0,//=&gt;的前/后括号\"accessor-pairs\": 0,//在对象中使用getter/setter\"block-scoped-var\": 0,//块语句中使用var\"brace-style\": [1, \"1tbs\"],//大括号风格\"callback-return\": 1,//避免多次调用回调什么的\"camelcase\": 2,//强制驼峰法命名\"comma-dangle\": [2, \"never\"],//对象字面量项尾不能有逗号\"comma-spacing\": 0,//逗号前后的空格\"comma-style\": [2, \"last\"],//逗号风格，换行时在行首还是行尾\"complexity\": [0, 11],//循环复杂度\"computed-property-spacing\": [0, \"never\"],//是否允许计算后的键名什么的\"consistent-return\": 0,//return 后面是否允许省略\"consistent-this\": [2, \"that\"],//this别名\"constructor-super\": 0,//非派生类不能调用super，派生类必须调用super\"curly\": [2, \"all\"],//必须使用 if()&#123;&#125; 中的&#123;&#125;\"default-case\": 2,//switch语句最后必须有default\"dot-location\": 0,//对象访问符的位置，换行的时候在行首还是行尾\"dot-notation\": [0, &#123; \"allowKeywords\": true &#125;],//避免不必要的方括号\"eol-last\": 0,//文件以单一的换行符结束\"eqeqeq\": 2,//必须使用全等\"func-names\": 0,//函数表达式必须有名字\"func-style\": [0, \"declaration\"],//函数风格，规定只能使用函数声明/函数表达式\"generator-star-spacing\": 0,//生成器函数*的前后空格\"guard-for-in\": 0,//for in循环要用if语句过滤\"handle-callback-err\": 0,//nodejs 处理错误\"id-length\": 0,//变量名长度\"indent\": [2, 4],//缩进风格\"init-declarations\": 0,//声明时必须赋初值\"key-spacing\": [0, &#123; \"beforeColon\": false, \"afterColon\": true &#125;],//对象字面量中冒号的前后空格\"lines-around-comment\": 0,//行前/行后备注\"max-depth\": [0, 4],//嵌套块深度\"max-len\": [0, 80, 4],//字符串最大长度\"max-nested-callbacks\": [0, 2],//回调嵌套深度\"max-params\": [0, 3],//函数最多只能有3个参数\"max-statements\": [0, 10],//函数内最多有几个声明\"new-cap\": 2,//函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用\"new-parens\": 2,//new时必须加小括号\"newline-after-var\": 2,//变量声明后是否需要空一行\"object-curly-spacing\": [0, \"never\"],//大括号内是否允许不必要的空格\"object-shorthand\": 0,//强制对象字面量缩写语法\"one-var\": 1,//连续声明\"operator-assignment\": [0, \"always\"],//赋值运算符 += -=什么的\"operator-linebreak\": [2, \"after\"],//换行时运算符在行尾还是行首\"padded-blocks\": 0,//块语句内行首行尾是否要空行\"prefer-const\": 0,//首选const\"prefer-spread\": 0,//首选展开运算\"prefer-reflect\": 0,//首选Reflect的方法\"quotes\": [1, \"single\"],//引号类型 `` \"\" ''\"quote-props\":[2, \"always\"],//对象字面量中的属性名是否强制双引号\"radix\": 2,//parseInt必须指定第二个参数\"id-match\": 0,//命名检测\"require-yield\": 0,//生成器函数必须有yield\"semi\": [2, \"always\"],//语句强制分号结尾\"semi-spacing\": [0, &#123;\"before\": false, \"after\": true&#125;],//分号前后空格\"sort-vars\": 0,//变量声明时排序\"space-after-keywords\": [0, \"always\"],//关键字后面是否要空一格\"space-before-blocks\": [0, \"always\"],//不以新行开始的块&#123;前面要不要有空格\"space-before-function-paren\": [0, \"always\"],//函数定义时括号前面要不要有空格\"space-in-parens\": [0, \"never\"],//小括号里面要不要有空格\"space-infix-ops\": 0,//中缀操作符周围要不要有空格\"space-return-throw-case\": 2,//return throw case后面要不要加空格\"space-unary-ops\": [0, &#123; \"words\": true, \"nonwords\": false &#125;],//一元运算符的前/后要不要加空格\"spaced-comment\": 0,//注释风格要不要有空格什么的\"strict\": 2,//使用严格模式\"use-isnan\": 2,//禁止比较时使用NaN，只能用isNaN()\"valid-jsdoc\": 0,//jsdoc规则\"valid-typeof\": 2,//必须使用合法的typeof的值\"vars-on-top\": 2,//var必须放在作用域顶部\"wrap-iife\": [2, \"inside\"],//立即执行函数表达式的小括号风格\"wrap-regex\": 0,//正则表达式字面量用小括号包起来\"yoda\": [2, \"never\"]//禁止尤达条件","categories":[{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/tags/vue/"},{"name":"eslint","slug":"eslint","permalink":"https://WLL-1017065322.github.io/blog/tags/eslint/"}],"author":"along"},{"title":"css瀑布流","slug":"css瀑布流","date":"2019-10-12T16:00:00.000Z","updated":"2019-10-28T10:12:51.204Z","comments":true,"path":"2019/10/13/css瀑布流/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/10/13/css瀑布流/","excerpt":"","text":"纯 css 写瀑布流1.multi-columns 方式：通过 Multi-columns 相关的属性 column-count、column-gap配合 break-inside来实现瀑布流布局。 设置这样的 html 结构： ;) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 1 &lt;div class=&quot;masonry&quot;&gt; 2 &lt;div class=&quot;item&quot;&gt; 3 &lt;div class=&quot;item_content content-lar&quot;&gt; 1 4 &lt;/div&gt; 5 &lt;/div&gt; 6 &lt;div class=&quot;item&quot;&gt; 7 &lt;div class=&quot;item_content content-sma&quot;&gt; 2 8 &lt;/div&gt; 9 &lt;/div&gt;10 &lt;div class=&quot;item&quot;&gt; 11 &lt;div class=&quot;item_content content-mid&quot;&gt; 312 &lt;/div&gt; 13 &lt;/div&gt;14 &lt;div class=&quot;item&quot;&gt; 15 &lt;div class=&quot;item_content content-sma&quot;&gt; 416 &lt;/div&gt; 17 &lt;/div&gt;18 &lt;div class=&quot;item&quot;&gt; 19 &lt;div class=&quot;item_content content-mid&quot;&gt; 520 &lt;/div&gt; 21 &lt;/div&gt;22 &lt;div class=&quot;item&quot;&gt; 23 &lt;div class=&quot;item_content content-lar&quot;&gt; 624 &lt;/div&gt; 25 &lt;/div&gt; 26 &lt;div class=&quot;item&quot;&gt; 27 &lt;div class=&quot;item_content content-sma&quot;&gt; 728 &lt;/div&gt; 29 &lt;/div&gt;30 &lt;div class=&quot;item&quot;&gt; 31 &lt;div class=&quot;item_content content-lar&quot;&gt; 832 &lt;/div&gt; 33 &lt;/div&gt;34 &lt;div class=&quot;item&quot;&gt; 35 &lt;div class=&quot;item_content content-lar&quot;&gt; 936 &lt;/div&gt; 37 &lt;/div&gt;38 &lt;div class=&quot;item&quot;&gt; 39 &lt;div class=&quot;item_content content-sma&quot;&gt; 1040 &lt;/div&gt; 41 &lt;/div&gt;42 &lt;div class=&quot;item&quot;&gt; 43 &lt;div class=&quot;item_content content-mid&quot;&gt; 1144 &lt;/div&gt; 45 &lt;/div&gt;46 &lt;div class=&quot;item&quot;&gt; 47 &lt;div class=&quot;item_content content-mid&quot;&gt; 1248 &lt;/div&gt; 49 &lt;/div&gt;50 &lt;!-- more items --&gt; 51 &lt;/div&gt; ;) .masonry 是瀑布流容器，里面放置了列表 item，在 .masonry中设置 column-count（列数）和 column-gap（列间距） item 中设置 break-inside:avoid，这是为了控制文本块分解成单独的列，以免项目列表的内容跨列，破坏整体的布局。 在 css 中设置包裹 masonry 和 item 的属性样式： ;) 123456789101112131415161718 1 .masonry &#123; 2 -moz-column-count:3; /* Firefox */ 3 -webkit-column-count:3; /* Safari 和 Chrome */ 4 column-count:3; 5 -moz-column-gap: 2em; 6 -webkit-column-gap: 2em; 7 column-gap: 2em; 8 width: 80%; 9 margin:2em auto;10 &#125;11 .item &#123; 12 padding: 2em;13 margin-bottom: 2em;14 -moz-page-break-inside: avoid;15 -webkit-column-break-inside: avoid;16 break-inside: avoid;17 background: #f60;18 &#125; ;) 当然为了布局具有响应式效果，可以借助媒体查询属性，在不同屏幕大小的条件下设置瀑布流容器 masonry 的 column-count 来自适应改变列数： ;) 12345678910 1 @media screen and (max-width: 800px) &#123; 2 .masonry &#123; 3 column-count: 2; // two columns on larger phones 4 &#125; 5 &#125; 6 @media screen and (max-width: 500px) &#123; 7 .masonry &#123; 8 column-count: 1; // two columns on larger phones 9 &#125; 10 &#125; ;) 那么所产生的效果是： 也是根据屏幕大小自适应改变列数 2.flexbox 方式：html 的结构依旧和上面的 Multi-columns 展示的一样。只是在 .masonry容器中使用的 CSS 不一样： 在 .masonry中是通过采用 flex-flow来控制列，并且允许它换行。 这里关键是容器的高度，我这里要显式的设置 height属性，当然除了设置 px值，还可以设置100vh，让 .masonry容器的高度和浏览器视窗高度一样。 记住，这里height可以设置成任何高度值（采用任何的单位），但不能不显式的设置，如果没有显式的设置，容器就无法包裹住项目列表。 ;) 12345671 .masonry &#123; 2 height: 800px;3 display: flex; 4 flex-flow: column wrap;5 width: 80%;6 margin:2em auto;7 &#125; ;) 对于 .item，可以不再使用 break-inside:avoid，但其它属性可以是一样。 同样的，响应式设置，使用 Flexbox 实现响应式布局比多列布局 Multi-columns 要来得容易，他天生就具备这方面的能力，只不过我们这里需要对容器的高度做相关的处理。 前面也提到过了，如果不给 .masonry容器显式设置高度是无法包裹项目列表的，那么这里响应式设计中就需要在不同的媒体查询条件下设置不同的高度值： ;) 1234567891011121314151617181920 1 @media screen and (max-width: 1100px) &#123; 2 .masonry &#123; 3 height: 800px; 4 &#125; 5 &#125; 6 @media screen and (max-width: 800px) &#123; 7 .masonry &#123; 8 height: 1100px; 9 &#125; 10 &#125; 11 @media screen and (max-width: 600px) &#123; 12 .masonry &#123; 13 height: 1300px; 14 &#125; 15 &#125; 16 @media screen and (max-width: 460px) &#123; 17 .masonry &#123; 18 height: 1600px;19 &#125; 20 &#125; ;) 那么所产生的效果是： 也是根据屏幕大小自适应改变列数。 看到这里，我们可以发现，使用纯 css 写瀑布流，每一块 item 都是从上往下排列，不能做到从左往右排列： 这样子若是动态加载图片的瀑布流，体验就会很不好 我们想要的是这样： 这样做只能通过 js 来写瀑布流 js 写瀑布流：html 结构与上面类似，这里我用图片来做示例： ;) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 1 &lt;div class=&quot;masonry&quot;&gt; 2 &lt;div class=&quot;item&quot;&gt; 3 &lt;img class=&quot;lazy&quot; src=&quot;images/1.jpg&quot; alt=&quot;&quot; /&gt; 4 &lt;/div&gt; 5 &lt;div class=&quot;item&quot;&gt; 6 &lt;img class=&quot;lazy&quot; src=&quot;images/2.jpg&quot; alt=&quot;&quot; /&gt; 7 &lt;/div&gt; 8 &lt;div class=&quot;item&quot;&gt; 9 &lt;img class=&quot;lazy&quot; src=&quot;images/3.jpg&quot; alt=&quot;&quot; /&gt;10 &lt;/div&gt;11 &lt;div class=&quot;item&quot;&gt; 12 &lt;img class=&quot;lazy&quot; src=&quot;images/4.jpg&quot; alt=&quot;&quot; /&gt;13 &lt;/div&gt;14 &lt;div class=&quot;item&quot;&gt; 15 &lt;img class=&quot;lazy&quot; src=&quot;images/5.jpg&quot; alt=&quot;&quot; /&gt;16 &lt;/div&gt;17 &lt;div class=&quot;item&quot;&gt; 18 &lt;img class=&quot;lazy&quot; src=&quot;images/6.jpg&quot; alt=&quot;&quot; /&gt;19 &lt;/div&gt; 20 &lt;div class=&quot;item&quot;&gt; 21 &lt;img class=&quot;lazy&quot; src=&quot;images/7.jpg&quot; alt=&quot;&quot; /&gt;22 &lt;/div&gt;23 &lt;div class=&quot;item&quot;&gt; 24 &lt;img class=&quot;lazy&quot; src=&quot;images/8.jpg&quot; alt=&quot;&quot; /&gt;25 &lt;/div&gt;26 &lt;div class=&quot;item&quot;&gt; 27 &lt;img class=&quot;lazy&quot; src=&quot;images/9.jpg&quot; alt=&quot;&quot; /&gt;28 &lt;/div&gt;29 &lt;div class=&quot;item&quot;&gt; 30 &lt;img class=&quot;lazy&quot; src=&quot;images/10.jpg&quot; alt=&quot;&quot; /&gt;31 &lt;/div&gt;32 &lt;div class=&quot;item&quot;&gt; 33 &lt;img class=&quot;lazy&quot; src=&quot;images/11.jpg&quot; alt=&quot;&quot; /&gt;34 &lt;/div&gt;35 &lt;div class=&quot;item&quot;&gt; 36 &lt;img class=&quot;lazy&quot; src=&quot;images/12.jpg&quot; alt=&quot;&quot; /&gt;37 &lt;/div&gt;38 &lt;div class=&quot;item&quot;&gt; 39 &lt;img class=&quot;lazy&quot; src=&quot;images/13.jpg&quot; alt=&quot;&quot; /&gt;40 &lt;/div&gt;41 &lt;div class=&quot;item&quot;&gt; 42 &lt;img class=&quot;lazy&quot; src=&quot;images/14.jpg&quot; alt=&quot;&quot; /&gt;43 &lt;/div&gt;44 &lt;div class=&quot;item&quot;&gt; 45 &lt;img class=&quot;lazy&quot; src=&quot;images/15.jpg&quot; alt=&quot;&quot; /&gt;46 &lt;/div&gt;47 &lt;div class=&quot;item&quot;&gt; 48 &lt;img class=&quot;lazy&quot; src=&quot;images/16.jpg&quot; alt=&quot;&quot; /&gt;49 &lt;/div&gt;50 &lt;div class=&quot;item&quot;&gt; 51 &lt;img class=&quot;lazy&quot; src=&quot;images/17.jpg&quot; alt=&quot;&quot; /&gt;52 &lt;/div&gt;53 &lt;div class=&quot;item&quot;&gt; 54 &lt;img class=&quot;lazy&quot; src=&quot;images/18.jpg&quot; alt=&quot;&quot; /&gt;55 &lt;/div&gt;56 &lt;div class=&quot;item&quot;&gt; 57 &lt;img class=&quot;lazy&quot; src=&quot;images/19.jpg&quot; alt=&quot;&quot; /&gt;58 &lt;/div&gt;59 &lt;div class=&quot;item&quot;&gt; 60 &lt;img class=&quot;lazy&quot; src=&quot;images/20.jpg&quot; alt=&quot;&quot; /&gt;61 &lt;/div&gt;62 &lt;div class=&quot;item&quot;&gt; 63 &lt;img class=&quot;lazy&quot; src=&quot;images/21.jpg&quot; alt=&quot;&quot; /&gt;64 &lt;/div&gt;65 &lt;div class=&quot;item&quot;&gt; 66 &lt;img class=&quot;lazy&quot; src=&quot;images/22.jpg&quot; alt=&quot;&quot; /&gt;67 &lt;/div&gt;68 &lt;div class=&quot;item&quot;&gt; 69 &lt;img class=&quot;lazy&quot; src=&quot;images/23.jpg&quot; alt=&quot;&quot; /&gt;70 &lt;/div&gt;71 &lt;div class=&quot;item&quot;&gt; 72 &lt;img class=&quot;lazy&quot; src=&quot;images/24.jpg&quot; alt=&quot;&quot; /&gt;73 &lt;/div&gt;74 &lt;/div&gt; ;) css 内容： ;) 123456789101112131415161718192021222324252627 1 .masonry &#123; 2 width: 100%; 3 margin-top: 50px; 4 position:relative; 5 &#125; 6 .item &#123; 7 z-index: 10; 8 transition: 0.25s; 9 overflow: hidden;10 position: absolute;11 &#125;12 .item img&#123;13 width: 100%;14 height:100%;15 transition: 0.25s;16 &#125;17 .item:hover img&#123;18 z-index: 100;19 transition: 0.25s;20 overflow: hidden;21 animation: bounceIn 0.25s ease-in 2 alternate;22 &#125;23 @keyframes bounceIn&#123;24 100% &#123;25 transform: scale(1.07);26 &#125;27 &#125; ;) js 瀑布流实现方式： css 的绝对定位方式：根据每张图片的位置设置 top 和 left 值： ;) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 1 //瀑布流效果 2 //这里有一个坑（已经修复）： 3 //因为是动态加载远程图片，在未加载完全无法获取图片宽高 4 //未加载完全就无法设定每一个item(包裹图片)的top。 5 6 //item的top值：第一行：top为0 7 // 其他行：必须算出图片宽度在item宽度的缩小比例，与获取的图片高度相乘，从而获得item的高度 8 // 就可以设置每张图片在瀑布流中每块item的top值（每一行中最小的item高度，数组查找） 9 //item的left值：第一行：按照每块item的宽度值*块数10 // 其他行：与自身上面一块的left值相等11 function waterFall() &#123;12 // 1- 确定图片的宽度 - 滚动条宽度13 var pageWidth = getClient().width-8;14 var columns = 3; //3列15 var itemWidth = parseInt(pageWidth/columns); //得到item的宽度16 $(&quot;.item&quot;).width(itemWidth); //设置到item的宽度17 18 var arr = [];19 20 $(&quot;.masonry .item&quot;).each(function(i)&#123;21 var height = $(this).find(&quot;img&quot;).height();22 var width = $(this).find(&quot;img&quot;).width();23 var bi = itemWidth/width; //获取缩小的比值24 var boxheight = parseInt(height*bi); //图片的高度*比值 = item的高度25 26 if (i &lt; columns) &#123;27 // 2- 确定第一行28 $(this).css(&#123;29 top:0,30 left:(itemWidth) * i31 &#125;);32 arr.push(boxheight);33 34 &#125; else &#123;35 // 其他行36 // 3- 找到数组中最小高度 和 它的索引37 var minHeight = arr[0];38 var index = 0;39 for (var j = 0; j &lt; arr.length; j++) &#123;40 if (minHeight &gt; arr[j]) &#123;41 minHeight = arr[j];42 index = j;43 &#125;44 &#125;45 // 4- 设置下一行的第一个盒子位置46 // top值就是最小列的高度 47 $(this).css(&#123;48 top:arr[index],49 left:$(&quot;.masonry .item&quot;).eq(index).css(&quot;left&quot;)50 &#125;);51 52 // 5- 修改最小列的高度 53 // 最小列的高度 = 当前自己的高度 + 拼接过来的高度54 arr[index] = arr[index] + boxheight;55 &#125;56 &#125;);57 &#125;58 59 60 //clientWidth 处理兼容性61 function getClient() &#123;62 return &#123;63 width: window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth,64 height: window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight65 &#125;66 &#125;67 68 69 70 // 页面尺寸改变时实时触发71 window.onresize = function() &#123;72 //重新定义瀑布流73 waterFall();74 &#125;;75 76 77 78 //初始化79 window.onload = function()&#123;80 81 //实现瀑布流82 waterFall();83 84 &#125; ;) 效果图是： 这实现了横向排列的瀑布流效果","categories":[{"name":"css","slug":"css","permalink":"https://WLL-1017065322.github.io/blog/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://WLL-1017065322.github.io/blog/tags/css/"},{"name":"瀑布流","slug":"瀑布流","permalink":"https://WLL-1017065322.github.io/blog/tags/瀑布流/"}],"author":"along"},{"title":"chrome使用技巧","slug":"chrome使用技巧","date":"2019-10-08T16:00:00.000Z","updated":"2019-10-28T10:12:24.492Z","comments":true,"path":"2019/10/09/chrome使用技巧/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/10/09/chrome使用技巧/","excerpt":"","text":"Chrome的隐身模式先来说说隐身模式的启用方法吧 1.键盘快捷：Ctrl + Shift + N。 2.在Windows7下的任务栏处，右击“Chrome”图标，会出一个下拉菜单，点击“新建隐身窗口”。 3.你还可以在一个正在浏览的页面中，通过“右键点击链接”出现下拉菜单，选择“在隐身窗口中打开链接”，直接进入隐身窗口（如下图）。 简单一点的说，Chrome的隐身模式的好处就是保持你的隐私。具体表现在在此窗口中查看的网页不会显示在浏览器历史记录或搜索历史记录中，关闭隐身窗口后也不会在计算机上留下 Cookie 之类的其他痕迹，但会保留所有下载的文件或创建的书签，一般什么情境下你会使用Chrome的隐身模式呢 1、在注册网上银行等业务方面的网站时 2、你用朋友的电脑上网，而又不想在“历史记录”中被他发现你上了哪些网站 Chrome最强大的地方莫过于有各种各样的插件了，那如何在隐身模式下启用或禁用插件呢？点击右上角“扳手“–》”更多工具“–》”扩展程序”，在这个页面中，你可以选择哪些插件可以用于Chrome的隐身模式 事实上隐身模式并非是万能的，Chrome给出的建议是在以下一些情况下谨防失效： 收集或共享有关您的信息的网站 跟踪您访问的网页的互联网服务提供商或雇主 以提供免费表情符号的名义跟踪您击键情况的恶意软件 通过秘密代理进行监视的行为 站在身后的人 Chrome下各种组合键 热键组合 实现的功能 F1 Google浏览器帮助中心 F12 打开Chrome控制台 Ctrl+J 进入“下载内容”页面 Ctrl+H 查看“历史记录”页面 Ctrl+D 将此页加入书签 Ctrl+F 打开/关闭 搜索框（搜索页面内的文字） Ctrl+P 打开打印窗口 Ctrl+T 新建标签页 Ctrl+W 关闭标签页 Ctrl++ 放大页面 Ctrl+- 缩小页面 Ctrl+0 默认页面字体大小 Ctrl+Shift+T 重新打开最近关闭的一个标签 Ctrl+N 新建一个窗口 Ctrl+Shift+N 新建一个隐身模式窗口 Ctrl+Tab 从左到右，标签循环浏览 Ctrl+Shift+Tab 从右到左，标签循环浏览 Ctrl+1-8 分别指向第1、2、3…8标签 Ctrl+9 跳转到最后一个标签 Ctrl+Shift+Del 打开“清除浏览数据”窗口 Ctrl+Shift+B 显示/隐藏书签栏 Shift+Esc 开打Chrome任务管理器 Alt+Home 在当前标签打开首页 Alt+D/Ctrl+L 迅速突出地址栏 Ctrl+Enter 在地址栏自动添加www或.com Ctrl+Shift+V 粘帖剪切板中的纯文本格式 Shift+Alt+T 将焦点聚集到工具栏中的第一个工具 Tab (after Shift+Alt+T) 工具栏中将焦点移到各个选项上 Space or Enter (after Shift+Alt+T) 可激活工具栏按钮 Shift+F10 (after Shift+Alt+T) 可打开相关右键菜单 Esc (after Shift+Alt+T) 可将焦点从工具栏移回到网页上 Chrome的about指令估计很多人不知道Chrome地址栏功能，作为一个Chrome用户，必须懂的。以下我要介绍的这些指令在Chrome地址栏输入即可 about:version – 显示当前版本 也可以是chrome-resource://about/ about:plugins – 显示已安装插件 about:histograms – 显示历史记录 chrome://history2 – 浏览历史 History2 about:dns – 显示DNS状态 about:cache, 重定向到 view-cache: 显示缓存页面 view-cache:stats – 缓存状态 about:stats – 显示状态 chrome-resource://new-tab/ – 新标签页 about:memory – 可以查看内存和进程占用。也可以Shift+ESC，点击Statistics for nerds（傻瓜统计信息） about:flags – Chrome高级设置 也许大家看到上面 这一大片的指令，估计都没有动手去试试的欲望了。 事实上你根本就无需记这些指令，你只需要记住一个万能的就行，那就是chrome://about/ 你在Chrome地址栏输入这个，就会出现如下截图，哈哈，万能吧！（还有好多，我只截了一部分哦） 下面我就针对一些重要的指令一一介绍一下！（别嫌麻烦哦，真心挺有用的） chrome://accessibility 查看浏览器当前访问的标签用于查看浏览器当前访问的标签，打开全局访问模式可以查看：各个标签页面的文档系统树，大家看到的效果图如下所示： chrome://appcache-internals/ 对HTML5应用的离线存储进行管理这个我就不细说了，只有你浏览HTML5网站时才会有显示缓存记录，这时用这个命令就可以对HTML5应用的离线存储进行管理 chrome://apps/ Chrome网上应用商店使用这个命令就可以快速打开Chrome网上应用商店 chrome://bookmarks Chrome书签管理相信大家平常少不了用书签来记录一些自己认为特别好的网站以便后时之需。哈哈，这时这条命令就派上用场了。 chrome://cache/ Chrome缓存哎，对于这个指令，我只能说看看而已吧，别太认真了。因为它只能用于查看，却不能进行其它操作。 不过，虽然是查看，却可以带来异样的感觉。比如说点击某个缓存的图片文件它会用16进制的方法显示缓存文件 关于Chrome chrome://chrome/和chrome://help/想自动升级Chrome的用它吧，不过不知道为什么有两条指令。（不过也许这就是条条大道通罗马吧 哈哈 扯远了） 关于Chrome的相关功能 chrome://about/和chrome://chrome-urls/显示所有 chrome 的相关功能的连接 chrome://components/ 查看相关组件如果你相看看相关组件是否需要升级，可以使用它哦。 chrome://conflicts/ 查看所有已经载入或者将要载入主要程序中的 dll 模块这个功能不太懂是….也许是为了调试用的吧 chrome://crashes/ 停用启用崩溃报告如果启用的话将使用情况统计信息和崩溃报告自动发送给 Google chrome://credits/ 查看第三方软件许可证除此之外还可以查看某个软件的主页（源码），点击下图所示的show license试试 chrome://devices/查看设备，比如链接的打印机 chrome://dns/ 查看DNS记录DNS记录查看，如果有网络故障记得先来找他，chrome 还会定时更新hosts的DNS chrome://downloads/ 查看下载文件查看下载文件的记录。这个命令太有用了。也是我最最经常使用的。 chrome://extensions/ 查看扩展程序这个没啥好说的，大家都知道Chrome最强大的地方就在于有各种各校的插件和各式各样的扩展程序。那这些扩展程序主要是干嘛呢，无非就是由某些大神开发用于提高咱们的工作效率的 chrome://plugins/ 停用启用相关插件chrome://flags/这个更没啥好说的，没专业技能不要修改默认设置，比如 GPU的某些设置。 chrome://flash/ flash插件的详细信息 chrome://gcm-internals/ 消息推送服务Google Cloud Messaging for Android 是谷歌新推出的云推送消息服务，简称 GCM。该服务可帮助你将数据从服务端发送至应用 chrome://history/ 查看历史记录查看访问的历史记录 chrome://indexeddb-internals/ 查看 html5的本地存储列出使用你本地存储的 html5站点，然后你可以“强制清除”它，或者“下载”它 chrome://inspect/ 查看开发工具这个对于开发人员来说应该最体贴的功能啦，包括设备、检查页面 、扩展、App、共享、服务等选项卡。上图就知道了 chrome://invalidations/ 失效的调试程序失效的调试信息，可以查看调试日志以及内部详细信息。这个我还真没摸出它的价值来，有知道的可以告诉我一下。 chrome://media-internals/ 查看媒体内部数据用来调试在线播放的一些数据，比如测试 音频流 chrome://memory-redirect/ 查看内存信息查看 chrome 各个 网页标签、插件 消耗的内存 chrome://memory-internals/每个页面、插件详细的内存信息；点击 Update 可以获取json格式的进程，以及可视化的信息：PID、Name(Browser/GPU/TAB/History)、Memory…… chrome://nacl/本地客户端 Native Client 环境信息，包括浏览器、操作系统、插件等 chrome://net-internals Chrome的抓包工具 chrome://newtab 打开新的标签chrome://omnibox/ 智能地址栏我只能说这个大强大了，太实用了。你用用就知道它的厉害了 chrome://predictors/ URl输入命中率结合 omnibox 一起使用看看的智能程序。 chrome://policy/ 编辑策略chrome://print/ 调用打印机chrome://profiler/ 分析器 chrome://serviceworker-internals/ 调试服务chrome://quota-internals/ 显示磁盘详细可用空间以及各个网站的使用配额chrome://settings/ 设置chrome://signin-internals/ 内部标签包括，基础信息、上一次更新、登陆令牌、账户 chrome://sync-internals/ 各种同步记录chrome://system/ 系统诊断数据chrome://terms/ 查看Chrome服务条款chrome://thumbnails/ 近期浏览的网站的首页快照（以相册的形式）我不得不说一下，这个确实好玩。（还是忍不住暴露了一下女生天生爱玩的特质） chrome://translate-internals/ 内部翻译器chrome://tracing/ 追踪访问URL，包括浏览和渲染的过程这个对开发人员来说太实用了。上图就知道啦 chrome://user-actions/chrome://user-actions/ 监听用户行为监听用户行为，比如你的鼠标点击事件，访问url事件都会被记录下来。哈哈，你看，连我切换浏览器都被捕获到了。是不是挺强大的。","categories":[{"name":"其他","slug":"其他","permalink":"https://WLL-1017065322.github.io/blog/categories/其他/"}],"tags":[{"name":"chrome","slug":"chrome","permalink":"https://WLL-1017065322.github.io/blog/tags/chrome/"}],"author":"along"},{"title":"node session","slug":"node session","date":"2019-10-05T16:00:00.000Z","updated":"2019-10-28T10:14:05.669Z","comments":true,"path":"2019/10/06/node session/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/10/06/node session/","excerpt":"","text":"最近使用node写了接口，想实现用户密码的录功能，其中使用了express-session来保存数据，奇怪的是，发送post请求时获取不到req.session的值， 1234567891011121314router.get(&apos;./api/get_captcha,(req,res)=&gt;&#123; //这是一个获取图形验证码的接口 cosnt captcha = svgCaptcha.create(&#123; color:true, noise:1, size:4, ignoreChars:&apos;Oo0i1&apos; &#125;); //保存验证码到session req.session.captcha = captcha.text.toLocalLowerCase(); //返回给客户端 res.type(&apos;svg&apos;); res.status(200).sen(captcha.data);&#125;); 解决方法: 1 vue配置跨域 12345678910111213proxy: &#123; // 配置跨域 &apos;/api&apos;: &#123; target: &apos;http://localhost:4000&apos;, // 这里后台的地址模拟的;应该填写你们真实的后台接口 // target: &apos;http://vue.wanglvlong.top:4000/&apos;, ws: true, changOrigin: true, // 允许跨域 pathRewrite: &#123; &apos;^/api&apos;: &apos;&apos;, // 请求的时候使用这个api就可以 &#125;, &#125;, &#125;, 2 调整一下use的顺序试一下，我的也遇到过这种问题，我的是把app.use(app.router);放到session之前就会undefined，之后就好了，具体为什么我还没追代码，你可以试下把bodyParser、cookie、session放到最前面","categories":[{"name":"node","slug":"node","permalink":"https://WLL-1017065322.github.io/blog/categories/node/"}],"tags":[{"name":"node","slug":"node","permalink":"https://WLL-1017065322.github.io/blog/tags/node/"},{"name":"session","slug":"session","permalink":"https://WLL-1017065322.github.io/blog/tags/session/"}],"author":"along"},{"title":"mongoose saveupdat","slug":"mongoose saveupdat","date":"2019-10-05T16:00:00.000Z","updated":"2019-10-28T10:14:16.052Z","comments":true,"path":"2019/10/06/mongoose saveupdat/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/10/06/mongoose saveupdat/","excerpt":"","text":".save()和update() update比find之后save()效率高，因为这样不用读取整个文档。 Mongoose的update是MongoDB的update，但是Mongoose的save可能是MongoDB的插入或是update。 关于save，mongoose会自动diff新文档，只更改更新部分。这有利于原子性。 update不能触发中间件，validation默认不能，但是可以修改。 update()和findOneAndUpdate() update()返回数据处理条数 findOneAndUpdate()返回处理后的数据 简单来说，你需要获取数据就用findOneAndUpdate()，只需要修改数据而不关注修改后数据那就用update()。 首先有两个概念。您的应用程序是客户端，Mongodb是服务器。 主要区别在于，.save()在客户端代码中已经有一个对象，或者必须先从服务器检索数据，然后再写回整个内容。 在另一方面.update()也不会需要加载从服务器客户端的数据。所有交互都发生在服务器端，而无需检索到客户端.update()。因此，当您向现有文档中添加内容时，这种方式会非常有效。 此外，还有一个multi参数，该参数.update()允许对多个符合查询条件的文档执行操作。 便捷方法中有一些在您.update()用作呼叫时会松懈的东西，但是某些操作的好处是您必须承担“权衡”。有关此信息和可用选项的更多信息，请参阅文档。 简而言之.save()是客户端接口，.update()是服务器端。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://WLL-1017065322.github.io/blog/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://WLL-1017065322.github.io/blog/tags/数据库/"},{"name":"mongod","slug":"mongod","permalink":"https://WLL-1017065322.github.io/blog/tags/mongod/"}],"author":"along"},{"title":"chrome开发者工具","slug":"chrome开发者工具 ","date":"2019-10-04T16:00:00.000Z","updated":"2019-10-28T10:12:34.779Z","comments":true,"path":"2019/10/05/chrome开发者工具 /","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/10/05/chrome开发者工具 /","excerpt":"","text":"由于F12是前端开发人员的利器，所以我自己也在不断摸索中，查看一些博客和资料后，自己总结了一下来帮助自己理解和记忆，也希望能帮到有需要的小伙伴，嘿嘿！ 首先介绍Chrome开发者工具中，调试时使用最多的三个功能页面是：元素（ELements）、控制台（Console）、源代码（Sources），此外还有网络（Network）等。 元素（Elements）：用于查看或修改HTML元素的属性、CSS属性、监听事件、断点等。控制台（Console）：控制台一般用于执行一次性代码，查看JavaScript对象，查看调试日志信息或异常信息。源代码（Sources）：该页面用于查看页面的HTML文件源代码、JavaScript源代码、CSS源代码，此外最重要的是可以调试JavaScript源代码，可以给JS代码添加断点等。网络（Network）：网络页面主要用于查看header等与网络连接相关的信息。 1、元素（Elements）查看元素代码：点击如图箭头（或用者用快捷键Ctrl+Shift+C）进入选择元素模式，然后从页面中选择需要查看的元素，然后可以在开发者工具元素（Elements）一栏中定位到该元素源代码的具体位置 。 查看元素属性：可从被定位的源码中查看部分，如class、src，也可在右边的侧栏中查看全部的属性，如下图位置查看 修改元素的代码与属性：可直接双击想要修改的部分，然后就进行修改，或者选中要修改部分后点击右键进行修改，如下图 注意：这个修改也仅对当前的页面渲染生效，不会修改服务器的源代码，故而这个功能也是作为调试页面效果而使用。 右边的侧栏个功能的介绍:如下图所示 2、控制台（Console）查看JS对象的及其属性执行JS语句查看控制台日志：当网页的JS代码中使用了console.log()函数时，该函数输出的日志信息会在控制台中显示。日志信息一般在开发调试时启用，而当正式上线后，一般会将该函数去掉。 3、源代码（Sources）其主要功能如下介绍 4、网络（Network）大体功能如下： 请求文件具体说明 一共分为四个模块： Header：面板列出资源的请求url、HTTP方法、响应状态码、请求头和响应头及它们各自的值、请求参数等等Preview：预览面板，用于资源的预览。Response：响应信息面板包含资源还未进行格式处理的内容Timing：资源请求的详细信息花费时间 Application面板简介该面板主要是记录网站加载的所有资源信息，包括存储数据（Local Storage、Session Storage、IndexedDB、Web SQL、Cookies）、缓存数据、字体、图片、脚本、样式表等。 这个面板跟前前面几道硬菜（Network面板、Timeline面板、Profiles面板）比起来简单多了，这里就稍微作一下介绍： Local Storage 如果你在开发过程中使用了local storage来存储键值对(KVPs)，那么你就可以通过Local Storage窗格来检查、新增、修改、删除这个键值对。 Application Cache 你可以使用Application Cache窗格去查看通过Application Cache API创建的资源。 Frames 将页面上的资源按frame类别进行组织显示。 Frames窗格在上图中可以查看到顶级的top是一个主文档，在top下面是主文档的Fonts、Images、Scripts、Stylesheets等资源。最后一个就是主文件自身。 在资源上右击后在弹出菜单选择Reveal in Network Panel，就会跳转到Network面板并定位到该资源的位置。 你也可以在Sources面板里面按frame类别来查看资源信息。 Security面板简介通过该面板你可以去调试当前网页的安全和认证等问题并确保您已经在你的网站上正确地实现HTTPS。 HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。 HTTPS和HTTP的区别主要为以下四点：① https协议需要到CA申请证书，一般免费证书很少，需要交费。② http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。③ http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。④ http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 如果网页是安全的，则会显示这样一条消息：This page is secure (valid HTTPS).。 通过点击View certificate可以查看main origin的服务器证书信息。点击左侧可以查看指定源的连接和证书详情。 如果网页是不安全的，则会显示：This page is not secure.。 该面板可以区分两种类型的不安全的页面： 如果被请求的页面通过HTTP提供服务，那么这个主源就会被标记为不安全。 如果被请求的页面是通过HTTPS获取的，但这个页面接着通过HTTP继续从其他来源检索内容，那么这个页面仍然被标记为不安全。这就是所谓的混合内容页面,混合内容页面只是部分受到保护,因为HTTP内容(非加密的内容)可以被嗅探者入侵,容易受到中间人攻击。 点击左侧则提供一个跳转到Network面板视图的链接信息。 中间人攻击(Man-in-the-Middle Attack,”MITM攻击”)是一种“间接”的入侵攻击，这种攻击模式是通过各种技术手段将受入侵者控制的一台计算机虚拟放置在网络连接中的两台通信计算机之间，这台计算机就称为“中间人”。 Audits面板简介对当前网页进行网络利用情况、网页性能方面的诊断，并给出一些优化建议。比如列出所有没有用到的CSS文件等。 选中Network Utilization、Web Page Performance，点击Run按钮，将会对当前页面进行网络利用率和页面的性能优化作出诊断，并给出相应的优化建议。 ## performance:运行时性能表现（runtime performance）指的是当你的页面在浏览器运行时的性能表现，而不是在下载页面的时候的表现。这篇指南将会告诉你怎么用Chrome DevToos Performance功能去分析运行时性能表现。在RAIL性能评估模型下，你可以在这篇指南中可以学到怎么去用这个performance功能去分析Response, Animation, 以及 Idle 这三个性能指标。 让我们开始吧在这篇指南中，我们会用Performance工具去分析一个现有的在线DEMO，然后教会你怎么去分析，从而找到性能瓶颈。 打开Chrome的匿名模式。匿名模式可以保证Chrome在一个相对干净的环境下运行。比如说，你安装了许多chrome插件，这些插件可能会影响我们分析性能表现。 在匿名模式下打开右边这个链接，DEMO，这个网页就是我们要用来分析的DEMO。这个页面里都是很多上下移动的蓝色小方块。 按下Command+Opiton+I（Mac）或者Control+shift+I (Windows, Linux) 来打开Devtools 模拟移动设备的CPU移动设备的CPU一般比台式机和笔记本弱很多。当你想分析页面的时候，可以用CPU控制器（CPU Throttling）来模拟移动端设备CPU。 在DevTools中，点击 Performance 的 tab。 确保 Screenshots checkbox 被选中 点击 Capture Settings（⚙️）按钮，DevTools会展示很多设置，来模拟各种状况 对于模拟CPU，选择2x slowdown，于是Devtools就开始模拟两倍低俗CPU 设置DEMO为了使得这个DEMO有相对统一的运行表现（不同的读者，机器的性能千差万别）。这个DEMO提供了自定义功能，用来确保这个DEMO的统一表现。 一直点击 Add 10 这个按钮直到你能很明显看到蓝色小方块移动变慢，在性能比较好的机器上，大概要点击20次左右。 点击 Optimize按钮，你会发现蓝色小方块会变的很快而且动画变得平滑。 点击 un-optimize 按钮，蓝色小方块又会变成之前的模样。 记录运行时性能表现在之前的DEMO中，当你运行优化模式的时候，蓝色小方块移动地非常快。为什么呢？明明两个模式都是移动了同样数量的小方块而且移动的时间也一样。那么现在我们在Performance界面下录制下发生的一切，并且学习如何分析这个记录，从而找到非优化模式下的性能瓶颈。 在DevTools中，点击 Record 。这时候Devtools就开始录制各种性能指标 等待几分钟 点击Stop按钮，Devtools停止录制，处理数据，然后显示性能报告 wow，看起来有非常多的数据，别害怕，我们一个一个来介绍 分析报告一旦你得到了页面的性能表现报告，那么就可以用它来分析页面的性能，从而找到性能瓶颈。 分析每一秒的帧FPS（frames per second）是用来分析动画的一个主要性能指标。能保持在60的FPS的话，那么用户体验就是不错的。 观察FPS图表，如果你发现了一个红色的长条，那么就说明这些帧存在严重问题，有可能导致非常差的用户体验。一般来说，绿色的长条越高，说明FPS越高，用户体验越好。 就在FPS图表下方，你会看到CPU图表。在CPU图表中的各种颜色与Summary面板里的颜色是相互对应的，Summary面板就在Performance面板的下方。CPU图表中的各种颜色代表着在这个时间段内，CPU在各种处理上所花费的时间。如果你看到了某个处理占用了大量的时间，那么这可能就是一个可以找到性能瓶颈的线索。 把鼠标移动到FPS，CPU或者NET图表之上，DevToos就会展示这个时间点界面的截图。左右移动鼠标，可以重发当时的屏幕录像。这被称为scrubbing, 他可以用来分析动画的各个细节。 在Frames图表中，把鼠标移动到绿色条状图上，Devtools会展示这个帧的FPS。每个帧可能都在60以下，都没有达到60的标准。 当然这个对于DEMO，可以相当容易观察到性能的问题。但是在现实使用场景下，就不是那么容易观察到了。所以要把常常使用这些工具来分析页面。 小功能：显示实时FPS面板 另外一个好用的小工具就是实时FPS面板，它可以实时展示页面的FPS指标 按下 Command+Shift+P（Mac）或者 Control+Shift+P(Windows, Linux) 打开命令菜单 输入Rendering，点选Show Rendering 在Rendering面板里，激活FPS Meter。FPS实时面板就出现在页面的右上方。 关闭FPS Meter只要按下Escape就可以了。这篇指南里暂时用不上这个功能。 定位瓶颈现在已经确定到这个页面的动画性能表现不太好，那么下一步就是找到为什么 注意Summary面板，你会发现CPU花费了大量的时间在rendering上。因为提高性能就是一门做减法的艺术，你的目标就是减少rendering的时间 展开Main图表，Devtools展示了主线程运行状况。X轴代表着时间。每个长条代表着一个event。长条越长就代表这个event花费的时间越长。Y轴代表了调用栈（call stack）。在栈里，上面的event调用了下面的event。 在性能报告中，有很多的数据。可以通过双击，拖动等等动作来放大缩小报告范围，从各种时间段来观察分析报告。 在事件长条的右上角出，如果出现了红色小三角，说明这个事件是存在问题的，需要特别注意。 双击这个带有红色小三角的的事件。在Summary面板会看到详细信息。注意reveal这个链接，双击它会让高亮触发这个事件的event。如果点击了app.js:94这个链接，就会跳转到对应的代码处。 在app.update这个事件的长条下方，有很多被触发的紫色长条。如果放大这些事件长条，你会看到它们每个都带有红色小三角。点击其中一个紫色事件长条，Devtools在Summary面板里展示了更多关于这个事件的信息。确实，这里有很多reflow的警告。 在summary面板里点击app.js:70链接，Devtools会跳转到需要优化的代码处 OK！Devtools里面还有很多很多指标需要你去探索，但是，对于怎么用Devtools去分析网页的运行时性能表现，你现在已经有了一个基本的概念。 之前有说到Element，Console，Sources大多运用于debug，Network可用于debug和查看性能，今天的主角Timeline(现已更名Performance)更多的是用在性能优化方面，它的作用就是记录与分析应用程序运行过程中所产生的活动。 认识Timeline 接下来开始详细的分析下每个标记处的作用(有几个还没标记出来的也有介绍，顺序是按照面板从左到右，从上到下) 记录按钮 是否需要对当前页面的运行进行记录，当打开记录按钮开始执行记录过程的时候，该按钮显示红色 清除按钮 按下后会清除之前的记录信息，瞬间白板 捕获列表 捕获满足后面所列出的条件的相关事件，在这个的右边有选择框供选择 js概况 js函数执行的信息，主要展现在事件调用瀑布图中 如图所示，我们能够看到函数的调用(这里截取了一段短时间内的事件瀑布图) 信息记录和记忆线 当打开状态时，记录在记录过程中如js堆内存、Node节点数等数据的记忆线 如下图，在该记忆线上移动鼠标，会在图的下面出现对应时间点时的各项指标数据 当打开memory时，会在NET下面产生一个HEAP展示图，该图展示了js堆内存的使用情况，如图 绘制信息 记录paint过程的信息，可以在paint profile细节面板中查看，记录绘制信息有产生一定的性能损耗 录制截屏和截屏列表 和network的捕获截屏是一样的，会产生一定的性能损耗，详情可查看Chrome 开发工具之Network 垃圾回收 针对记录过程所产生的垃圾进行回收，释放浏览器内存 FPS信息 页面活动时的FPS变化信息，通常设备的屏幕的刷新频率是60FPS，超过的话，则有可能产生卡顿现象，可参考这篇介绍 (需翻墙) 效果如下图，有两个地方可以显示FPS信息，当FPS过大时，会显示红色的长条，代表有个长帧。我们也可以观察到，上下两个区域的分红条状出现的时间点和持续的时间段是同步的。 CPU信息 记录浏览器内核的运行情况,以曲线区域图的形式展示。黄色的表示对js的操作所占内存(js代码评估及函数调用)，蓝色表示对html操作所占的内存(主要是html编译)，紫色表示对css操作所占的内存(css样式计算等)，灰色表示其他操作所占的内存 展示效果如下图所示： 网络请求信息 网络资源请求信息，以不同颜色的条状表示不同的资源。黄色表示是script文件，蓝色表示是html文件，紫色表示是css文件，绿色表示是媒体文件，灰色表示各种其他文件~ 若希望看network的详细情况，建议参考Chrome 开发工具之Network 效果如图: 推荐将FPS.CPU.NET合起来看，如下： 事件瀑布图 各种事件的信息大集合，24K钛合金狗眼已闪瞎，第一行代表随着时间推移而发生的事件，下面各行是第一行事件的子项，由下面的各项组成第一行的整体事件。瀑布图的信息与CPU使用情况相符合，可从下图中看出 具体效果如图所示(为方便查看，这里截取一段时间内的事件瀑布图) 当记录一个网站加载过程时，在事件瀑布面板会有三条虚线，绿色的表示第一次开始绘制页面，蓝色线代表DOM已加载完成，红色线表示页面加载完(包括资源引用) 效果图： 最新版本的chrome在js profile选择框前面加了个network选择框，当选择network时，会将此处作为network信息面板，可通过鼠标悬浮network面板上的条状来查看没个资源的请求情况 如图所示，最新版本的chrome-timeline面板 细节展示 展示所选事件的各项细节信息 summary(信息汇总） 所选事件的一个信息汇总 我们可以先在时间轴上选取一段区域，看看有些什么： 然后在事件瀑布图中选中一个事件看看： 可以看出，该汇总会将选中目标的内容大致信息展示出来。 bottom-up 根据事件耗时长短，反向列出事件列表，有分类可选(通过类型、域、子域、URL分类列出)，面板右边也有详细介绍，不过基本和左边相似，就不多介绍了。 效果图如下： 可以看出耗时最长的是html编译及其所花费的时间，其次是一个XHR请求…在这个面板的左上角还有分组筛选，将列表数据分别以activity、category、domain、subdomain、url归类到一起。 call-tree(事件调用的树形图) 可在树形图中查看各项事件的子项信息，及各子项的信息,同样也有分组筛选，规则同上，面板右边同上 效果如图所示(和bottom-up基本相同，不同的是事件调用跟踪信息更详细的列在了树形图上)： 而同一个事件在bottom-up里是这样的，简化了很多： event-log(事件日志) 明确列出各项事件的详细信息，可以进行关键字筛选，所耗时间筛选，事件类型筛选等，右边是详细信息，可看到函数调用栈的跟踪信息。 效果如图所示： layers 展示刷新到某帧时的页面，可让开发者明确页面每一帧的渲染情况 注意：在paint选择框勾选的情况下可用 面板召唤过程： 1.选择所选区块 2.选择长帧，出现layers面板 3.在layers面板浪起来 可以看到页面在这个长帧阶段后的绘制情况，旋转可看层级立体图，右侧也有列出当前帧的详细信息，如size大小、为啥要合并(什么是合并？看这篇文章)、内存评估等 paint profiler 页面绘制过程 注意：在paint选择框勾选的情况下可用 面板召唤过程： 1.选择一个paint事件，出现paint profiler面板 2.在paint profiler面板浪起来 绘制过程中可以选择一段区域，看这段区域内的页面绘制结果是什么样的，比如，在这个列表中，首先是导航的绘制，然后是右侧文章内容，然后是左侧几个小窗div的绘制。文字描述，相对图形来说的，只是给列出了选中区域的绘制事件列表及绘制信息，可点开看详细内容，比如有textsize、left、top等属性 Memory开发过程中难免会遇到内存问题，emmm… 本文主要记录一下Chrome排查内存问题的面板，官网也有，但有些说明和例子跟不上新的版本了，也不够详细… ！！！ 多图预警！！！ 简单的内存信息列表 如果只想查看当前浏览器的各个 tab 正在使用的内存量，则在 Setting - More Tools - Task Manager 即可。效果如下图： 那个列表里的可勾选项，没看错，是对于可选的信息数据列。 那个 End Process 按钮，没看错，选择一项后，可以在浏览器所起的任务列表里关闭改任务(任务可以是打开页面的 tab、Chrome 自身一些项目及扩展插件…为什么不是按钮上写的 process，因为这些任务里面只有部分是在机器进程列表里列出存在的，强行严格 ~ToT~ ) 需要看内存的实时变化过程，可以在 Chrome - Performance 面板查看时间轴上内存变化情况，其中会有 js Heap 记录的选项，详情参考 Chrome 开发工具之 Timeline/Performance Memory 面板初始 如果想要看更多的内存信息快照，则需要打开 Chrome 浏览器的开发者工具中的 Memory 面板了，下面就简单介绍一下该面板的使用。 它大概是长这样： 上面有三个按钮： Heap snapshot - 用以打印堆快照，堆快照文件显示页面的 javascript 对象和相关 DOM 节点之间的内存分配 Allocation instrumentation on timeline - 在时间轴上记录内存信息，随着时间变化记录内存信息。 Allocation sampling - 内存信息采样，使用采样的方法记录内存分配。此配置文件类型具有最小的性能开销，可用于长时间运行的操作。它提供了由 javascript 执行堆栈细分的良好近似值分配。 各自举些例子吧，方便理解 Heap snapshot 给个 html，里面只有一句 js 代码 var _testArray_____ = [ {value: ‘hello’} ]; ，打个堆栈看看： 右上那块区域，从左到右有三个操作：查看方式、对象归类的筛选、对象选择。 左边有 Summary 字样的那个，可以选择查看内存快照的方式，可选方式如下： Summary - 可以显示按构造函数名称分组的对象。使用此视图可以根据按构造函数名称分组的类型深入了解对象（及其内存使用），适用于跟踪 DOM 泄漏。 Comparison - 可以显示两个快照之间的不同。使用此视图可以比较两个（或多个）内存快照在某个操作前后的差异。检查已释放内存的变化和参考计数，可以确认是否存在内存泄漏及其原因。 Containment - 此视图提供了一种对象结构视图来分析内存使用，由顶级对象作为入口。 Statistic - 内存使用饼状的统计图。 附上 Comparison 效果，大致如下： 代码： ;) 123456789var _____testArray_____ = [&#123; value: &apos;hello&apos; &#125;]function someTodo() &#123; _____testArray_____.push(&#123; value: &apos;:::::::::&apos; &#125;)&#125;document.querySelector(&apos;#btn&apos;).addEventListener(&apos;click&apos;, someTodo, false) ;) 点击按钮后，数组中 push 了新的一项对象 图(array 那块列表展开就看不到下面列表了，就没展开)： 附上 Containment 视图，它的排列稍微有些不同，大致如下： 入口有： DOMWindow - 是被视为 JavaScript 代码 “全局” 对象的对象。 GC - VM 的垃圾使用的实际 GC 根。GC 根可以由内置对象映射、符号表、VM 线程堆栈、编译缓存、句柄作用域和全局句柄组成。 原生对象 - 是 “推送” 至 JavaScript 虚拟机内以允许自动化的浏览器对象，例如 DOM 节点和 CSS 规则。 中间的 Class filter 只能够按照列出来的 Constructor 值进行筛选。 右边的 All objects 能够选择查看哪些阶段的对象、如 “Objects allocated before Snapshot1”、”Objects allocated between Snapshot1 and Snapshot2” 右中那块区域显示的内存快照信息，可以在各个数据上右键选择一些操作( Reveal in Summary view )，各个字段代表信息如下： Contructor - 表示使用此构造函数创建的所有对象 Distance - 显示使用节点最短简单路径时距根节点的距离 Shallow Size - 显示通过特定构造函数创建的所有对象浅层大小的总和。浅层大小是指对象自身占用的内存大小（一般来说，数组和字符串的浅层大小比较大） Retained Size - 显示同一组对象中最大的保留大小。某个对象删除后（其依赖项不再可到达）可以释放的内存大小称为保留大小。 #New - Comparison 特有 - 新增项 #Deleted - Comparison 特有 - 删除项 #Delta - Comparison 特有 - 增量 Alloc. Size - Comparison 特有 - 内存分配大小 Freed Size - Comparison 特有 - 释放大小 Size Delta - Comparison 特有 - 内存增量 右下那块区域显示的是被选中对象的详细信息，如上面图片的内容一样一样的…可以在各个数据上右键选择一些操作( Reveal in Summary view )。 注意：图中最最下面那块最有用，就是搜索，ctrl/command + f 唤出 ~ 最后，根据上面的图来分析一下上面代码产生的效果，根据 js 的类型和引用的关系来分析，变量 _testArray_____ 在列表中的情况是： 基础类型 string 值为 hello ，内存标记是 string@353953，这个 string 值存在于 Object @362113 对象上的 value 属性上； Object @362113 在 Object 列表里，在 Array @356493 的索引 0 位置存在该对象的引用； Array @356493 在 Window / @353829 对象上存在引用，属性名为”testArray“； Window / @353829 是个 Windows 对象，在 Windows 列表里。 ;) 1234567&quot;hello&quot; -&gt; 在(string)列表里 -&gt; string@353953 -&gt; value in Object @362113 Object -&gt; 在 Object 列表里 -&gt; [0] in Array @356493 Array -&gt; 在(array)列表里 -&gt; _____testArray_____ in Window / @353829 Windows -&gt; 在 Windows 列表里 -&gt; Window / @353829 ;) Allocation instrumentation on timeline 看完静态的快照，再来看看动态的。 代码如下： ;) 12345678910111213var _____testArray_____ = [&#123; value: &apos;hello&apos; &#125;]var count = 1function someTodo() &#123; // 每次点击 字符串长度都以上一次为基础增加到5倍，拉大差异突出效果，并且之后在字符串头部加上count值做区分 count *= 5 var str = new Array(count * 10).join(&apos;:&apos;) _____testArray_____.push(&#123; value: count + str &#125;)&#125;document.querySelector(&apos;#btn&apos;).addEventListener(&apos;click&apos;, someTodo, false) ;) 选择 Allocation instrumentation on timeline 点击开始记录的按钮，然后得到如图所示： 每条线的高度与最近分配的对象大小对应，竖线的颜色表示这些对象是否仍然显示在最终的堆快照中。蓝色竖线表示在时间线最后对象仍然显示，灰色竖线表示对象已在时间线期间分配，但曾对其进行过垃圾回收。(这图中不是很明显，放大 devtool 面板后，图中的蓝色线顶部是有部分是灰色的…) 可以选择时间范围，查看该时间范围内的内存变化情况，如上图 5 次变化的情况分别是： ;) 123456789101112131415161718192021222324252627282930313233343536# 前面的数字代表本次记录索引，点击了5次# 0 Shallow Size : 112Constructor Distance Shallow Size Retained Size- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -(array)×9 3 5008 0% 5008 0%(system)×60 3 2416 0% 2640 0%(closure)×1 3 4768 0% 2928 0%Object×3 3 144 0% 768 0%MouseEvent×3 4 112 0% 7200 0%(string)×2 5 96 0% 96 0%(concatenated string)×2 4 64 0% 160 0%Event 5 56 0% 2040 0%UIEvent 5 32 0% 648 0%# 1(string)×2 5 296 0% 296 0%(concatenated string)×2 4 64 0% 360 0%Object 3 32 0% 392 0%# 2(string)×2 5 1296 0% 1296 0%(concatenated string)×2 4 64 0% 1360 0%Object 3 32 0% 1392 0%# 3(string)×2 5 6296 0% 6296 0%(concatenated string)×2 4 64 0% 6360 0%Object 3 32 0% 6392 0%# 4(string)×2 5 31296 0% 31296 0%(array) 4 80 0% 80 0%(concatenated string)×2 4 64 0% 31360 0%(system) 4 32 0% 32 0%Object 3 32 0% 31392 0% ;) 当勾选 Record allocation stacks 框后，还可以在 Allocation stack 面板里打印出调用堆栈。 如上面代码的效果： Allocation sampling 这个功能根据名称和说明，不是很看得懂是什么… 但是，还是通过一些案例给出了效果图，如下： 根据给出的图，可以看出这块的功能应该是：哪些函数影响了内存的分配，并且该函数所耗内存在内存分配中占比多少。 图中函数可以直接点击跳转到函数定义的文件和位置。","categories":[{"name":"其他","slug":"其他","permalink":"https://WLL-1017065322.github.io/blog/categories/其他/"}],"tags":[{"name":"chrome","slug":"chrome","permalink":"https://WLL-1017065322.github.io/blog/tags/chrome/"}],"author":"along"},{"title":"mongodb导入csv","slug":"mongodb导入csv","date":"2019-10-01T16:00:00.000Z","updated":"2019-10-28T10:14:22.948Z","comments":true,"path":"2019/10/02/mongodb导入csv/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/10/02/mongodb导入csv/","excerpt":"","text":"主要介绍使用自带工具mongoimport工具将 CSV 格式数据导入到 MongoDB 的详细过程。 由于官方提供了mongoimport工具，所以实际上导入 CSV 格式数据的过程非常简单，再次体现了越是强大的工具使用起来越简单。 创建数据库如果已经有要导入的数据库存在，忽略此步骤，直接查看“导入数据”部分即可。 首先启动 mongodb shell 控制台，直接在终端输入 1mongo 查看数据库和列表 如果没有需要导入的数据库，可以创建一个，具体执行 1234show dbsuse networkdb.myCollection.insertOne( &#123; x: 1 &#125; );show dbs show dbs：查看当前存在的数据库； use network：这里network是上面查询结果中没有的，当没有时，使用use会自动创建一个新的数据库； db.myCollection.insertOne( { x: 1 } );：为了能使show dbs时出现刚才创建的那个数据库，使用这条命令插入一条数据； show dbs：查看刚创建的数据库。 我之前已经创建好数据库了，这里以将 csv 数据导入network1数据库为例。 导入数据导入数据一句命令即可 mongoimport –db network1 –collection networkmanagement –type csv –headerline –ignoreBlanks –file /home/erik/Documents/networkmanagement-1.csv1–db network1：需要将数据导入到哪个数据库，这里以networ1数据库为例；–collection networkmanagement：将数据导入的 collection 名，这里以networkmanagement为例，如果这个networkmanagement之前是不存在的，则会自动创建一个。如果省略–collection networkmanagement这个参数，那么会自动新建一个以 CSV 文件名为名的 collection。–type csv：文件类型，这里是 csv；–headerline：这个参数很重要，加上这个参数后创建完成后的内容会以 CSV 第一行的内容为字段名；–ignoreBlanks：这个参数可以忽略掉 CSV 文件中的空缺值；–file /home/erik/Documents/networkmanagement-1.csv：这里就是 csv 文件的路径了。 查看导入后的数据这里使用 adminMongo 查看导入后的数据，这样更直观，adminMongo 安装过程可以参考：MongoDB可视化图形界面mongo-express/adminMongo安装过程 首先要启动 MongoDB service mongod start 然后打开 adminMongo进入到/usr/local/node/node-v6.11.2-linux-x64/lib/node_modules/admin-mongo，然后执行 npm start 启动完成后，在浏览器输入 http://0.0.0.0:1234查看network1中的networkmanagement数据。 至此，数据导入完成。 参考资料mongoimport — MongoDB Manual 3.4：https://docs.mongodb.com/manual/reference/program/mongoimport/","categories":[{"name":"数据库","slug":"数据库","permalink":"https://WLL-1017065322.github.io/blog/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://WLL-1017065322.github.io/blog/tags/数据库/"},{"name":"mongod","slug":"mongod","permalink":"https://WLL-1017065322.github.io/blog/tags/mongod/"}],"author":"along"},{"title":"项目遇到的问题-vue","slug":"项目遇到的问题-vue","date":"2019-09-30T16:00:00.000Z","updated":"2019-10-28T08:21:57.392Z","comments":true,"path":"2019/10/01/项目遇到的问题-vue/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/10/01/项目遇到的问题-vue/","excerpt":"","text":"shops项目: app.js 123&lt;keep-alive&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; 缓存导致,点击尺码,到达的页面是缓存的,而不是根据url 1 当引入keep-alive的时候，页面第一次进入，钩子的触发顺序created-&gt; mounted-&gt; activated，退出时触发deactivated。当再次进入（前进或者后退）时，只触发activated。链接：https://www.jianshu.com/p/42429f4d8f9e 2.监测$router的变化； 1234watch: &#123; // 如果路由有变化，会再次执行该方法 &quot;$route&quot;: &quot;fetchDate&quot;&#125; 3 .在keep-alive中直接添加 include，cachedViews（Array类型：包含vue文件的组件name都将被缓存起来）；反之exclude则是不包含； 注意：所有.vue组件文件都必须附上name属性！！！建议用vuex管理cachedViews 123&lt;keep-alive :include=&quot;cachedViews&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; 4.还有种情况，在不同路由应用了相同的vue组件 12&#123;path:&apos;aaa&apos;,component:Mompage,name:&apos;mom&apos;&#125;,&#123;path:&apos;bbb&apos;,component:Mompage,name:&apos;momPlus&apos;&#125; 默认情况下当这两个页面切换时并不会触发vue的created或者mounted钩子，需要手动的watch:$router（又回到上面的步骤），或者在router-view上加上唯一值。 1234567//随便抄一段代码过来&lt;router-view :key=&quot;key&quot;&gt;&lt;/router-view&gt;computed: &#123; key() &#123; return this.$route.name !== undefined? this.$route.name + +new Date(): this.$route + +new Date() &#125; &#125;","categories":[{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/categories/vue/"}],"tags":[{"name":"问题","slug":"问题","permalink":"https://WLL-1017065322.github.io/blog/tags/问题/"},{"name":"项目","slug":"项目","permalink":"https://WLL-1017065322.github.io/blog/tags/项目/"}],"author":"along"},{"title":"python-Selenium-WebDriverWait","slug":"python-Selenium-WebDriverWait","date":"2019-09-27T16:00:00.000Z","updated":"2019-10-28T10:13:57.258Z","comments":true,"path":"2019/09/28/python-Selenium-WebDriverWait/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/09/28/python-Selenium-WebDriverWait/","excerpt":"","text":"之前有篇文章介绍过Selenium的等待知识，可惜当时水平有限，只介绍了sleep和implicitly_wait的用法。今天还是补充一下WebDriverWait的知识吧。 一、webdrivewait 示例代码 12345678910111213141516from selenium import webdriverfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.common.by import Byimport timedriver = webdriver.Chrome()driver.get(\"http://www.baidu.com/\")locator = (By.ID,\"kw\"try: ele = WebDriverWait(driver,10).until(EC.presence_of_element_located(locator)) driver.find_element_by_id(\"kw\").send_keys('abc') time.sleep(1) #为了看效果except: print(\"ele can't find\")finally: driver.quit() 接下来一点点分析下这个语句 1WebDriverWait(driver,10).until(EC.presence_of_element_located(locator)) （1）WebDriverWait 方法 12345driver: 传入WebDriver实例，即我们上例中的drivertimeout: 超时时间，等待的最长时间（同时要考虑隐性等待时间）poll_frequency: 调用until或until_not中的方法的间隔时间，默认是0.5秒ignored_exceptions: 忽略的异常，如果在调用until或until_not的过程中抛出这个元组中的异常， 则不中断代码，继续等待，如果抛出的是这个元组外的异常，则中断代码，抛出异常。默认只有NoSuchElementException。 （2）WebDriverWait 方法后面有两种等待方式 until 12method: 在等待期间，每隔一段时间（__init__中的poll_frequency）调用这个传入的方法，直到返回值不是Falsemessage: 如果超时，抛出TimeoutException，将message传入异常 until_not 12与until相反，until是当某元素出现或什么条件成立则继续执行， until_not是当某元素消失或什么条件不成立则继续执行，参数也相同，不再赘述。 看了以上内容基本上很清楚了，调用方法如下： 1WebDriverWait(driver, 超时时长, 调用频率, 忽略异常).until(可执行方法, 超时时返回的信息) 这里需要特别注意的是until或until_not中的可执行方法method参数，很多人传入了WebElement对象，如下： 1WebDriverWait(driver, 10).until(driver.find_element_by_id('kw')) # 错误 这是错误的用法，这里的参数一定要是可以调用的，即这个对象一定有 __call__() 方法，否则会抛出异常： 1TypeError: &apos;xxx&apos; object is not callable 在这里，你可以用selenium提供的 expected_conditions 模块中的各种条件，也可以用WebElement的 is_displayed() 、is_enabled()、is_selected() 方法，或者用自己封装的方法都可以，那么接下来我们看一下selenium提供的条件有哪些： expected_conditions expected_conditions是selenium的一个模块，其中包含一系列可用于判断的条件： 1selenium.webdriver.support.expected_conditions（模块） 以下两个条件类验证title，验证传入的参数title是否等于或包含于driver.titletitle_is title_contains 以下两个条件验证元素是否出现，传入的参数都是元组类型的locator，如(By.ID, ‘kw’)顾名思义，一个只要一个符合条件的元素加载出来就通过；另一个必须所有符合条件的元素都加载出来才行presence_of_element_located presence_of_all_elements_located 以下三个条件验证元素是否可见，前两个传入参数是元组类型的locator，第三个传入WebElement第一个和第三个其实质是一样的visibility_of_element_located invisibility_of_element_located visibility_of 以下两个条件判断某段文本是否出现在某元素中，一个判断元素的text，一个判断元素的valuetext_to_be_present_in_element text_to_be_present_in_element_value 以下条件判断frame是否可切入，可传入locator元组或者直接传入定位方式：id、name、index或WebElementframe_to_be_available_and_switch_to_it 以下条件判断是否有alert出现alert_is_present 以下条件判断元素是否可点击，传入locatorelement_to_be_clickable 以下四个条件判断元素是否被选中，第一个条件传入WebElement对象，第二个传入locator元组第三个传入WebElement对象以及状态，相等返回True，否则返回False第四个传入locator以及状态，相等返回True，否则返回Falseelement_to_be_selected element_located_to_be_selected element_selection_state_to_be element_located_selection_state_to_be 最后一个条件判断一个元素是否仍在DOM中，传入WebElement对象，可以判断页面是否刷新了staleness_of 上面是所有17个condition，与until、until_not组合能够实现很多判断，如果能自己灵活封装，将会大大提高脚本的稳定性。 图片懒加载 图片懒加载是一种网页优化技术。图片作为一种网络资源，在被请求时也与普通静态资源一样，将占用网络资源，而一次性将整个页面的所有图片加载完，将大大增加页面的首屏加载时间。为了解决这种问题，通过前后端配合，使图片仅在浏览器当前视窗内出现时才加载该图片，达到减少首屏图片请求数的技术就被称为“图片懒加载”。 在网页源码中，在img标签中首先会使用一个“伪属性”（通常使用src2，original……）去存放真正的图片链接而并非是直接存放在src属性中。当图片出现到页面的可视化区域中，会动态将伪属性替换成src属性，完成图片的加载。 因此在爬虫时，对当前页加载的数据进行分析发起请求获取解析数据会出现数据解析不完整，究其原因很有可能是图片的懒加载技术导致，因此要在爬虫时要特别注意准确解析数据！（比如站长素材高清图片的爬取） ​ ​ selenium自动化（测试）工具 简介 selenium最初是一个自动化测试工具,而爬虫中使用它主要是为了解决requests无法直接执行JavaScript代码的问题 selenium本质是通过驱动浏览器，完全模拟浏览器的操作，比如跳转、输入、点击、下拉等，来拿到网页渲染之后的结果，可支持多种浏览器 环境安装 下载安装selenium：pip install selenium 下载浏览器驱动程序： http://chromedriver.storage.googleapis.com/index.html https://npm.taobao.org/mirrors/chromedriver 查看驱动和浏览器版本的映射关系： http://blog.csdn.net/huilan_same/article/details/51896672 简单使用 以百度搜索为例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 1 &apos;&apos;&apos; 2 下载浏览器驱动程序:https://npm.taobao.org/mirrors/chromedriver 3 查看驱动和浏览器版本的映射:http://blog.csdn.net/huilan_same/article/details/51896672 4 &apos;&apos;&apos; 5 import time 6 from lxml.html.clean import etree 7 8 from selenium import webdriver#pip install selenium 导入浏览器驱动 9 #（1）创建（谷歌等）浏览器,参数为浏览器驱动位置10 browser=webdriver.Chrome(r&quot;./chromedriver.exe&quot;)111213 #（2）通过浏览器发起get请求14 browser.get(&apos;https://www.baidu.com/&apos;)151617 #（3）进行关键字搜索等页面操作18 #①定位搜索框标签（可通过多种方式进行定位）19 search_input=browser.find_element_by_id(&apos;kw&apos;)20 #②定位搜索按钮21 search_button=browser.find_element_by_xpath(&apos;//input[@id=&quot;su&quot;]&apos;)22 #③在输入框输入关键字23 search_input.send_keys(&apos;selenium&apos;)24 time.sleep(2)25 #④清空输入框26 search_input.clear()27 time.sleep(2)28 search_input.send_keys(&apos;selenium工具包&apos;)29 time.sleep(2)30 #⑤点击搜索按钮31 search_button.click()32 time.sleep(2)33 #⑥向下滑动滚动条到底部34 browser.execute_script(&quot;window.scrollTo(0,document.body.scrollHeight)&quot;)35 time.sleep(2)36 #⑦向下滑动滚动条到顶部37 browser.execute_script(&quot;window.scrollTo(0,-document.body.scrollHeight)&quot;)38 time.sleep(2)394041 #获取当前页面内容进行说数据解析42 page_text=browser.page_source43 print(etree.HTML(page_text).xpath(&apos;//span[@class=&quot;nums_text&quot;]/text()&apos;)[0])444546 # 处理弹出的警告页面:确定accept() 和 取消dismiss()47 # browser.switch_to_alert().accept()48 # time.sleep(2)495051 #（3）关闭浏览器52 # browser.close()53 browser.quit() 浏览器驱动 Selenium支持非常多的浏览器，如Chrome、Firefox、Edge等，还有Android、BlackBerry等手机端的浏览器。另外，也支持无界面浏览器PhantomJS。 1234567&gt; from selenium import webdriver&gt; browser = webdriver.Chrome()&gt; browser = webdriver.Firefox()&gt; browser = webdriver.Edge()&gt; browser = webdriver.PhantomJS()&gt; browser = webdriver.Safari()&gt; 元素定位 1234567891011&gt; webdriver 提供了一系列的元素定位方法，常用的有以下几种：&gt; &gt; find_element_by_id()&gt; find_element_by_name()&gt; find_element_by_class_name()&gt; find_element_by_tag_name()&gt; find_element_by_link_text()&gt; find_element_by_partial_link_text()&gt; find_element_by_xpath()&gt; find_element_by_css_selector()&gt; 注意 1、find_element_by_xxx找的是第一个符合条件的标签，find_elements_by_xxx找的是所有符合条件的标签。 2、根据ID、CSS选择器和XPath获取，它们返回的结果完全一致。 3、另外，Selenium还提供了通用方法find_element()，它需要传入两个参数：查找方式By和值。实际上，它就是find_element_by_id()这种方法的通用函数版本，比如find_element_by_id(id)就等价于find_element(By.ID, id)，二者得到的结果完全一致。 节点交互（文本输出与清空） Selenium可以驱动浏览器来执行一些操作，也就是说可以让浏览器模拟执行一些动作。比较常见的用法有：输入文字时用send_keys()方法，清空文字时用clear()方法，点击按钮时用click()方法。 12345678910111213141516171819&gt; import time&gt; &gt; from selenium import webdriver&gt; &gt; browser=webdriver.Chrome(r&quot;./chromedriver.exe&quot;)&gt; &gt; browser.get(&apos;https://www.baidu.com/&apos;)&gt; &gt; search_input=browser.find_element_by_id(&apos;kw&apos;)&gt; search_input.send_keys(&apos;selenium&apos;)#输入文字&gt; &gt; time.sleep(2)&gt; &gt; &gt; &gt; search_input.clear()#清空文字&gt; &gt; time.sleep(2) &gt; 动作链 一些交互动作是针对某个节点执行的。比如，对于输入框，我们就调用它的输入文字和清空文字方法；对于按钮，就调用它的点击方法。其实，还有另外一些操作，它们没有特定的执行对象，比如鼠标拖曳、键盘按键等，这些动作用另一种方式来执行，那就是动作链。 12345678910111213141516171819202122232425262728293031323334353637 1 # 实现一个节点的拖曳操作，将某个节点从一处拖曳到另外一处，可以这样实现 2 import time 3 from selenium import webdriver 4 from selenium.webdriver import ActionChains 5 6 browser = webdriver.Chrome(r&apos;./chromedriver.exe&apos;) 7 browser.get(&quot;https://www.runoob.com/try/try.php?filename=jqueryui-api-droppable&quot;) 8 9 # 分析页面标签可以发现页面中嵌套了html，实用的是frame框架，因此需要先定位iframe10 browser.switch_to_frame(&quot;iframeResult&quot;) # 通过id定位iframe1112 # 找到要拖动的标签和要拖动到的标签13 start = browser.find_element_by_id(&quot;draggable&quot;)14 end = browser.find_element_by_id(&quot;droppable&quot;)15 # 实例化动作对象16 actions = ActionChains(browser)1718 # (1)拖拽动作，参数为起始对象，perform()立即执行19 # actions.drag_and_drop(start,end).perform()20 # time.sleep(2)2122 # (2)缓慢执行拖动动作23 actions.click_and_hold(start)24 for i in range(5):25 actions.move_by_offset(xoffset=18,yoffset=0).perform()26 time.sleep(0.5)27 actions.release()28 start.click()29 time.sleep(2)303132 # 处理页面的弹出警示框33 browser.switch_to_alert().accept()34 time.sleep(2)3536 browser.close()37 browser.quit() 执行JavaScript 对于某些操作，Selenium API并没有提供。比如，下拉进度条，它可以直接模拟运行JavaScript，此时使用execute_script()方法即可实现。 12345678910111213 1 import time 2 from selenium import webdriver 3 4 browser = webdriver.Chrome() 5 browser.get(&apos;https://www.jd.com/&apos;) 6 time.sleep(1) 7 browser.execute_script(&apos;window.scrollTo(0, document.body.scrollHeight)&apos;)#操作滚动条 8 time.sleep(2) 9 browser.execute_script(&apos;alert(&quot;123&quot;)&apos;)#操作警示弹窗10 time.sleep(2)11 browser.switch_to_alert().accept()12 time.sleep(2)13 browser.quit() 获取页面源码数据 通过page_source属性可以获取网页的源代码，接着就可以使用解析库（如正则表达式、Beautiful Soup、pyquery等）来提取信息了。 1234567891011121314151617 1 import time 2 from lxml.html.clean import etree 3 4 from selenium import webdriver 5 6 browser=webdriver.Chrome(r&quot;./chromedriver.exe&quot;) 7 browser.get(&apos;https://www.baidu.com/&apos;) 8 search_input=browser.find_element_by_id(&apos;kw&apos;) 9 search_button=browser.find_element_by_xpath(&apos;//input[@id=&quot;su&quot;]&apos;)10 search_input.send_keys(&apos;selenium工具包&apos;)11 time.sleep(2)12 search_button.click()13 time.sleep(2)1415 page_text=browser.page_source#获取页面源码16 print(etree.HTML(page_text).xpath(&apos;//span[@class=&quot;nums_text&quot;]/text()&apos;)[0])17 browser.quit() 前进和后退 模拟浏览器的前进和回退功能 1234567891011121314 1 import time 2 from selenium import webdriver 3 browser=webdriver.Chrome() 4 5 browser.get(&apos;https://www.baidu.com/&apos;) 6 browser.get(&apos;https://www.jd.com/&apos;) 7 browser.get(&apos;https://www.sina.com.cn/&apos;) 8 9 time.sleep(3)10 browser.back()#浏览器后退11 time.sleep(3)12 browser.forward()#浏览器前进13 time.sleep(3)14 browser.close() 规避被检测识别 不少大网站有对selenium采取了监测机制。比如正常情况下我们用浏览器访问淘宝等网站的 window.navigator.webdriver的值为 undefined。而使用selenium访问则该值为true。因此需要设置Chromedriver的启动参数来解决问题。 在启动Chromedriver之前，为Chrome开启实验性功能参数excludeSwitches，它的值为[&#39;enable-automation&#39;] 12345671 from selenium import webdriver2 from selenium.webdriver import ChromeOptions3 option=ChromeOptions()4 option.add_experimental_option(&apos;excludeSwitches&apos;, [&apos;enable-automation&apos;])5 browser=webdriver.Chrome(options=option)67 browser.get(&apos;https://www.baidu.com/&apos;) Cookie处理 selenium模拟浏览器操作，可以不用考虑在页面数据获取时cookie问题，但是如果想操作cookie,使用Selenium也是可以实现的，例如获取、添加、删除Cookies等。 123456781 from selenium import webdriver2 browser = webdriver.Chrome()3 browser.get(&apos;https://www.baidu.com&apos;)4 print(browser.get_cookies())5 browser.add_cookie(&#123;&apos;name&apos;: &apos;name&apos;, &apos;value&apos;: &apos;12345&apos;&#125;)6 print(browser.get_cookies())7 browser.delete_all_cookies()8 print(browser.get_cookies()) phantomJS PhantomJS是一款无界面的浏览器，其自动化操作流程和上述操作谷歌浏览器是一致的。由于是无界面的，为了能够展示自动化操作流程，PhantomJS为用户提供了一个截屏的功能，使用save_screenshot函数实现。PhantomJS下载地址：https://phantomjs.org/download.html，目前已经停止维护和更新，因此不建议使用，可以使用谷歌的无头浏览器。 12345678910111213141516171819202122232425262728293031323334 1 from selenium import webdriver 2 import time 3 4 # phantomjs路径 5 path = r&apos;PhantomJS驱动路径&apos; 6 browser = webdriver.PhantomJS(path) 7 8 # 打开百度 9 url = &apos;http://www.baidu.com/&apos;10 browser.get(url)1112 time.sleep(3)1314 browser.save_screenshot(r&apos;phantomjs\\baidu.png&apos;)1516 # 查找input输入框17 my_input = browser.find_element_by_id(&apos;kw&apos;)18 # 往框里面写文字19 my_input.send_keys(&apos;美女&apos;)20 time.sleep(3)21 #截屏22 browser.save_screenshot(r&apos;phantomjs\\meinv.png&apos;)2324 # 查找搜索按钮25 button = browser.find_elements_by_class_name(&apos;s_btn&apos;)[0]26 button.click()2728 time.sleep(3)2930 browser.save_screenshot(r&apos;phantomjs\\show.png&apos;)3132 time.sleep(3)3334 browser.quit() ;) 谷歌无头浏览器 ;) 1234567891011121314151617181920 1 import time 2 from selenium import webdriver 3 from selenium.webdriver.chrome.options import Options 4 # 创建一个参数对象，用来控制chrome以无界面模式打开 5 chrome_options=Options() 6 chrome_options.add_argument(&apos;--headless&apos;) 7 chrome_options.add_argument(&apos;--disable-gpu&apos;) 8 9 #谷歌浏览器驱动路径10 chrome_path=r&apos;chromedriver.exe&apos;#当前目录1112 #创建浏览器对象13 # browser=webdriver.Chrome(executable_path=chrome_path, chrome_options=chrome_options)14 browser=webdriver.Chrome(chrome_path,chrome_options=chrome_options)151617 browser.get(&apos;https://www.baidu.com/&apos;)18 time.sleep(4)19 browser.save_screenshot(&apos;baidu.png&apos;)#截图20 browser.quit() ;)","categories":[{"name":"python","slug":"python","permalink":"https://WLL-1017065322.github.io/blog/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://WLL-1017065322.github.io/blog/tags/python/"},{"name":"Selenium","slug":"Selenium","permalink":"https://WLL-1017065322.github.io/blog/tags/Selenium/"},{"name":"WebDriverWait","slug":"WebDriverWait","permalink":"https://WLL-1017065322.github.io/blog/tags/WebDriverWait/"},{"name":"爬虫","slug":"爬虫","permalink":"https://WLL-1017065322.github.io/blog/tags/爬虫/"}],"author":"along"},{"title":"js类数组","slug":"js类数组","date":"2019-09-24T16:00:00.000Z","updated":"2019-10-28T10:14:48.837Z","comments":true,"path":"2019/09/25/js类数组/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/09/25/js类数组/","excerpt":"","text":"js类数组转数组的方法（ArrayLike）1. 什么是类数组ArrayLike 拥有length属性，其它属性（索引）为非负整数(对象中的索引会被当做字符串来处理，这里你可以当做是个非负整数串来理解) 不具有数组所具有的方法 123456//类数组示例var a = &#123;&apos;1&apos;:&apos;gg&apos;,&apos;2&apos;:&apos;love&apos;,&apos;4&apos;:&apos;meimei&apos;,length:5&#125;;Array.prototype.join.call(a,&apos;+&apos;);//&apos;+gg+love++meimei&apos;//非类数组示例var c = &#123;&apos;1&apos;:2&#125;; //没有length属性就不是类数组 javascript中常见的类数组有arguments对象和DOM方法的返回结果。比如 document.getElementsByTagName()。 2. 判断一个对象是否属于类数组1234567891011function isArrayLike(o) &#123; if (o &amp;&amp; // o is not null, undefined, etc. typeof o === &apos;object&apos; &amp;&amp; // o is an object isFinite(o.length) &amp;&amp; // o.length is a finite number o.length &gt;= 0 &amp;&amp; // o.length is non-negative o.length===Math.floor(o.length) &amp;&amp; // o.length is an integer o.length &lt; 4294967296) // o.length &lt; 2^32 return true; // Then o is array-like else return false; // Otherwise it is not&#125; 3. 类数组转换成数组之后进行操作有什么优势由于类数组不具有数组所具有的操作数组的方法，讲类数组转换为数组之后就能调用如shift,unshift,splice,slice,concat,reverse,sort等这些强大的方法，方便快捷。 4. 类数组转换为数组方法12Array.prototype.slice.call(arrayLike)//将arguments转化为数组后，截取第一个元素之后的所有元素 var args = Array.prototype.slice.call(arguments,1); 首先Array.prototype.slice.call(arrayLike)的结果是将arrayLike对象转换成一个Array对象。所以其后面可以直接调用数组具有的方法，例如 1Array.prototype.slice.call(arrayLike).forEach(function(element,index)&#123; //可以随意操作每一个element了 &#125;) （1）Array.prototype.slice表示数组的原型中的slice方法。注意这个slice方法返回的是一个Array类型的对象。 12345678910//slice的内部实现Array.prototype.slice = function(start,end)&#123; var result = new Array(); start = start || 0; end = end || this.length; //this指向调用的对象，当用了call后，能够改变this的指向，也就是指向传进来的对象，这是关键 for(var i = start; i &lt; end; i++)&#123; result.push(this[i]); &#125; return result; &#125; （2）能调用call的只有方法，所以不能用[].call这种形式，得用[].slice。而call的第一个参数表示真正调用slice的环境变为了arrayLike对象。所以就好像arrayLike也具有了数组的方法。 （3）附上转成数组的通用函数 1234567891011var toArray = function(s)&#123; try&#123; return Array.prototype.slice.call(s); &#125; catch(e)&#123; var arr = []; for(var i = 0,len = s.length; i &lt; len; i++)&#123; //arr.push(s[i]); arr[i] = s[i]; //据说这样比push快 &#125; return arr; &#125; 5. 将数组转换为参数列表（类数组）调用apply方法的时候,第一个参数是对象(this), 第二个参数是一个数组集合, 这里就说明apply的一个巧妙用法，可以将一个**数组默认的转换为一个参数列表**([param1,param2,param3] 转换为 param1,param2,param3)， 这个如果让我们用程序来实现将数组的每一个项,来转换为参数的列表,可能都得费一会功夫,借助apply的这点特性,所以就有了以下高效率的方法。 具体可以参考前面的文章 js函数中的apply()、call()、bind()方法 —（apply的其他巧妙用法（一般在什么情况下可以使用apply）） 参考来源 1.https://www.inkling.com/read/javascript-definitive-guide-david-flanagan-6th/chapter-7/array-like-objects2.JavaScript 的怪癖 8：“类数组对象” 3.js类数组转数组的方法","categories":[{"name":"js","slug":"js","permalink":"https://WLL-1017065322.github.io/blog/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://WLL-1017065322.github.io/blog/tags/js/"},{"name":"数组","slug":"数组","permalink":"https://WLL-1017065322.github.io/blog/tags/数组/"}],"author":"along"},{"title":"项目遇到的问题-node","slug":"项目遇到的问题-node","date":"2019-09-24T16:00:00.000Z","updated":"2019-10-28T08:21:16.518Z","comments":true,"path":"2019/09/25/项目遇到的问题-node/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/09/25/项目遇到的问题-node/","excerpt":"","text":"1 3t能查到数据,node查不到, model的type类型问题 1234let brandsList = await Shoe.find(​ &#123; sold_num: &#123; $gt: 0 &#125;, qty: &#123; $gt: 0 &#125; &#125;,​ &#123; brand: 1, _id: 0 &#125;​ );","categories":[{"name":"node","slug":"node","permalink":"https://WLL-1017065322.github.io/blog/categories/node/"}],"tags":[{"name":"问题","slug":"问题","permalink":"https://WLL-1017065322.github.io/blog/tags/问题/"}],"author":"along"},{"title":"js获取当前位置","slug":"js获取当前位置","date":"2019-09-17T16:00:00.000Z","updated":"2019-10-28T10:12:13.534Z","comments":true,"path":"2019/09/18/js获取当前位置/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/09/18/js获取当前位置/","excerpt":"","text":"由于项目需求，需要获取手机的当前位置，，，，，问度娘，然后做了一个小demo if(navigator.geolocation) { navigator.geolocation.getCurrentPosition( function (position) { var longitude = position.coords.longitude; var latitude = position.coords.latitude; console.log(longitude) console.log(latitude) }, function (e) { var msg = e.code; var dd = e.message; console.log(msg) console.log(dd) } ) } 解释1.检测是否支持地理定位2.如果支持输出地理坐标，如果不支持，给出提示","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"}],"author":"along"},{"title":"网页乱码","slug":"网页乱码","date":"2019-09-14T16:00:00.000Z","updated":"2019-10-28T08:20:01.209Z","comments":true,"path":"2019/09/15/网页乱码/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/09/15/网页乱码/","excerpt":"","text":"1，meta标签未设置 charset=“utf-8” 2, 复制到txt文本时编码错误。","categories":[{"name":"其他","slug":"其他","permalink":"https://WLL-1017065322.github.io/blog/categories/其他/"}],"tags":[{"name":"问题","slug":"问题","permalink":"https://WLL-1017065322.github.io/blog/tags/问题/"}],"author":"along"},{"title":"浏览器刷新不停","slug":"浏览器刷新不停","date":"2019-09-11T16:00:00.000Z","updated":"2019-10-28T08:19:31.981Z","comments":true,"path":"2019/09/12/浏览器刷新不停/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/09/12/浏览器刷新不停/","excerpt":"","text":"1 router.use(cookieParser()); //注意 cookieParser() 括号省去会是浏览器不停刷新 2 函数加了 async 1234567891011router.get(&quot;/usercenter&quot;, async(request, response) =&gt; &#123; // response.sendFile(__dirname + &quot;/public/register.html&quot;); // 1.获取cookie,读取cookie中的session编码 // 2.去服务器中匹配该编号对应的session容器 // 3.根据匹配结果,进行业务逻辑 // const &#123; _id &#125; = request.cookie; let filePath = resolve(__dirname, &quot;../public/usercenter.html&quot;); // console.log(request.cookie); response.send(filePath);&#125;);","categories":[{"name":"node","slug":"node","permalink":"https://WLL-1017065322.github.io/blog/categories/node/"}],"tags":[{"name":"node","slug":"node","permalink":"https://WLL-1017065322.github.io/blog/tags/node/"},{"name":"问题","slug":"问题","permalink":"https://WLL-1017065322.github.io/blog/tags/问题/"}],"author":"along"},{"title":"js clientHeight","slug":"js clientHeight","date":"2019-09-11T16:00:00.000Z","updated":"2019-10-28T10:14:57.493Z","comments":true,"path":"2019/09/12/js clientHeight/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/09/12/js clientHeight/","excerpt":"","text":"scrollHeight定义： 所有的内容（指图一图中有文字的红色框框内）和内边距，这个内容包括肉眼看不见、溢出、被窗口遮挡的部分； 还可以参考《JavaScript高级程序设计(第3版)》第324页； clientHeight定义： 图二中视野内可见的内容和内边距，不包括x轴的滚动条高度、边框、外边距； 同一种型号的手机上是不变的，比如iPhone 6上就是667px； 还可以参考《JavaScript高级程序设计(第3版)》第322页； offsetHeight定义 图二中，在clientHeight的基础上， 加上边框和滚动条的高度； 还可以参考《JavaScript高级程序设计(第3版)》第321页； scrollTop定义 见图三，滚动条滚动了多少距离（包括之前已滚动过的隐藏内容）就是scrollTop； 如果还不够清楚，还可以参考《JavaScript高级程序设计(第3版)》第324页； 获取方法在《JavaScript高级程序设计(第3版)》第198页，document.body是为了兼容IE浏览器，但在我实践过程中，发现chrome也需要document.body来获取这些数据，而不是document.ducumentElement。需要特意说明的是：这里的chrome是在device情况下，而且我的项目是运行在微信端。 为了兼容浏览器，用以下方法（举例）： 1234const scrollLeft = Math.max(document.documentElement.scrollLeft, document.body.scrollLeft); const scrollTop = Math.max(document.documentElement.scrollTop, document.body.scrollTop); 原因： 用Math.max()方法是因为获取方法不兼容时，scrollTop始终为0，其他属性同理；","categories":[{"name":"js","slug":"js","permalink":"https://WLL-1017065322.github.io/blog/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://WLL-1017065322.github.io/blog/tags/js/"},{"name":"clientHeight","slug":"clientHeight","permalink":"https://WLL-1017065322.github.io/blog/tags/clientHeight/"}],"author":"along"},{"title":"java运行不了","slug":"java运行不了","date":"2019-09-08T16:00:00.000Z","updated":"2019-10-28T10:15:01.829Z","comments":true,"path":"2019/09/09/java运行不了/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/09/09/java运行不了/","excerpt":"","text":"最近在看java，安装配置好了环境之后就准备写我的 “HelloWorld”，但是在运行第二个程序的时候发现我的运行结果还是helloworld，这是为什么呢？？？ 后来发现是我的main函数拼写错了，其实造成这样结果的原因可能如下： 有可能main函数拼写错了，写成mian； 主函数是不是忘写string[] args； 忘记加static修饰。","categories":[{"name":"java","slug":"java","permalink":"https://WLL-1017065322.github.io/blog/categories/java/"}],"tags":[{"name":"问题","slug":"问题","permalink":"https://WLL-1017065322.github.io/blog/tags/问题/"},{"name":"java","slug":"java","permalink":"https://WLL-1017065322.github.io/blog/tags/java/"}],"author":"along"},{"title":"类数组转化为数组","slug":"类数组转化为数组","date":"2019-09-06T16:00:00.000Z","updated":"2019-10-28T08:18:27.408Z","comments":true,"path":"2019/09/07/类数组转化为数组/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/09/07/类数组转化为数组/","excerpt":"","text":"1. 什么是类数组ArrayLike 拥有length属性，其它属性（索引）为非负整数(对象中的索引会被当做字符串来处理，这里你可以当做是个非负整数串来理解) 不具有数组所具有的方法 123456//类数组示例var a = &#123;&apos;1&apos;:&apos;gg&apos;,&apos;2&apos;:&apos;love&apos;,&apos;4&apos;:&apos;meimei&apos;,length:5&#125;;Array.prototype.join.call(a,&apos;+&apos;);//&apos;+gg+love++meimei&apos;//非类数组示例var c = &#123;&apos;1&apos;:2&#125;; //没有length属性就不是类数组 javascript中常见的类数组有arguments对象和DOM方法的返回结果。比如 document.getElementsByTagName()。 2. 判断一个对象是否属于类数组1234567891011function isArrayLike(o) &#123; if (o &amp;&amp; // o is not null, undefined, etc. typeof o === &apos;object&apos; &amp;&amp; // o is an object isFinite(o.length) &amp;&amp; // o.length is a finite number o.length &gt;= 0 &amp;&amp; // o.length is non-negative o.length===Math.floor(o.length) &amp;&amp; // o.length is an integer o.length &lt; 4294967296) // o.length &lt; 2^32 return true; // Then o is array-like else return false; // Otherwise it is not&#125; 3. 类数组转换成数组之后进行操作有什么优势由于类数组不具有数组所具有的操作数组的方法，讲类数组转换为数组之后就能调用如shift,unshift,splice,slice,concat,reverse,sort等这些强大的方法，方便快捷。 4. 类数组转换为数组方法12Array.prototype.slice.call(arrayLike)//将arguments转化为数组后，截取第一个元素之后的所有元素 var args = Array.prototype.slice.call(arguments,1); 首先Array.prototype.slice.call(arrayLike)的结果是将arrayLike对象转换成一个Array对象。所以其后面可以直接调用数组具有的方法，例如 1Array.prototype.slice.call(arrayLike).forEach(function(element,index)&#123; //可以随意操作每一个element了 &#125;) （1）Array.prototype.slice表示数组的原型中的slice方法。注意这个slice方法返回的是一个Array类型的对象。 12345678910//slice的内部实现Array.prototype.slice = function(start,end)&#123; var result = new Array(); start = start || 0; end = end || this.length; //this指向调用的对象，当用了call后，能够改变this的指向，也就是指向传进来的对象，这是关键 for(var i = start; i &lt; end; i++)&#123; result.push(this[i]); &#125; return result; &#125; （2）能调用call的只有方法，所以不能用[].call这种形式，得用[].slice。而call的第一个参数表示真正调用slice的环境变为了arrayLike对象。所以就好像arrayLike也具有了数组的方法。 （3）附上转成数组的通用函数 1234567891011var toArray = function(s)&#123; try&#123; return Array.prototype.slice.call(s); &#125; catch(e)&#123; var arr = []; for(var i = 0,len = s.length; i &lt; len; i++)&#123; //arr.push(s[i]); arr[i] = s[i]; //据说这样比push快 &#125; return arr; &#125; 5. 将数组转换为参数列表（类数组）调用apply方法的时候,第一个参数是对象(this), 第二个参数是一个数组集合, 这里就说明apply的一个巧妙用法，可以将一个**数组默认的转换为一个参数列表**([param1,param2,param3] 转换为 param1,param2,param3)， 这个如果让我们用程序来实现将数组的每一个项,来转换为参数的列表,可能都得费一会功夫,借助apply的这点特性,所以就有了以下高效率的方法。 具体可以参考前面的文章 js函数中的apply()、call()、bind()方法 —（apply的其他巧妙用法（一般在什么情况下可以使用apply））","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"},{"name":"数组","slug":"数组","permalink":"https://WLL-1017065322.github.io/blog/tags/数组/"}],"author":"along"},{"title":"跨域导致cookie设置失败","slug":"跨域导致cookie设置失败","date":"2019-09-03T16:00:00.000Z","updated":"2019-10-28T08:17:43.111Z","comments":true,"path":"2019/09/04/跨域导致cookie设置失败/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/09/04/跨域导致cookie设置失败/","excerpt":"","text":"nodejs 跨域设置cookie在做vue全家桶+express 做项目。 想做一个免登陆功能，选择session方案。 服务器设置session 后， 返回的响应头有Set-Cookie,但是浏览器的Application的cookies缺没有返回的sessionID的cookie。 折腾了很久，才意识到这是跨域造成了问题。前端是8080端口，后端是4000端口。 默认情况下跨域请求浏览器不会携带凭证信息（cookie, ssl证明等），服务器设置的cookie也会被浏览器拦截 所以解决方案是 前端的ajax后者axios需要设置withCredentials为true。我的是axios，这样请求会携带上cookie 同时后端使用cors中间件。 即可 ;) 1234567891011//需要安装并且引入中间件corsconst cors = require(&apos;cors&apos;);var corsOptions = &#123; origin: &apos;http://localhost:8080&apos;, credentials: true, maxAge: &apos;1728000&apos; //这一项是为了跨域专门设置的&#125;app.use(cors(corsOptions))//设置跨域 ;) 如果不用中间件，也可以这样，显示的设置 1Access-Control-Allow-Credentials 为true 注意origin不能是*号.。 这样浏览器就不会拦截服务器设置的cookie了 ;) 12345671 app.all(&apos;*&apos;, function(req, res, next) &#123;2 res.header(&quot;Access-Control-Allow-Origin&quot;, req.headers.origin); //需要显示设置来源3 res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, X-Requested-With, Content-Type, Accept&quot;);4 res.header(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;);5 res.header(&quot;Access-Control-Allow-Credentials&quot;,true); //带cookies7 res.header(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;);8 next();9 &#125;); ;) nodejs端 （适用于 express koa egg） 123456789const cors = require(&apos;cors&apos;);var app=express();var corsOptions = &#123; origin: &apos;http://localhost:8080&apos;, credentials: true, maxAge: &apos;1728000&apos; //这一项是为了跨域专门设置的&#125;app.use(cors(corsOptions)) 1、前端 vue ajax请求解决cookie跨域 vue-resource123456789101112this.$http.get(&apos;getlogin&apos;,&#123; credentials: true &#125;).then(res =&gt; &#123; console.log(res) &#125;) this.$http.post(&apos;postlogin&apos;,&#123;userInfo: $(&apos;.form-signin&apos;).serialize()&#125;,&#123; credentials: true &#125;).then(res =&gt; &#123; console.log(res) if(res.body.status != 200) &#123; console.log(&apos;登录失败&apos;) &#125;else &#123; console.log(&apos;登录成功&apos;) &#125; &#125;) 2、原生js中ajax请求api cookie跨域12345var xhr = new XMLHttpRequest();xhr.open(&apos;GET&apos;, &apos;http://www.xxx.com/api&apos;);xhr.withCredentials = true;xhr.onload = onLoadHandler;xhr.send() 3、jquery中ajax请求api cookie跨域1234567891011$.ajax(&#123; url: &quot;http://localhost:8080/orders&quot;, type: &quot;GET&quot;, xhrFields: &#123; withCredentials: true &#125;, crossDomain: true, success: function (data) &#123; render(data); &#125; &#125;); 4.axios ajax请求api cookie跨域 （vue react angular通用）123456789const service = axios.create(&#123; baseURL: process.env.BASE_API, // node环境的不同，对应不同的baseURL timeout: 5000, // 请求的超时时间 //设置默认请求头，使post请求发送的是formdata格式数据// axios的header默认的Content-Type好像是&apos;application/json;charset=UTF-8&apos;,我的项目都是用json格式传输，如果需要更改的话，可以用这种方式修改 // headers: &#123; // &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot; // &#125;, withCredentials: true // 允许携带cookie&#125;) 3.3.3 设置 Access-Control-Allow-Origin: * 就行吗带cookie的跨域 当我们需要发送带 cookie 的请求时，Access-Control-Allow-Origin 直接设置为通配符 * 时是无法通过浏览器的检查的，此时该响应头的值必须与发出请求的域完全匹配才行，另外，还需要设置 Access-Control-Allow-Credentials 响应头的值为 true，表示支持带 cookie 的跨域请求。 3.3.4 CORS请求头和响应头总结请求头： Origin： 浏览器发出 Ajax 跨域请求之前会添加此头部，值为发送请求的域 Access-Control-Request-Method：使用了除 GET、POST 请求方法之外的方法，浏览器会添加此头部，值为当前请求方法 Access-Control-Request-Headers：使用了自定义头部或除了Accept、Accept-Language、Content-Language、Content-Type 之外的头部，浏览器会添加此头部，值为当前的请求方法 响应头： Access-Control-Allow-Origin： 表示服务端允许哪些域请求资源 Access-Control-Allow-Methods： 当客户端包含 Access-Control-Request-Method 请求头时，服务端需要响应该头部，值通常由 Reauest 的 header 中 Access-Control-Request-Method 取得 Access-Control-Allow-Headers： 当客户端包含 Access-Control-Request-Headers 请求头时，服务端需要响应该头部，值通常由 Reauest 的 header 中 Access-Control-Request-Headers 取得 Access-Control-Expose-Headers： 指出客户端通过 XHR 对象的 getResponseHeaders 方法可以获取的响应头有哪些 Access-Control-Allow-Credentials： 允许带 cookie 的跨域请求 Access-Control-Max-Age： 预检请求的缓存时间","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/categories/javascript/"}],"tags":[{"name":"跨域","slug":"跨域","permalink":"https://WLL-1017065322.github.io/blog/tags/跨域/"},{"name":"cookie","slug":"cookie","permalink":"https://WLL-1017065322.github.io/blog/tags/cookie/"}],"author":"along"},{"title":"跨域","slug":"跨域","date":"2019-08-31T16:00:00.000Z","updated":"2019-10-28T08:17:03.979Z","comments":true,"path":"2019/09/01/跨域/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/09/01/跨域/","excerpt":"","text":"什么是跨域？跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。 广义的跨域： 1231.) 资源跳转： A链接、重定向、表单提交2.) 资源嵌入： &lt;link&gt;、&lt;script&gt;、&lt;img&gt;、&lt;frame&gt;等dom标签，还有样式中background:url()、@font-face()等文件外链3.) 脚本请求： js发起的ajax请求、dom和js对象的跨域操作等 其实我们通常所说的跨域是狭义的，是由浏览器同源策略限制的一类请求场景。 什么是同源策略？同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。 同源策略限制以下几种行为： 1231.) Cookie、LocalStorage 和 IndexDB 无法读取2.) DOM 和 Js对象无法获得3.) AJAX 请求不能发送 常见跨域场景1234567891011121314151617181920URL 说明 是否允许通信http://www.domain.com/a.jshttp://www.domain.com/b.js 同一域名，不同文件或路径 允许http://www.domain.com/lab/c.jshttp://www.domain.com:8000/a.jshttp://www.domain.com/b.js 同一域名，不同端口 不允许 http://www.domain.com/a.jshttps://www.domain.com/b.js 同一域名，不同协议 不允许 http://www.domain.com/a.jshttp://192.168.4.12/b.js 域名和域名对应相同ip 不允许 http://www.domain.com/a.jshttp://x.domain.com/b.js 主域相同，子域不同 不允许http://domain.com/c.js http://www.domain1.com/a.jshttp://www.domain2.com/b.js 不同域名 不允许 跨域解决方案1、 通过jsonp跨域2、 document.domain + iframe跨域3、 location.hash + iframe4、 window.name + iframe跨域5、 postMessage跨域6、 跨域资源共享（CORS）7、 nginx代理跨域8、 nodejs中间件代理跨域9、 WebSocket协议跨域 一、 通过jsonp跨域通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。 1.）原生实现： 12345678910111213&lt;script&gt; var script = document.createElement(&apos;script&apos;); script.type = &apos;text/javascript&apos;; // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数 script.src = &apos;http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback&apos;; document.head.appendChild(script); // 回调执行函数 function handleCallback(res) &#123; alert(JSON.stringify(res)); &#125;&lt;/script&gt; 服务端返回如下（返回时即执行全局函数）： 1handleCallback(&#123;&quot;status&quot;: true, &quot;user&quot;: &quot;admin&quot;&#125;) 2.）jquery ajax： 1234567$.ajax(&#123; url: &apos;http://www.domain2.com:8080/login&apos;, type: &apos;get&apos;, dataType: &apos;jsonp&apos;, // 请求方式为jsonp jsonpCallback: &quot;handleCallback&quot;, // 自定义回调函数名 data: &#123;&#125;&#125;); 3.）vue.js： 123456this.$http.jsonp(&apos;http://www.domain2.com:8080/login&apos;, &#123; params: &#123;&#125;, jsonp: &apos;handleCallback&apos;&#125;).then((res) =&gt; &#123; console.log(res); &#125;) 后端node.js代码示例： 1234567891011121314151617var querystring = require(&apos;querystring&apos;);var http = require(&apos;http&apos;);var server = http.createServer();server.on(&apos;request&apos;, function(req, res) &#123; var params = qs.parse(req.url.split(&apos;?&apos;)[1]); var fn = params.callback; // jsonp返回设置 res.writeHead(200, &#123; &apos;Content-Type&apos;: &apos;text/javascript&apos; &#125;); res.write(fn + &apos;(&apos; + JSON.stringify(params) + &apos;)&apos;); res.end();&#125;);server.listen(&apos;8080&apos;);console.log(&apos;Server is running at port 8080...&apos;); jsonp缺点：只能实现get一种请求。 二、 document.domain + iframe跨域此方案仅限主域相同，子域不同的跨域应用场景。 实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。 1.）父窗口：(http://www.domain.com/a.html) 12345&lt;iframe id=&quot;iframe&quot; src=&quot;http://child.domain.com/b.html&quot;&gt;&lt;/iframe&gt;&lt;script&gt; document.domain = &apos;domain.com&apos;; var user = &apos;admin&apos;;&lt;/script&gt; 2.）子窗口：(http://child.domain.com/b.html) 12345&lt;script&gt; document.domain = &apos;domain.com&apos;; // 获取父窗口中变量 alert(&apos;get js data from parent ---&gt; &apos; + window.parent.user);&lt;/script&gt; 三、 location.hash + iframe跨域实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。 具体实现：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。 1.）a.html：(http://www.domain1.com/a.html) 1234567891011121314&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById(&apos;iframe&apos;); // 向b.html传hash值 setTimeout(function() &#123; iframe.src = iframe.src + &apos;#user=admin&apos;; &#125;, 1000); // 开放给同域c.html的回调方法 function onCallback(res) &#123; alert(&apos;data from c.html ---&gt; &apos; + res); &#125;&lt;/script&gt; 2.）b.html：(http://www.domain2.com/b.html) 123456789&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain1.com/c.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById(&apos;iframe&apos;); // 监听a.html传来的hash值，再传给c.html window.onhashchange = function () &#123; iframe.src = iframe.src + location.hash; &#125;;&lt;/script&gt; 3.）c.html：(http://www.domain1.com/c.html) 1234567&lt;script&gt; // 监听b.html传来的hash值 window.onhashchange = function () &#123; // 再通过操作同域a.html的js回调，将结果传回 window.parent.parent.onCallback(&apos;hello: &apos; + location.hash.replace(&apos;#user=&apos;, &apos;&apos;)); &#125;;&lt;/script&gt; 四、 window.name + iframe跨域window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。 1.）a.html：(http://www.domain1.com/a.html) 1234567891011121314151617181920212223242526272829303132333435var proxy = function(url, callback) &#123; var state = 0; var iframe = document.createElement(&apos;iframe&apos;); // 加载跨域页面 iframe.src = url; // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name iframe.onload = function() &#123; if (state === 1) &#123; // 第2次onload(同域proxy页)成功后，读取同域window.name中数据 callback(iframe.contentWindow.name); destoryFrame(); &#125; else if (state === 0) &#123; // 第1次onload(跨域页)成功后，切换到同域代理页面 iframe.contentWindow.location = &apos;http://www.domain1.com/proxy.html&apos;; state = 1; &#125; &#125;; document.body.appendChild(iframe); // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问） function destoryFrame() &#123; iframe.contentWindow.document.write(&apos;&apos;); iframe.contentWindow.close(); document.body.removeChild(iframe); &#125;&#125;;// 请求跨域b页面数据proxy(&apos;http://www.domain2.com/b.html&apos;, function(data)&#123; alert(data);&#125;); 2.）proxy.html：(http://www.domain1.com/proxy….)中间代理页，与a.html同域，内容为空即可。 3.）b.html：(http://www.domain2.com/b.html) 123&lt;script&gt; window.name = &apos;This is domain2 data!&apos;;&lt;/script&gt; 总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。 五、 postMessage跨域postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：a.） 页面和其打开的新窗口的数据传递b.） 多窗口之间消息传递c.） 页面与嵌套的iframe消息传递d.） 上面三个场景的跨域数据传递 用法：postMessage(data,origin)方法接受两个参数data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。origin： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。 1.）a.html：(http://www.domain1.com/a.html) 12345678910111213141516&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById(&apos;iframe&apos;); iframe.onload = function() &#123; var data = &#123; name: &apos;aym&apos; &#125;; // 向domain2传送跨域数据 iframe.contentWindow.postMessage(JSON.stringify(data), &apos;http://www.domain2.com&apos;); &#125;; // 接受domain2返回数据 window.addEventListener(&apos;message&apos;, function(e) &#123; alert(&apos;data from domain2 ---&gt; &apos; + e.data); &#125;, false);&lt;/script&gt; 2.）b.html：(http://www.domain2.com/b.html) 1234567891011121314&lt;script&gt; // 接收domain1的数据 window.addEventListener(&apos;message&apos;, function(e) &#123; alert(&apos;data from domain1 ---&gt; &apos; + e.data); var data = JSON.parse(e.data); if (data) &#123; data.number = 16; // 处理后再发回domain1 window.parent.postMessage(JSON.stringify(data), &apos;http://www.domain1.com&apos;); &#125; &#125;, false);&lt;/script&gt; 六、 跨域资源共享（CORS）普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。 需注意的是：由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页。如果想实现当前页cookie的写入，可参考下文：七、nginx反向代理中设置proxy_cookie_domain 和 八、NodeJs中间件代理中cookieDomainRewrite参数的设置。 目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案。 1、 前端设置：1.）原生ajax 12// 前端设置是否带cookiexhr.withCredentials = true; 示例代码： 1234567891011121314var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容// 前端设置是否带cookiexhr.withCredentials = true;xhr.open(&apos;post&apos;, &apos;http://www.domain2.com:8080/login&apos;, true);xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;);xhr.send(&apos;user=admin&apos;);xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; alert(xhr.responseText); &#125;&#125;; 2.）jQuery ajax 12345678$.ajax(&#123; ... xhrFields: &#123; withCredentials: true // 前端设置是否带cookie &#125;, crossDomain: true, // 会让请求头中包含跨域的额外信息，但不会含cookie ...&#125;); 3.）vue框架 a.) axios设置： 1axios.defaults.withCredentials = true b.) vue-resource设置： 1Vue.http.options.credentials = true 2、 服务端设置：若后端设置成功，前端浏览器控制台则不会出现跨域报错信息，反之，说明没设成功。 1.）Java后台： 12345678910111213/* * 导入包：import javax.servlet.http.HttpServletResponse; * 接口参数中定义：HttpServletResponse response */// 允许跨域访问的域名：若有端口需写全（协议+域名+端口），若没有端口末尾不用加&apos;/&apos;response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://www.domain1.com&quot;); // 允许前端带认证cookie：启用此项后，上面的域名不能为&apos;*&apos;，必须指定具体的域名，否则浏览器会提示response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); // 提示OPTIONS预检时，后端需要设置的两个常用自定义头response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type,X-Requested-With&quot;); 2.）Nodejs后台示例： 12345678910111213141516171819202122232425262728293031323334var http = require(&apos;http&apos;);var server = http.createServer();var qs = require(&apos;querystring&apos;);server.on(&apos;request&apos;, function(req, res) &#123; var postData = &apos;&apos;; // 数据块接收中 req.addListener(&apos;data&apos;, function(chunk) &#123; postData += chunk; &#125;); // 数据接收完毕 req.addListener(&apos;end&apos;, function() &#123; postData = qs.parse(postData); // 跨域后台设置 res.writeHead(200, &#123; &apos;Access-Control-Allow-Credentials&apos;: &apos;true&apos;, // 后端允许发送Cookie &apos;Access-Control-Allow-Origin&apos;: &apos;http://www.domain1.com&apos;, // 允许访问的域（协议+域名+端口） /* * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)， * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问 */ &apos;Set-Cookie&apos;: &apos;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&apos; // HttpOnly的作用是让js无法读取cookie &#125;); res.write(JSON.stringify(postData)); res.end(); &#125;);&#125;);server.listen(&apos;8080&apos;);console.log(&apos;Server is running at port 8080...&apos;); 七、 nginx代理跨域1、 nginx配置解决iconfont跨域浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。 123location / &#123; add_header Access-Control-Allow-Origin *;&#125; 2、 nginx反向代理接口跨域跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。 实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。 nginx具体配置： 123456789101112131415#proxy服务器server &#123; listen 81; server_name www.domain1.com; location / &#123; proxy_pass http://www.domain2.com:8080; #反向代理 proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名 index index.html index.htm; # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 add_header Access-Control-Allow-Origin http://www.domain1.com; #当前端只跨域不带cookie时，可为* add_header Access-Control-Allow-Credentials true; &#125;&#125; 1.) 前端代码示例： 12345678var xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问nginx中的代理服务器xhr.open(&apos;get&apos;, &apos;http://www.domain1.com:81/?user=admin&apos;, true);xhr.send(); 2.) Nodejs后台示例： 123456789101112131415161718var http = require(&apos;http&apos;);var server = http.createServer();var qs = require(&apos;querystring&apos;);server.on(&apos;request&apos;, function(req, res) &#123; var params = qs.parse(req.url.substring(2)); // 向前台写cookie res.writeHead(200, &#123; &apos;Set-Cookie&apos;: &apos;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&apos; // HttpOnly:脚本无法读取 &#125;); res.write(JSON.stringify(params)); res.end();&#125;);server.listen(&apos;8080&apos;);console.log(&apos;Server is running at port 8080...&apos;); 八、 Nodejs中间件代理跨域node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。 1、 非vue框架的跨域（2次跨域）利用node + express + http-proxy-middleware搭建一个proxy服务器。 1.）前端代码示例： 12345678var xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问http-proxy-middleware代理服务器xhr.open(&apos;get&apos;, &apos;http://www.domain1.com:3000/login?user=admin&apos;, true);xhr.send(); 2.）中间件服务器： 123456789101112131415161718192021var express = require(&apos;express&apos;);var proxy = require(&apos;http-proxy-middleware&apos;);var app = express();app.use(&apos;/&apos;, proxy(&#123; // 代理跨域目标接口 target: &apos;http://www.domain2.com:8080&apos;, changeOrigin: true, // 修改响应头信息，实现跨域并允许带cookie onProxyRes: function(proxyRes, req, res) &#123; res.header(&apos;Access-Control-Allow-Origin&apos;, &apos;http://www.domain1.com&apos;); res.header(&apos;Access-Control-Allow-Credentials&apos;, &apos;true&apos;); &#125;, // 修改响应信息中的cookie域名 cookieDomainRewrite: &apos;www.domain1.com&apos; // 可以为false，表示不修改&#125;));app.listen(3000);console.log(&apos;Proxy server is listen at port 3000...&apos;); 3.）Nodejs后台同（六：nginx） 2、 vue框架的跨域（1次跨域）利用node + webpack + webpack-dev-server代理接口跨域。在开发环境下，由于vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域，无须设置headers跨域信息了。 webpack.config.js部分配置： 12345678910111213141516module.exports = &#123; entry: &#123;&#125;, module: &#123;&#125;, ... devServer: &#123; historyApiFallback: true, proxy: [&#123; context: &apos;/login&apos;, target: &apos;http://www.domain2.com:8080&apos;, // 代理跨域目标接口 changeOrigin: true, secure: false, // 当代理某些https服务报错时用 cookieDomainRewrite: &apos;www.domain1.com&apos; // 可以为false，表示不修改 &#125;], noInfo: true &#125;&#125; 九、 WebSocket协议跨域WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。 1.）前端代码： 12345678910111213141516171819202122&lt;div&gt;user input：&lt;input type=&quot;text&quot;&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js&quot;&gt;&lt;/script&gt;&lt;script&gt;var socket = io(&apos;http://www.domain2.com:8080&apos;);// 连接成功处理socket.on(&apos;connect&apos;, function() &#123; // 监听服务端消息 socket.on(&apos;message&apos;, function(msg) &#123; console.log(&apos;data from server: ---&gt; &apos; + msg); &#125;); // 监听服务端关闭 socket.on(&apos;disconnect&apos;, function() &#123; console.log(&apos;Server socket has closed.&apos;); &#125;);&#125;);document.getElementsByTagName(&apos;input&apos;)[0].onblur = function() &#123; socket.send(this.value);&#125;;&lt;/script&gt; 2.）Nodejs socket后台： 123456789101112131415161718192021222324252627var http = require(&apos;http&apos;);var socket = require(&apos;socket.io&apos;);// 启http服务var server = http.createServer(function(req, res) &#123; res.writeHead(200, &#123; &apos;Content-type&apos;: &apos;text/html&apos; &#125;); res.end();&#125;);server.listen(&apos;8080&apos;);console.log(&apos;Server is running at port 8080...&apos;);// 监听socket连接socket.listen(server).on(&apos;connection&apos;, function(client) &#123; // 接收信息 client.on(&apos;message&apos;, function(msg) &#123; client.send(&apos;hello：&apos; + msg); console.log(&apos;data from client: ---&gt; &apos; + msg); &#125;); // 断开处理 client.on(&apos;disconnect&apos;, function() &#123; console.log(&apos;Client socket has closed.&apos;); &#125;);&#125;);","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/categories/javascript/"}],"tags":[{"name":"跨域","slug":"跨域","permalink":"https://WLL-1017065322.github.io/blog/tags/跨域/"}],"author":"along"},{"title":"this的指向问题","slug":"this的指向问题","date":"2019-08-27T16:00:00.000Z","updated":"2019-10-28T10:13:51.195Z","comments":true,"path":"2019/08/28/this的指向问题/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/08/28/this的指向问题/","excerpt":"","text":"thisthis是js中的一个关键字，函数运行时自动生成的一个内部对象，只能在函数内部使用。我们要讨论的是 this 的指向。 this就是函数运行时自动生成的一个内部对象 this的指向不是在创建时就决定了，而是由执行环境决定的。 下面介绍一下几种情况下，this的指向 1、全局环境全局环境下，this就代表window对象。（针对web 应用来讲） 12345var name = &apos;zhar&apos;;function say()&#123; console.log(this.name);//zhar&#125;say(); 同样，在 setTimeout 或 setInterval 这样的延时函数中调用也属于全局对象 1234var name = &apos;zhar&apos;;setTimeout(function()&#123; console.log(this.name);//zhar&#125;,0); 2、对象环境对象环境指向对象。 1234567var obj = &#123; name : &quot;zhar&quot;, say : function()&#123; console.log(this.name);//zhar &#125;&#125;obj.say(); 下面举两个经典的例子： 1234567891011121314151617181920var name = &apos;tom&apos;;var obj = &#123; name : &quot;zhar&quot;, say : function()&#123; console.log(this.name); &#125;&#125;var fun = obj.say;fun();//输出 ?//tom--&gt;fun定义在全局环境下，即window.fun()//再次说明了this的指向是由运行时的执行环境来决定的var name = &apos;tom&apos;;var obj = &#123; name : &quot;zhar&quot;, say : function()&#123; return function()&#123; console.log(this.name); &#125; &#125;&#125;obj.say()();//输出 ？//tom 3、构造函数环境构造函数中的this 会指向创建出来的实例对象，使用new 调用构造函数时，会先创建出一个空对象，然后用call函数把构造函数中的this指针修改为指向这个空对象。执行完环境后，空对象也就有了相关的属性，然后将对象返回出去，所以说就不用我们自己手动返回啦~ 12345function Person() &#123; this.name = &apos;zhar&apos;;&#125;var p = new Person();console.log(p.name); 综合以上，构造函数不需要返回值，如果我们指定一个返回值时，this的指向将发生变化 1234567891011121314151617181920function Person() &#123; this.name = &apos;zhar&apos;; return &#123;&#125;;&#125;var p = new Person();console.log(p.name);//undefined//--------------------------------------function Person() &#123; this.name = &apos;zhar&apos;; return &#123;name:&apos;tom&apos;&#125;;&#125;var p = new Person();console.log(p.name);//tom 如果构造函数返回对象(Object,Array,Function)，那 this 将指向这个对象，其它基础类型则不受影响//--------------------------------------function Person() &#123; this.name = &apos;zhar&apos;; return 1;//number string boolean 等&#125;var p = new Person();console.log(p.name);//zhar 所以，如无必要我们通常不要设置构造函数的返回值 4、事件对象在 DOM 事件中使用 this，this 指向了触发事件的 DOM 元素本身 123li.onclick = function()&#123; console.log(this.innerHTML);&#125; 总结下来就是一句话：是谁调用的，this就指向谁 下面介绍一下如何来修改this 的指向 1、可以使用局部变量来代替this指针1234567891011var name = &quot;zhar&quot;;var obj = &#123; name : &quot;zhar&quot;, say : function()&#123; var _this = this;//使用一个变量指向 this setTimeout(function()&#123; console.log(_this.name); &#125;,0); &#125;&#125;obj.say(); 该方法为非常常用的一个方法 2、使用call 或 apply 方法首先说明一下，call也是函数调用的一种形式，可以通过 函数名.call（）来调用函数。但是提供了一个修改this指向的方法。 fun.call(thisObj[,arg1[,arg2[,…]]]) 调用方式和传入参数如上面的形式。其中，所以call(thisObj[,arg1[,arg2[,…]]])中的第一个参数就是要更改this指向的对象，为必选参数; 之后的参数要根据调用的函数是否需要传入参数(为可选的) 下面通过代码来展示call 如何使用： 123456789101112131415161718192021222324252627282930313233343536373839404142var name = &apos;zhar&apos;;function say()&#123; console.log(this.name);&#125;;say();//zhar;var obj = &#123; name : &apos;tom&apos;, say : function()&#123; console.log(this.name); &#125;&#125;say.call(obj);//tom 将 say 函数中的 this 替换为传入的对象obj.say();//tomobj.say.call(null);//zhar 将 obj.say 函数的 this 替换为了 null，也就意味着指向了全局环境//前面课程的继承代码function Person()&#123; this.name = &quot;人&quot;;&#125;function Student()&#123; Person.call(this,null);&#125;var s = new Student();console.log(s.name);li.onclick = function()&#123; console.log(this.innerHTML);//此处的 this 代表着 DOM 元素 function update()&#123; this.innerHTML += &quot; new &quot;; &#125; //update();//这样做的话，this 的指向将变为window update.call(this);//通过 call 方法修改函数内 this 的指向&#125;//call 的传参function say(arg1,arg2)&#123; console.log(this.name,arg1,arg2);&#125;;var obj = &#123; name : &apos;tom&apos;, say : function()&#123; console.log(this.name); &#125;&#125;say.call(obj,&apos;one&apos;,&apos;two&apos;);//tom one two apply apply的作用和call一样，不同的是传参的形式。apply需要以数组的形式传递参数 1234567891011//apply 的传参function say(arg1,arg2)&#123; console.log(this.name,arg1,arg2);&#125;;var obj = &#123; name : &apos;tom&apos;, say : function()&#123; console.log(this.name); &#125;&#125;say.apply(obj,[&apos;one&apos;,&apos;two&apos;]);//tom one two 以上就是关于this指向和如何修改this指向的介绍","categories":[{"name":"js","slug":"js","permalink":"https://WLL-1017065322.github.io/blog/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://WLL-1017065322.github.io/blog/tags/js/"},{"name":"this","slug":"this","permalink":"https://WLL-1017065322.github.io/blog/tags/this/"}],"author":"along"},{"title":"定时器的this","slug":"定时器的this","date":"2019-08-24T16:00:00.000Z","updated":"2019-10-28T08:16:23.239Z","comments":true,"path":"2019/08/25/定时器的this/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/08/25/定时器的this/","excerpt":"","text":"Javascript定时器中的this指向使用js中的定时器（setInterval，setTimeout），很容易会遇到this指向的问题。 直接上例子： 1234567891011 1 var name = &apos;my name is window&apos;; 2 var obj = &#123; 3 name: &apos;my name is obj&apos;, 4 fn: function () &#123; 5 var timer = null; 6 clearInterval(timer); 7 timer = setInterval(function () &#123; 8 console.log(this.name); //my name is window 9 &#125;, 1000)10 &#125;11 &#125; 在这里，从this.name可以看出this的指向是window。 如果没有特殊指向，setInterval和setTimeout的回调函数中this的指向都是window。这是因为JS的定时器方法是定义在window下的。但是平时很多场景下，都需要修改this的指向。这里总结了几种： 1、最常用的方法：在外部函数中将this存为一个变量，回调函数中使用该变量，而不是直接使用this。 123456789101112 1 var name = &apos;my name is window&apos;; 2 var obj = &#123; 3 name: &apos;my name is obj&apos;, 4 fn: function () &#123; 5 var that = this; 6 var timer = null; 7 clearInterval(timer); 8 timer = setInterval(function () &#123; 9 console.log(that.name); //my name is obj10 &#125;, 1000)11 &#125;12 &#125; 在fn中加了var that = this; 回调函数中使用that代替this即可。这种方法最常见，使用也最广泛。 2、使用bind()方法（bind()为ES5的标准，低版本IE下有兼容问题，可以引入es5-shim.js解决） bind()的作用类似call和apply，都是修改this指向。但是call和apply是修改this指向后函数会立即执行，而bind则是返回一个新的函数，它会创建一个与原来函数主体相同的新函数，新函数中的this指向传入的对象。 1234567891011 1 var name = &apos;my name is window&apos;; 2 var obj = &#123; 3 name: &apos;my name is obj&apos;, 4 fn: function () &#123; 5 var timer = null; 6 clearInterval(timer); 7 timer = setInterval(function () &#123; 8 console.log(this.name); //my name is obj 9 &#125;.bind(this), 1000)10 &#125;11 &#125; 在这里为什么不能用call和apply，是因为call和apply不是返回函数，而是立即执行函数，那么，就失去了定时器的作用。 3、使用es6的箭头函数：箭头函数的最大作用就是this指向。 1234567891011 1 var name = &apos;my name is window&apos;; 2 var obj = &#123; 3 name: &apos;my name is obj&apos;, 4 fn: function () &#123; 5 var timer = null; 6 clearInterval(timer); 7 timer = setInterval(() =&gt; &#123; 8 console.log(this.name); //my name is obj 9 &#125;, 1000)10 &#125;11 &#125; 箭头函数没有自己的this，它的this继承自外部函数的作用域。所以，在该例中，定时器回调函数中的this，是继承了fn的this。当然箭头函数也有兼容问题，要是兼容低版本ie，需要使用babel编译，并且引入es5-shim.js才可以。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/categories/javascript/"}],"tags":[{"name":"javascrpit","slug":"javascrpit","permalink":"https://WLL-1017065322.github.io/blog/tags/javascrpit/"},{"name":"定时器","slug":"定时器","permalink":"https://WLL-1017065322.github.io/blog/tags/定时器/"}],"author":"along"},{"title":"pm2 status error","slug":"pm2 status error","date":"2019-08-19T16:00:00.000Z","updated":"2019-10-28T08:15:29.525Z","comments":true,"path":"2019/08/20/pm2 status error/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/08/20/pm2 status error/","excerpt":"","text":"pm2 status erroredps aux | grep pm2kill -9 pm2项目对应的进程 #注意这里的 pm2 是全局安装的pm2 update #问题解决","categories":[{"name":"上线","slug":"上线","permalink":"https://WLL-1017065322.github.io/blog/categories/上线/"}],"tags":[{"name":"部署上线","slug":"部署上线","permalink":"https://WLL-1017065322.github.io/blog/tags/部署上线/"},{"name":"pm2","slug":"pm2","permalink":"https://WLL-1017065322.github.io/blog/tags/pm2/"}],"author":"along"},{"title":"nginx","slug":"nginx","date":"2019-08-15T16:00:00.000Z","updated":"2019-10-28T08:14:25.245Z","comments":true,"path":"2019/08/16/nginx/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/08/16/nginx/","excerpt":"","text":"准备工作:查看防火墙情况:查看开放的端口号:firewall-cmd –list-all 设置开放的端口号: firewall-cmd-add-service=http –permanent sudo firewall-cmd-add-port=80/tcp–permanent 重启防火墙: firewall-cmd-reload 常用命令:1 进入目录/usr/local/nginx/sbin 2查看版本号 ./nginx -v ​ 查看状态:ps -ef | grep nginx 3 启动nginx ./nginx 4关闭nginx ./nginx -s stop 5重新加载nginx ./nginx -s reload 反向代理host文件进行域名和ip对应关系的配置(windows) 反向代理配置: 实例一: server { listen 80; server_name 本地ip; location / { proxy_pass http//127.0.0.1:3000; } } 实例二: proxy_set_header Host $host; proxy_set_header X-Forwarded-For $remote_addr; #proxy_cache cache_one; #proxy_cache_key $host$request_uri$is_args$args; #proxy_cache_valid 200 304 301 302 1h; add_header X-Cache $upstream_cache_status; expires 12h;","categories":[{"name":"上线","slug":"上线","permalink":"https://WLL-1017065322.github.io/blog/categories/上线/"}],"tags":[{"name":"部署上线","slug":"部署上线","permalink":"https://WLL-1017065322.github.io/blog/tags/部署上线/"},{"name":"nginx","slug":"nginx","permalink":"https://WLL-1017065322.github.io/blog/tags/nginx/"}],"author":"along"},{"title":"linux-sudo npm 没有命令","slug":"linux-sudo npm 没有命令","date":"2019-08-15T16:00:00.000Z","updated":"2019-10-28T08:13:50.466Z","comments":true,"path":"2019/08/16/linux-sudo npm 没有命令/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/08/16/linux-sudo npm 没有命令/","excerpt":"","text":"这种情况通常是使用 npm 命令可以正常使用，但使用sudo npm 命令便会报 command not found 这是什么原因呢？输入which npm可以得到/usr/local/bin/npm，这个是普通用户的bin目录而sudo执行的是/usr/bin目录，这是root用户的目录所以使用sudo命令是识别不到这个命令的，我们可以使用以下方法来处理这个问题 sudo ln -s /usr/local/bin/node /usr/bin/nodesudo ln -s /usr/local/lib/node /usr/lib/nodesudo ln -s /usr/local/bin/npm /usr/bin/npmsudo ln -s /usr/local/bin/node-waf /usr/bin/node-waf 1234sudo ln -s /usr/local/bin/node /usr/bin/nodesudo ln -s /usr/local/lib/node /usr/lib/nodesudo ln -s /usr/local/bin/npm /usr/bin/npmsudo ln -s /usr/local/bin/node-waf /usr/bin/node-waf 同理，如果你使用的是cnpm 那么 sudo ln -s /usr/local/bin/cnpm /usr/bin/cnpm1如果你的其他程序也是这样的问题,只要将xxx替换成你的可执行程序就可以了 sudo ln -s /usr/local/bin/xxx /usr/bin/xxx1ln命令用来为文件创件连接，连接类型分为硬连接和符号连接两种，默认的连接类型是硬连接。如果要创建符号连接必须使用”-s”选项。 注意: 符号链接文件不是一个独立的文件，它的许多属性依赖于源文件，所以给符号链接文件设置存取权限是没有意义的。","categories":[{"name":"上线","slug":"上线","permalink":"https://WLL-1017065322.github.io/blog/categories/上线/"}],"tags":[{"name":"部署上线","slug":"部署上线","permalink":"https://WLL-1017065322.github.io/blog/tags/部署上线/"},{"name":"linux","slug":"linux","permalink":"https://WLL-1017065322.github.io/blog/tags/linux/"}],"author":"along"},{"title":"linux 环境变量","slug":"linux 环境变量","date":"2019-08-12T16:00:00.000Z","updated":"2019-10-28T08:13:24.080Z","comments":true,"path":"2019/08/13/linux 环境变量/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/08/13/linux 环境变量/","excerpt":"","text":"Ubuntu Linux系统环境变量配置文件：/etc/profile : 在登录时,操作系统定制用户环境时使用的第一个文件 ,此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行。 /etc /environment : 在登录时操作系统使用的第二个文件, 系统在读取你自己的profile前,设置环境文件的环境变量。 ~/.profile : 在登录时用到的第三个文件 是.profile文件,每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件。 /etc/bashrc : 为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取. ~/.bashrc : 该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取。 PASH环境变量的设置方法： 方法一：用户主目录下的.profile或.bashrc文件（推荐） 登录到你的用户（非root），在终端输入：$ sudo gedit ~/.profile(or .bashrc)可以在此文件末尾加入PATH的设置如下：export PATH=”$PATH:your path1:your path2 …”保存文件，注销再登录，变量生效。该方式添加的变量只对当前用户有效。 方法二：系统目录下的profile文件（谨慎） 在系统的etc目录下，有一个profile文件，编辑该文件：$ sudo gedit /etc/profile在最后加入PATH的设置如下：export PATH=”$PATH:your path1:your path2 …”该文件编辑保存后，重启系统，变量生效。该方式添加的变量对所有的用户都有效。 方法三：系统目录下的 environment 文件（谨慎） 在系统的etc目录下，有一个environment文件，编辑该文件：$ sudo gedit /etc/environment找到以下的 PATH 变量：PATH=”&lt;……&gt;”修改该 PATH 变量，在其中加入自己的path即可，例如：PATH=”&lt;……&gt;:your path1:your path2 …”各个path之间用冒号分割。该文件也是重启生效，影响所有用户。注意这里不是添加export PATH=… 。 方法四：直接在终端下输入 $ sudo export PATH=”$PATH:your path1:your path2 …”这种方式变量立即生效，但用户注销或系统重启后设置变成无效，适合临时变量的设置。 注 意：方法二和三的修改需要谨慎，尤其是通过root用户修改，如果修改错误，将可能导致一些严重的系统错误。因此笔者推荐使用第一种方法。另外嵌入式 Linux的开发最好不要在root下进行（除非你对Linux已经非常熟悉了！！），以免因为操作不当导致系统严重错误。 下面是一个对environment文件错误修改导致的问题以及解决方法示例： 问题：因为不小心在 etc/environment里设在环境变量导致无法登录提示：不要在 etc/environment里设置 export PATH这样会导致重启后登录不了系统解决方法：在登录界面 alt +ctrl+f1进入命令模式，如果不是root用户需要键入（root用户就不许这么罗嗦，gedit编辑会不可显示）/usr/bin/sudo /usr/bin/vi /etc/environment光标移到export PATH** 行，连续按 d两次删除该行；输入:wq保存退出；然后键入/sbin/reboot重启系统（可能会提示need to boot，此时直接power off）","categories":[{"name":"上线","slug":"上线","permalink":"https://WLL-1017065322.github.io/blog/categories/上线/"}],"tags":[{"name":"部署上线","slug":"部署上线","permalink":"https://WLL-1017065322.github.io/blog/tags/部署上线/"},{"name":"linux","slug":"linux","permalink":"https://WLL-1017065322.github.io/blog/tags/linux/"}],"author":"along"},{"title":"项目部署上线-Linux端口","slug":"linux 端口","date":"2019-08-09T16:00:00.000Z","updated":"2019-10-28T08:12:55.865Z","comments":true,"path":"2019/08/10/linux 端口/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/08/10/linux 端口/","excerpt":"","text":"1、lsof -i:端口号 用于查看某一端口的占用情况，比如查看8000端口使用情况，lsof -i:8000 123# lsof -i:8000COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMElwfs 22065 root 6u IPv4 4395053 0t0 TCP *:irdmi (LISTEN) 可以看到8000端口已经被轻量级文件系统转发服务lwfs占用 2、netstat -tunlp |grep 端口号，用于查看指定的端口号的进程情况，如查看8000端口的情况，netstat -tunlp |grep 8000 netstat命令各个参数说明如下： -t : 指明显示TCP端口 -u : 指明显示UDP端口 -l : 仅显示监听套接字(所谓套接字就是使应用程序能够读写与收发通讯协议(protocol)与资料的程序) -p : 显示进程标识符和程序名称，每一个套接字/端口都属于一个程序。 -n : 不进行DNS轮询，显示IP(可以加速操作) netstat -ntlp //查看当前所有tcp端口 netstat -ntulp |grep 80 //查看所有80端口使用情况 netstat -an | grep 3306 //查看所有3306端口使用情况","categories":[{"name":"上线","slug":"上线","permalink":"https://WLL-1017065322.github.io/blog/categories/上线/"}],"tags":[{"name":"部署上线","slug":"部署上线","permalink":"https://WLL-1017065322.github.io/blog/tags/部署上线/"},{"name":"linux","slug":"linux","permalink":"https://WLL-1017065322.github.io/blog/tags/linux/"}],"author":"along"},{"title":"项目部署上线-nginx反向代理","slug":"项目部署上线-nginx反向代理","date":"2019-08-04T16:00:00.000Z","updated":"2019-10-28T08:11:45.873Z","comments":true,"path":"2019/08/05/项目部署上线-nginx反向代理/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/08/05/项目部署上线-nginx反向代理/","excerpt":"","text":"打包压缩上传:后端配置:nginx反向代理宝塔: Nginx配置文件路径为：/www/server/panel/vhost/nginx/xinshouzhanzhang.conf nginx.conf文件路径：/www/server/nginx/conf/nginx.conf 多域名Nginx配置文件：/www/server/panel/vhost/nginx/你的域名.conf nginx.conf: 第一种: 123456789101112location / &#123; proxy_pass http://localhost:3000; proxy_set_header Host http://vueceshi.wanglvlong.top/boss/api/; proxy_set_header X-Forwarded-For $remote_addr; #proxy_cache cache_one; #proxy_cache_key http://vueceshi.wanglvlong.top/boss/api/$request_uri$is_args$args; #proxy_cache_valid 200 304 301 302 1h; add_header X-Cache $upstream_cache_status; expires 12h;&#125; 第二种: 123location ^~ /boss/api/ &#123; proxy_pass http://vueceshi.wanglvlong.top:3000/; #注意域名后有一个/&#125;","categories":[{"name":"上线","slug":"上线","permalink":"https://WLL-1017065322.github.io/blog/categories/上线/"}],"tags":[{"name":"部署上线","slug":"部署上线","permalink":"https://WLL-1017065322.github.io/blog/tags/部署上线/"},{"name":"nginx","slug":"nginx","permalink":"https://WLL-1017065322.github.io/blog/tags/nginx/"}],"author":"along"},{"title":"组件库","slug":"组件库","date":"2019-07-31T16:00:00.000Z","updated":"2019-10-28T08:08:29.177Z","comments":true,"path":"2019/08/01/组件库/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/08/01/组件库/","excerpt":"","text":"前端组件库大合集-必备收藏 前端组件库 搭建web app常用的样式/组件等收集列表(移动优先) 0. 前端自动化(Workflow) 前端构建工具 Yeoman – a set of tools for automating development workflow gulp – The streaming build system grunt – the JavaScript Task Runner F.I.S – 前端集成解决方案 前端模块管理器 Bower – A package manager for the web Browserify Component Duo RequireJS Sea.js css预处理器 Less – Less is More , Than CSS Sass – Syntactically Awesome Style Sheets Stylus – Expressive, dynamic, robust CSS 1. 前端框架(Frameworks) Bootstrap Foundation Amaze UI Semantic UI Pure CSS topcoat UIkit Material UI Framework7 mui ionic framework Fries jQuery Mobile 2. JavaScript 框架汇总 JavaScript 框架 react Angular jQuery Backbone.js Ractive.js KISSY Zepto.js Vanilla JS Avalon 轻量级JavaScript框架 Min.js – Super minimal selector and event library skel.js – A lightweight responsive framework JavaScript 工具库 underscore.js Way.js – 双向数据绑定库 Keys.js – 应用快捷键 3. 前端游戏框架 cocos2d-html5 Egret Engine LimeJS EaselJS three.js AlloyStick The-Best-JS-Game-Framework CanvasEngine Quintus 4. ui组件库 GMU NEC NEJ Pure CSS Components magic-of-css 5. 基础模版 HTML5 BOILERPLATE Modernizr Normalize.css Responsive – 响应式布局 6. 排版 yue.css typo.css chinese-copywriting-guidelines – 中文文案排版指南 7. 网格系统 grid Flexbox Grid 8. HTML5 API 应用 History.js – gracefully supports the HTML5 History/State APIs jquery-pjax – pushState+ajax jquery-address – Deep Linking Notify.js(Web Notifications API) 9. UA 识别 detector 10. 表单处理10.1 表单验证(Form Validator) Validator Parsley jquery.form.js – jQuery Form Plugin Validform validator.js formvalidator.js Fort.js – 表单填写进度提示 10.2 &lt; select &gt; 相关 Chosen Select2 bootstrap-select 10.3 单选框/复选框相关 iCheck – 增强复选框和单选按钮 10.4 上传组件 jQuery File Upload Plugin 百度 Web Uploader Uploadify Plupload arale-upload – 轻量级 iframe and html5 file uploader Dropzone.js – drag’n’drop library拖拽上传 flow.js 10.5 日期选择 Both Date and Time picker widget based on twitter bootstrap GMU 日历组件 Mobiscroll 10.6 取色 Colorpicker plugin for Twitter Bootstrap 10.7 标签插件(Tag) TaggingJS – 可以灵活定制的 jQuery 标签系统插件 10.8 自动完成插件 At.js – 一个Twitter/微博样式的@自动完成插件 jquery-textcomplete – 智能搜索提示框/自动补全 10.9 样式修正 autosize – 使文本框自动适应所输入的内容 11. 图表绘制 Highcharts Chart.js – Simple HTML5 Charts using Canvas 百度 ECharts Chartist.js D3.js – A JavaScript visualization library for HTML and SVG. intro-to-d3 – a D3.js tutorial 12. 日期格式化 Moment.js Smart Time Ago – 显示相对时间 13. 页面交互13.1 Slider slick – the last carousel you’ll ever need Swipe – the most accurate touch slider Swiper – Most modern mobile touch slider iscroll – Smooth scrolling for the web OwlCarousel – create beautiful responsive carousel slider jquery-mousewheel – jQuery鼠标滚轮滚动侦测插件 13.2 瀑布流 Masonry Isotope – Filter &amp; sort magical layouts 13.3 图片懒加载/加载监听 imagesLoaded Echo.js lazySizes jquery_lazyload lazyload.js waitForImages – 图片加载监听库 13.4 图片轮播/展示 FlexSlider unslider – 小而美的轮播库 prettyPhoto 13.5 图片剪裁/处理 croppic – an image cropping jquery plugin jQuery.eraser – 图像擦除插件 13.6 进度条 NProgress.js progress.js Pace – Automatic page load progress bar jquery-ajax-progress 13.7 侧滑插件(offcancas) pushy – a responsive off-canvas navigation menu 13.8 菜单(Menu) SuperFish – 基于jQuery的级联下拉菜单 Responsive Nav – 响应式导航 13.9 滚动侦测(ScrollSpy) jquery-scrollspy(1) jquery-scrollspy(2) Waypoints 13.10 滚动加载更多 jScroll 13.11 平滑滚动插件(Smooth Scroll) jquery-smooth-scroll jquery.scrollTo – 平滑滚动到页面指定位置 13.12 全屏滚动 pagePiling.js – 全屏滚动效果 13.13 分屏滚动 multiscroll.js – 分屏滚动效果 13.14 转场效果 Animsition – 页面切换时的过渡效果 13.15 固定元素(Sticky) sticky – jQuery Plugin for Sticky Objects jquery.pin – 固定页面元素 13.16 触控事件 Hammer.js jquery.event.move.js 13.17 拖拽组件 Draggabilly – 专注于拖拽功能的 JS 库 13.18 隐藏或展示页面元素 Headroom.js – 在不需要页头时将其隐藏 Readmore.js – 内容显示与隐藏插件 13.19 滚动条 jScrollPane 13.20 视差滚动(Parallax Scrolling) parallax.js jparallax 14. 代码高亮插件/代码编辑器 google-code-prettify highlight.js Rainbow ACE CodeMirror Crayon Syntax Highlighter prism – Lightweight, robust, elegant syntax highlighting. 15. UI Icon 组件 Font Awesome Glyphter: The SVG Font Machine Perfect Icons iconizr Cikonss – 纯CSS实现的响应式Icon Simple Icons 16. 动画 animate.css – A cross-browser library of CSS animations. Transit – CSS transitions and transformations for jQuery Move.js – 简化CSS3动画的JS库 ScrollMe – 在网页中加入各种滚动动画效果 Effeckt.css – A Performant Transitions and Animations Library NEC动画库 csshake – CSS classes to move your DOM magic – CSS3 Animations with special effects Hover.css css-loaders SpinKit 17. 本地存储 cross-storage – Cross domain local storage localForage pouchdb basil.js 18. 模板引擎 mustache.js Handlebars.js artTemplate baiduTemplate JSRender EJS – JavaScript Templates Juicer – A Light Javascript Templete Engine. Tempo json2html 19. 通知组件/弹框组件 alertify.js AlertifyJS SweetAlert Messenger – 非常酷的弹框组件 PNotify Notify.js – A simple, versatile notification library 20. 提示控件(Tooltips) qTip2 – Pretty powerful tooltips tooltip – CSS Tooltips tooltipster – A jQuery tooltip plugin grumble.js – 气泡形状的提示（Tooltip）控件 Ouibounce – 离站提示控件 21. 对话框/弹出层(lightbox) fancyBox – Fancy jQuery lightbox jquery-lightbox – The popular lightbox script, ported to jQuery Colorbox – a jQuery lightbox artDialog – 经典的网页对话框组件 DialogEffects 22. 文档/表格 handsontable – 在线可编辑excel表格 jQuery Bootgrid – 用于ajax生成动态表格 DataTables – Table plug-in for jQuery 23. 目录树插件 zTree_v3 – jQuery Tree Plugin jstree – jQuery Tree Plugin fancytree – Tree plugin for jQuery 24. Ajax模块 fetch – A window.fetch JavaScript polyfill reqwest – browser asynchronous http requests minAjax.js 25. 音频/视频 jPlayer – HTML5 Audio &amp; Video for jQuery video.js – HTML5 &amp; Flash video player Accessible HTML5 Video Player – PayPal 开源的 HTML5 视频播放器 Clappr – 开源的Web视频播放器 Plyr – A simple HTML5 media player FitVids.js – A lightweight, easy-to-use jQuery plugin for fluid width video embeds. BigVideo.js – The jQuery Plugin for Big Background Video BigScreen – A simple library for using the JavaScript Full Screen API Vide – 视频背景 winamp2-js 26. 按钮 Buttons – A CSS button library ButtonComponentMorph ProgressButtonStyles CreativeButtons CSS3 buttons jquery.onoff – Interactive, accessible toggle switches for the web. 27. 富文本编辑器/Markdown编辑器/Markdown解析器 Simditor – 简单快速的富文本编辑器 BachEditor – 一个有情怀的编辑器 bootstrap-markdown marked – markdown解析器 28. 内容提取(Readability) Readability json.human.js – Json Formatting for Human Beings 29. 颜色(CSS Colors)/SVG CSS Colours SVGeneration 30. 实用工具/其他插件 jquery-cookie FastClick – 处理移动端 click 事件 300 毫秒延迟 screenfull.js – 全屏切换 Async.js – 异步操作 html2canvas – 实现纯JS网页截图 jquery.qrcode.js – 生成二维码的 jQuery 插件 FocusPoint.js 实现图片的响应式裁剪 DD_belatedPNG.js – 让IE6支持透明PNG图片 nakedpassword – 用脱衣女帮助检测密码强度 PDF.js – 一个 JavaScript 编写的 PDF 阅读器 前端参考集 frontend-guidelines – Some HTML, CSS and JS best practices. Codrops – Useful resources Front-end Code Standards &amp; Best Practices frontend-dev-bookmarks","categories":[{"name":"其他","slug":"其他","permalink":"https://WLL-1017065322.github.io/blog/categories/其他/"}],"tags":[{"name":"组件","slug":"组件","permalink":"https://WLL-1017065322.github.io/blog/tags/组件/"}],"author":"along"},{"title":"axios错误统一封装","slug":"axios错误统一封装","date":"2019-07-29T16:00:00.000Z","updated":"2019-10-28T08:07:20.554Z","comments":true,"path":"2019/07/30/axios错误统一封装/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/07/30/axios错误统一封装/","excerpt":"","text":"前端网络请求封装前端采用了axios来处理网络请求，为了避免在每次请求时都去判断各种各样的网络情况，比如连接超时、服务器内部错误、权限不足等等不一而足，我对axios进行了简单的封装，这里主要使用了axios中的拦截器功能。 封装后的网络请求工具js如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152import axios from &apos;axios&apos;import &#123; Toast &#125; from &apos;mint-ui&apos;//请求时的拦截axios.interceptors.request.use(config =&gt; &#123; return config;&#125;, err =&gt; &#123; Toast(&apos;请求超时!&apos; ); return Promise.resolve(err);&#125;)//响应时的拦截axios.interceptors.response.use(data =&gt; &#123; // 返回响应时做一些处理 // 第一种方式 const data = response.data // 根据返回的code值来做不同的处理（和后端约定） switch (data.code) &#123; case &apos;0&apos;: // 举例 // exp: 修复iPhone 6+ 微信点击返回出现页面空白的问题 if (isIOS()) &#123; // 异步以保证数据已渲染到页面上 setTimeout(() =&gt; &#123; // 通过滚动强制浏览器进行页面重绘 document.body.scrollTop += 1 &#125;, 0) &#125; // 这一步保证数据返回，如果没有return则会走接下来的代码，不是未登录就是报错 return data // 需要重新登录 case &apos;SHIRO_E5001&apos;: // 微信生产环境下授权登录 if (isWeChat() &amp;&amp; IS_PRODUCTION) &#123; axios.get(apis.common.wechat.authorizeUrl).then((&#123; result &#125;) =&gt; &#123; location.replace(global.decodeURIComponent(result)) &#125;) &#125; else &#123; // 否则跳转到h5登录并带上跳转路由 const search = encodeSearchParams(&#123; next: location.href, &#125;) location.replace(`/user/login?$&#123;search&#125;`) &#125; // 不显示提示消息 data.description = &apos;&apos; break default: &#125; // 若不是正确的返回code，且已经登录，就抛出错误 const err = new Error(data.description) err.data = data err.response = response // 第二种方式，我采取的 if (data.status &amp;&amp; data.status == 200 &amp;&amp; data.data.status == &apos;error&apos;) &#123; Toast(data.data.msg); return data; &#125; return data;&#125;,err =&gt; &#123; // 当响应异常时做一些处理 if (err &amp;&amp; err.response) &#123; switch (err.response.status) &#123; case 400: err.message = &apos;请求错误(400)&apos;; break; case 401: err.message = &apos;未授权，请重新登录(401)&apos;; break; case 403: err.message = &apos;拒绝访问(403)&apos;; break; case 404: err.message = &apos;请求出错(404)&apos;; break; case 408: err.message = &apos;请求超时(408)&apos;; break; case 500: err.message = &apos;服务器错误(500)&apos;; break; case 501: err.message = &apos;服务未实现(501)&apos;; break; case 502: err.message = &apos;网络错误(502)&apos;; break; case 503: err.message = &apos;服务不可用(503)&apos;; break; case 504: err.message = &apos;网络超时(504)&apos;; break; case 505: err.message = &apos;HTTP版本不受支持(505)&apos;; break; default: err.message = `连接出错($&#123;err.response.status&#125;)!`; &#125; &#125; else &#123; err.message = &apos;连接服务器失败!&apos; &#125; Toast(err.message); return Promise.resolve(err);&#125;)//如果需要可以封装一些请求的方法let base = &apos;&apos;;export const postRequest = (url, params) =&gt; &#123; return axios(&#123; method: &apos;post&apos;, url: `$&#123;base&#125;$&#123;url&#125;`, data: params, transformRequest: [function (data) &#123; let ret = &apos;&apos; for (let it in data) &#123; ret += encodeURIComponent(it) + &apos;=&apos; + encodeURIComponent(data[it]) + &apos;&amp;&apos; &#125; return ret &#125;], headers: &#123; &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos; &#125; &#125;);&#125;export const uploadFileRequest = (url, params) =&gt; &#123; return axios(&#123; method: &apos;post&apos;, url: `$&#123;base&#125;$&#123;url&#125;`, data: params, headers: &#123; &apos;Content-Type&apos;: &apos;multipart/form-data&apos; &#125; &#125;);&#125;export const putRequest = (url, params) =&gt; &#123; return axios(&#123; method: &apos;put&apos;, url: `$&#123;base&#125;$&#123;url&#125;`, data: params, transformRequest: [function (data) &#123; let ret = &apos;&apos; for (let it in data) &#123; ret += encodeURIComponent(it) + &apos;=&apos; + encodeURIComponent(data[it]) + &apos;&amp;&apos; &#125; return ret &#125;], headers: &#123; &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos; &#125; &#125;);&#125;export const deleteRequest = (url) =&gt; &#123; return axios(&#123; method: &apos;delete&apos;, url: `$&#123;base&#125;$&#123;url&#125;` &#125;);&#125;export const get = (url,params) =&gt; &#123; return axios(&#123; method: &apos;get&apos;, url: `$&#123;base&#125;$&#123;url&#125;?`, params: params, headers:&#123; &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;, &apos;Access-Token&apos;: localStorage.getItem(&quot;AccessToken&quot;) &#125; &#125;);&#125; 封装之后的错误信息这个大家一目了然，没啥好说的，唯一要说的是当出错的时候我执行的是：Promise.resolve(err);，而不是Promise.reject(err); 这是什么原因呢？因为封装axios一个重要的目的就是希望能够对错误进行统一处理，不用在每一次发起网络请求的时候都去处理各种异常情况，将所有的异常情况都在工具js中进行统一的处理。但是这种方式也带来一个问题，就是我在发起网络请求的时候，一般都会开启一个进度条，当网络请求结束时，不论请求成功还是失败，我都要将这个进度条关闭掉，而失败的处理我都统一写在工具js里边了，因此就没在请求失败时关闭进度条了，解决这个问题，有两种方案： 1.直接在request的拦截器中开启一个fullscreen的loading，然后在response的拦截器中将其关闭，即我将进度条也封装到工具js中了，但是非常不推荐这种方式，因为这种方式的用户体验非常之差，有兴趣的小伙伴可以自己试一下就知道了。 2.第二种解决方案就是大家看到的，我返回一个Promise.resolve(err)，则这个请求不会就此结束，错误的message我已经弹出来了，但是这条消息还是会继续传到then中，也就是说，无论请求成功还是失败，我在成功的回调中都能收到通知，这样我就可以将loading关闭了，比如下面这个登录请求： 1234567891011121314151617var _this = this;this.loading = true;this.postRequest(&apos;/login&apos;, &#123; username: this.loginForm.username, password: this.loginForm.password&#125;).then(resp=&gt; &#123; _this.loading = false; if (resp &amp;&amp; resp.status == 200) &#123; _this.getRequest(&quot;/config/hr&quot;).then(resp=&gt; &#123; if (resp &amp;&amp; resp.status == 200) &#123; var data = resp.data; _this.$store.commit(&apos;login&apos;, data); var path = _this.$route.query.redirect; _this.$router.replace(&#123;path: path == &apos;/&apos; || path == undefined ? &apos;/home&apos; : path&#125;); &#125; &#125;) &#125; 添加Vue插件由于我对axios进行了封装，因此在每一个需要使用axios的地方，都需要导入相应的请求，略显麻烦，参考https://cn.vuejs.org/v2/guide/plugins.html，我将请求方法挂到Vue上，具体操作如下： 1.在main.js中导入所有的请求方法，如下： 1234import &#123;get&#125; from &apos;./utils/api&apos;import &#123;postRequest&#125; from &apos;./utils/api&apos;import &#123;deleteRequest&#125; from &apos;./utils/api&apos;import &#123;putRequest&#125; from &apos;./utils/api&apos; 2.把它们添加到 Vue.prototype 上，如下： 1234Vue.prototype.getRequest = getRequest;Vue.prototype.postRequest = postRequest;Vue.prototype.deleteRequest = deleteRequest;Vue.prototype.putRequest = putRequest; 如此之后，以后再需要发送网络请求，就不需要导入api了，直接通过下面这种方式即可： Post方法： 1234567this.postRequest(&apos;/login&apos;, &#123; username: this.loginForm.username, password: this.loginForm.password&#125;).then(resp=&gt; &#123; ... &#125;&#125;); GET方法： 123456789_this.get( this.url_s+&quot;/Notice/findTotalCount&quot;,&#123; userId:localStorage.getItem(&quot;userid&quot;), openId: localStorage.getItem(&apos;openId&apos;) &#125; ) .then(function(res) &#123; // &#125;)","categories":[{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/categories/vue/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/tags/vue/"},{"name":"axios","slug":"axios","permalink":"https://WLL-1017065322.github.io/blog/tags/axios/"}],"author":"along"},{"title":"axios的封装","slug":"axios的封装","date":"2019-07-27T16:00:00.000Z","updated":"2019-10-28T08:06:35.970Z","comments":true,"path":"2019/07/28/axios的封装/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/07/28/axios的封装/","excerpt":"","text":"vue中Axios的封装和API接口的管理 如图，面对一团糟代码的你~~~真的想说，What F~U~C~K！！！ 回归正题，我们所要的说的axios的封装和api接口的统一管理，其实主要目的就是在帮助我们简化代码和利于后期的更新维护。 一、axios的封装在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json、客户端防御XSRF等。所以我们的尤大大也是果断放弃了对其官方库vue-resource的维护，直接推荐我们使用axios库。如果还对axios不了解的，可以移步axios文档。 安装1npm install axios; // 安装axios复制代码 引入一般我会在项目的src目录中，新建一个request文件夹，然后在里面新建一个http.js和一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。 123456// 在http.js中引入axiosimport axios from &apos;axios&apos;; // 引入axiosimport QS from &apos;qs&apos;; // 引入qs模块，用来序列化post类型的数据，后面会提到// vant的toast提示框组件，大家可根据自己的ui组件更改。import &#123; Toast &#125; from &apos;vant&apos;; 复制代码 环境的切换我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。axios.defaults.baseURL可以设置axios的默认请求地址就不多说了。 123456789// 环境的切换if (process.env.NODE_ENV == &apos;development&apos;) &#123; axios.defaults.baseURL = &apos;https://www.baidu.com&apos;;&#125; else if (process.env.NODE_ENV == &apos;debug&apos;) &#123; axios.defaults.baseURL = &apos;https://www.ceshi.com&apos;;&#125; else if (process.env.NODE_ENV == &apos;production&apos;) &#123; axios.defaults.baseURL = &apos;https://www.production.com&apos;;&#125;复制代码 设置请求超时通过axios.defaults.timeout设置默认的请求超时时间。例如超过了10s，就会告知用户当前请求超时，请刷新等。 1axios.defaults.timeout = 10000;复制代码 post请求头的设置post请求的时候，我们需要加上一个请求头，所以可以在这里进行一个默认的设置，即设置post的请求头为application/x-www-form-urlencoded;charset=UTF-8 1axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded;charset=UTF-8&apos;;复制代码 请求拦截 我们在发送请求前可以进行一个请求的拦截，为什么要拦截呢，我们拦截请求是用来做什么的呢？比如，有些请求是需要用户登录之后才能访问的，或者post请求的时候，我们需要序列化我们提交的数据。这时候，我们可以在请求被发送之前进行一个拦截，从而进行我们想要的操作。 请求拦截1234567891011121314151617// 先导入vuex,因为我们要使用到里面的状态对象// vuex的路径根据自己的路径去写import store from &apos;@/store/index&apos;;// 请求拦截器axios.interceptors.request.use( config =&gt; &#123; // 每次发送请求之前判断vuex中是否存在token // 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况 // 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断 const token = store.state.token; token &amp;&amp; (config.headers.Authorization = token); return config; &#125;, error =&gt; &#123; return Promise.error(error); &#125;)复制代码 这里说一下token，一般是在登录完成之后，将用户的token通过localStorage或者cookie存在本地，然后用户每次在进入页面的时候（即在main.js中），会首先从本地存储中读取token，如果token存在说明用户已经登陆过，则更新vuex中的token状态。然后，在每次请求接口的时候，都会在请求的header中携带token，后台人员就可以根据你携带的token来判断你的登录是否过期，如果没有携带，则说明没有登录过。这时候或许有些小伙伴会有疑问了，就是每个请求都携带token，那么要是一个页面不需要用户登录就可以访问的怎么办呢？其实，你前端的请求可以携带token，但是后台可以选择不接收啊！ 响应的拦截1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 响应拦截器axios.interceptors.response.use( response =&gt; &#123; // 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据 // 否则的话抛出错误 if (response.status === 200) &#123; return Promise.resolve(response); &#125; else &#123; return Promise.reject(response); &#125; &#125;, // 服务器状态码不是2开头的的情况 // 这里可以跟你们的后台开发人员协商好统一的错误状态码 // 然后根据返回的状态码进行一些操作，例如登录过期提示，错误提示等等 // 下面列举几个常见的操作，其他需求可自行扩展 error =&gt; &#123; if (error.response.status) &#123; switch (error.response.status) &#123; // 401: 未登录 // 未登录则跳转登录页面，并携带当前页面的路径 // 在登录成功后返回当前页面，这一步需要在登录页操作。 case 401: router.replace(&#123; path: &apos;/login&apos;, query: &#123; redirect: router.currentRoute.fullPath &#125; &#125;); break; // 403 token过期 // 登录过期对用户进行提示 // 清除本地token和清空vuex中token对象 // 跳转登录页面 case 403: Toast(&#123; message: &apos;登录过期，请重新登录&apos;, duration: 1000, forbidClick: true &#125;); // 清除token localStorage.removeItem(&apos;token&apos;); store.commit(&apos;loginSuccess&apos;, null); // 跳转登录页面，并将要浏览的页面fullPath传过去，登录成功后跳转需要访问的页面 setTimeout(() =&gt; &#123; router.replace(&#123; path: &apos;/login&apos;, query: &#123; redirect: router.currentRoute.fullPath &#125; &#125;); &#125;, 1000); break; // 404请求不存在 case 404: Toast(&#123; message: &apos;网络请求不存在&apos;, duration: 1500, forbidClick: true &#125;); break; // 其他错误，直接抛出错误提示 default: Toast(&#123; message: error.response.data.message, duration: 1500, forbidClick: true &#125;); &#125; return Promise.reject(error.response); &#125; &#125; &#125;);复制代码 响应拦截器很好理解，就是服务器返回给我们的数据，我们在拿到之前可以对他进行一些处理。例如上面的思想：如果后台返回的状态码是200，则正常返回数据，否则的根据错误的状态码类型进行一些我们需要的错误，其实这里主要就是进行了错误的统一处理和没登录或登录过期后调整登录页的一个操作。 要注意的是，上面的Toast()方法，是我引入的vant库中的toast轻提示组件，你根据你的ui库，对应使用你的一个提示组件。 封装get方法和post方法我们常用的ajax请求方法有get、post、put等方法，相信小伙伴都不会陌生。axios对应的也有很多类似的方法，不清楚的可以看下文档。但是为了简化我们的代码，我们还是要对其进行一个简单的封装。下面我们主要封装两个方法：get和post。 get方法：我们通过定义一个get函数，get函数有两个参数，第一个参数表示我们要请求的url地址，第二个参数是我们要携带的请求参数。get函数返回一个promise对象，当axios其请求成功时resolve服务器返回 值，请求失败时reject错误值。最后通过export抛出get函数。 123456789101112131415/** * get方法，对应get请求 * @param &#123;String&#125; url [请求的url地址] * @param &#123;Object&#125; params [请求时携带的参数] */export function get(url, params)&#123; return new Promise((resolve, reject) =&gt;&#123; axios.get(url, &#123; params: params &#125;).then(res =&gt; &#123; resolve(res.data); &#125;).catch(err =&gt;&#123; reject(err.data) &#125;) &#125;);&#125;复制代码 post方法：原理同get基本一样，但是要注意的是，post方法必须要使用对提交从参数对象进行序列化的操作，所以这里我们通过node的qs模块来序列化我们的参数。这个很重要，如果没有序列化操作，后台是拿不到你提交的数据的。这就是文章开头我们import QS from ‘qs’;的原因。如果不明白序列化是什么意思的，就百度一下吧，答案一大堆。 12345678910111213141516/** * post方法，对应post请求 * @param &#123;String&#125; url [请求的url地址] * @param &#123;Object&#125; params [请求时携带的参数] */export function post(url, params) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.post(url, QS.stringify(params)) .then(res =&gt; &#123; resolve(res.data); &#125;) .catch(err =&gt;&#123; reject(err.data) &#125;) &#125;);&#125;复制代码 这里有个小细节说下，axios.get()方法和axios.post()在提交数据时参数的书写方式还是有区别的。区别就是，get的第二个参数是一个{}，然后这个对象的params属性值是一个参数对象的。而post的第二个参数就是一个参数对象。两者略微的区别要留意哦！ axios的封装基本就完成了，下面再简单说下api的统一管理。整齐的api就像电路板一样，即使再复杂也能很清晰整个线路。上面说了，我们会新建一个api.js,然后在这个文件中存放我们所有的api接口。 首先我们在api.js中引入我们封装的get和post方法 1234/** * api接口统一管理 */import &#123; get, post &#125; from &apos;./http&apos;复制代码 现在，例如我们有这样一个接口，是一个post请求： 1http://www.baiodu.com/api/v1/users/my_address/address_edit_before复制代码 我们可以在api.js中这样封装： 1export const apiAddress = p =&gt; post(&apos;api/v1/users/my_address/address_edit_before&apos;, p);复制代码 我们定义了一个apiAddress方法，这个方法有一个参数p，p是我们请求接口时携带的参数对象。而后调用了我们封装的post方法，post方法的第一个参数是我们的接口地址，第二个参数是apiAddress的p参数，即请求接口时携带的参数对象。最后通过export导出apiAddress。 然后在我们的页面中可以这样调用我们的api接口： 1234567891011121314151617181920import &#123; apiAddress &#125; from &apos;@/request/api&apos;;// 导入我们的api接口export default &#123; name: &apos;Address&apos;, created () &#123; this.onLoad(); &#125;, methods: &#123; // 获取数据 onLoad() &#123; // 调用api接口，并且提供了两个参数 apiAddress(&#123; type: 0, sort: 1 &#125;).then(res =&gt; &#123; // 获取数据成功后的其他操作 ……………… &#125;) &#125; &#125;&#125;复制代码 其他的api接口，就在pai.js中继续往下面扩展就可以了。友情提示，为每个接口写好注释哦！！！ api接口管理的一个好处就是，我们把api统一集中起来，如果后期需要修改接口，我们就直接在api.js中找到对应的修改就好了，而不用去每一个页面查找我们的接口然后再修改会很麻烦。关键是，万一修改的量比较大，就规格gg了。还有就是如果直接在我们的业务代码修改接口，一不小心还容易动到我们的业务代码造成不必要的麻烦。 好了，最后把完成的axios封装代码奉上。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135/**axios封装 * 请求拦截、相应拦截、错误统一处理 */import axios from &apos;axios&apos;;import QS from &apos;qs&apos;;import &#123; Toast &#125; from &apos;vant&apos;;import store from &apos;../store/index&apos;// 环境的切换if (process.env.NODE_ENV == &apos;development&apos;) &#123; axios.defaults.baseURL = &apos;/api&apos;;&#125; else if (process.env.NODE_ENV == &apos;debug&apos;) &#123; axios.defaults.baseURL = &apos;&apos;;&#125; else if (process.env.NODE_ENV == &apos;production&apos;) &#123; axios.defaults.baseURL = &apos;http://api.123dailu.com/&apos;;&#125;// 请求超时时间axios.defaults.timeout = 10000;// post请求头axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded;charset=UTF-8&apos;;// 请求拦截器axios.interceptors.request.use( config =&gt; &#123; // 每次发送请求之前判断是否存在token，如果存在，则统一在http请求的header都加上token，不用每次请求都手动添加了 // 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断 const token = store.state.token; token &amp;&amp; (config.headers.Authorization = token); return config; &#125;, error =&gt; &#123; return Promise.error(error); &#125;)// 响应拦截器axios.interceptors.response.use( response =&gt; &#123; if (response.status === 200) &#123; return Promise.resolve(response); &#125; else &#123; return Promise.reject(response); &#125; &#125;, // 服务器状态码不是200的情况 error =&gt; &#123; if (error.response.status) &#123; switch (error.response.status) &#123; // 401: 未登录 // 未登录则跳转登录页面，并携带当前页面的路径 // 在登录成功后返回当前页面，这一步需要在登录页操作。 case 401: router.replace(&#123; path: &apos;/login&apos;, query: &#123; redirect: router.currentRoute.fullPath &#125; &#125;); break; // 403 token过期 // 登录过期对用户进行提示 // 清除本地token和清空vuex中token对象 // 跳转登录页面 case 403: Toast(&#123; message: &apos;登录过期，请重新登录&apos;, duration: 1000, forbidClick: true &#125;); // 清除token localStorage.removeItem(&apos;token&apos;); store.commit(&apos;loginSuccess&apos;, null); // 跳转登录页面，并将要浏览的页面fullPath传过去，登录成功后跳转需要访问的页面 setTimeout(() =&gt; &#123; router.replace(&#123; path: &apos;/login&apos;, query: &#123; redirect: router.currentRoute.fullPath &#125; &#125;); &#125;, 1000); break; // 404请求不存在 case 404: Toast(&#123; message: &apos;网络请求不存在&apos;, duration: 1500, forbidClick: true &#125;); break; // 其他错误，直接抛出错误提示 default: Toast(&#123; message: error.response.data.message, duration: 1500, forbidClick: true &#125;); &#125; return Promise.reject(error.response); &#125; &#125;);/** * get方法，对应get请求 * @param &#123;String&#125; url [请求的url地址] * @param &#123;Object&#125; params [请求时携带的参数] */export function get(url, params)&#123; return new Promise((resolve, reject) =&gt;&#123; axios.get(url, &#123; params: params &#125;) .then(res =&gt; &#123; resolve(res.data); &#125;) .catch(err =&gt; &#123; reject(err.data) &#125;) &#125;);&#125;/** * post方法，对应post请求 * @param &#123;String&#125; url [请求的url地址] * @param &#123;Object&#125; params [请求时携带的参数] */export function post(url, params) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.post(url, QS.stringify(params)) .then(res =&gt; &#123; resolve(res.data); &#125;) .catch(err =&gt; &#123; reject(err.data) &#125;) &#125;);&#125;复制代码 如果喜欢，就给个❤❤吧(^▽^) *华丽丽的分割线**华丽丽的分割线**华丽丽的分割线**华丽丽的分割线**华丽丽的分割线* 2018.8.14更新axios的封装根据需求的不同而不同。这里非常感谢评论里一些很中肯的建议，我也对此进行了思考和针对不同需求的改善。主要有以下改变： 1.优化axios封装，去掉之前的get和post 2.断网情况处理 3.更加模块化的api管理 4.接口域名有多个的情况 5.api挂载到vue.prototype上省去引入的步骤 http.js中axios封装的优化，先直接贴代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/** * axios封装 * 请求拦截、响应拦截、错误统一处理 */import axios from &apos;axios&apos;;import router from &apos;../router&apos;;import store from &apos;../store/index&apos;;import &#123; Toast &#125; from &apos;vant&apos;;/** * 提示函数 * 禁止点击蒙层、显示一秒后关闭 */const tip = msg =&gt; &#123; Toast(&#123; message: msg, duration: 1000, forbidClick: true &#125;);&#125;/** * 跳转登录页 * 携带当前页面路由，以期在登录页面完成登录后返回当前页面 */const toLogin = () =&gt; &#123; router.replace(&#123; path: &apos;/login&apos;, query: &#123; redirect: router.currentRoute.fullPath &#125; &#125;);&#125;/** * 请求失败后的错误统一处理 * @param &#123;Number&#125; status 请求失败的状态码 */const errorHandle = (status, other) =&gt; &#123; // 状态码判断 switch (status) &#123; // 401: 未登录状态，跳转登录页 case 401: toLogin(); break; // 403 token过期 // 清除token并跳转登录页 case 403: tip(&apos;登录过期，请重新登录&apos;); localStorage.removeItem(&apos;token&apos;); store.commit(&apos;loginSuccess&apos;, null); setTimeout(() =&gt; &#123; toLogin(); &#125;, 1000); break; // 404请求不存在 case 404: tip(&apos;请求的资源不存在&apos;); break; default: console.log(other); &#125;&#125;// 创建axios实例var instance = axios.create(&#123; timeout: 1000 * 12&#125;);// 设置post请求头instance.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;;/** * 请求拦截器 * 每次请求前，如果存在token则在请求头中携带token */ instance.interceptors.request.use( config =&gt; &#123; // 登录流程控制中，根据本地是否存在token判断用户的登录情况 // 但是即使token存在，也有可能token是过期的，所以在每次的请求头中携带token // 后台根据携带的token判断用户的登录情况，并返回给我们对应的状态码 // 而后我们可以在响应拦截器中，根据状态码进行一些统一的操作。 const token = store.state.token; token &amp;&amp; (config.headers.Authorization = token); return config; &#125;, error =&gt; Promise.error(error))// 响应拦截器instance.interceptors.response.use( // 请求成功 res =&gt; res.status === 200 ? Promise.resolve(res) : Promise.reject(res), // 请求失败 error =&gt; &#123; const &#123; response &#125; = error; if (response) &#123; // 请求已发出，但是不在2xx的范围 errorHandle(response.status, response.data.message); return Promise.reject(response); &#125; else &#123; // 处理断网的情况 // eg:请求超时或断网时，更新state的network状态 // network状态在app.vue中控制着一个全局的断网提示组件的显示隐藏 // 关于断网组件中的刷新重新获取数据，会在断网组件中说明 if (!window.navigator.onLine) &#123; store.commit(&apos;changeNetwork&apos;, false); &#125; else &#123; return Promise.reject(error); &#125; &#125; &#125;);export default instance;复制代码 这个axios和之前的大同小异，做了如下几点改变： 1.去掉了之前get和post方法的封装，通过创建一个axios实例然后export default方法导出，这样使用起来更灵活一些。 2.去掉了通过环境变量控制baseUrl的值。考虑到接口会有多个不同域名的情况，所以准备通过js变量来控制接口域名。这点具体在api里会介绍。 3.增加了请求超时，即断网状态的处理。说下思路，当断网时，通过更新vuex中network的状态来控制断网提示组件的显示隐藏。断网提示一般会有重新加载数据的操作，这步会在后面对应的地方介绍。 4.公用函数进行抽出，简化代码，尽量保证单一职责原则。 下面说下api这块，考虑到一下需求： 1.更加模块化 2.更方便多人开发，有效减少解决命名冲突 3.处理接口域名有多个情况 这里这里呢新建了一个api文件夹，里面有一个index.js和一个base.js，以及多个根据模块划分的接口js文件。index.js是一个api的出口，base.js管理接口域名，其他js则用来管理各个模块的接口。 先放index.js代码： 123456789101112/** * api接口的统一出口 */// 文章模块接口import article from &apos;@/api/article&apos;;// 其他模块的接口……// 导出接口export default &#123; article, // ……&#125;复制代码 index.js是一个api接口的出口，这样就可以把api接口根据功能划分为多个模块，利于多人协作开发，比如一个人只负责一个模块的开发等，还能方便每个模块中接口的命名哦。 base.js: 123456789/** * 接口域名的管理 */const base = &#123; sq: &apos;https://xxxx111111.com/api/v1&apos;, bd: &apos;http://xxxxx22222.com/api&apos;&#125;export default base;复制代码 通过base.js来管理我们的接口域名，不管有多少个都可以通过这里进行接口的定义。即使修改起来，也是很方便的。 最后就是接口模块的说明，例如上面的article.js: 123456789101112131415161718192021222324252627/** * article模块接口列表 */import base from &apos;./base&apos;; // 导入接口域名列表import axios from &apos;@/utils/http&apos;; // 导入http中创建的axios实例import qs from &apos;qs&apos;; // 根据需求是否导入qs模块const article = &#123; // 新闻列表 articleList () &#123; return axios.get(`$&#123;base.sq&#125;/topics`); &#125;, // 新闻详情,演示 articleDetail (id, params) &#123; return axios.get(`$&#123;base.sq&#125;/topic/$&#123;id&#125;`, &#123; params: params &#125;); &#125;, // post提交 login (params) &#123; return axios.post(`$&#123;base.sq&#125;/accesstoken`, qs.stringify(params)); &#125; // 其他接口…………&#125;export default article;复制代码 1.通过直接引入我们封装好的axios实例，然后定义接口、调用axios实例并返回，可以更灵活的使用axios，比如你可以对post请求时提交的数据进行一个qs序列化的处理等。 2.请求的配置更灵活，你可以针对某个需求进行一个不同的配置。关于配置的优先级，axios文档说的很清楚，这个顺序是：在 lib/defaults.js 找到的库的默认值，然后是实例的 defaults 属性，最后是请求的 config 参数。后者将优先于前者。 3.restful风格的接口，也可以通过这种方式灵活的设置api接口地址。 最后，为了方便api的调用，我们需要将其挂载到vue的原型上。在main.js中： 1234567import Vue from &apos;vue&apos;import App from &apos;./App&apos;import router from &apos;./router&apos; // 导入路由文件import store from &apos;./store&apos; // 导入vuex文件import api from &apos;./api&apos; // 导入api接口Vue.prototype.$api = api; // 将api挂载到vue的原型上复制代码 然后我们可以在页面中这样调用接口，eg： 123456789methods: &#123; onLoad(id) &#123; this.$api.article.articleDetail(id, &#123; api: 123 &#125;).then(res=&gt; &#123; // 执行某些操作 &#125;) &#125; &#125;复制代码 再提一下断网的处理，这里只做一个简单的示例： 12345678910111213141516171819202122232425&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;div v-if=&quot;!network&quot;&gt; &lt;h3&gt;我没网了&lt;/h3&gt; &lt;div @click=&quot;onRefresh&quot;&gt;刷新&lt;/div&gt; &lt;/div&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123; mapState &#125; from &apos;vuex&apos;; export default &#123; name: &apos;App&apos;, computed: &#123; ...mapState([&apos;network&apos;]) &#125;, methods: &#123; // 通过跳转一个空页面再返回的方式来实现刷新当前页面数据的目的 onRefresh () &#123; this.$router.replace(&apos;/refresh&apos;) &#125; &#125; &#125;&lt;/script&gt;复制代码 这是app.vue，这里简单演示一下断网。在http.js中介绍了，我们会在断网的时候，来更新vue中network的状态，那么这里我们根据network的状态来判断是否需要加载这个断网组件。断网情况下，加载断网组件，不加载对应页面的组件。当点击刷新的时候，我们通过跳转refesh页面然后立即返回的方式来实现重新获取数据的操作。因此我们需要新建一个refresh.vue页面，并在其beforeRouteEnter钩子中再返回当前页面。 123456// refresh.vuebeforeRouteEnter (to, from, next) &#123; next(vm =&gt; &#123; vm.$router.replace(from.fullPath) &#125;) &#125;复制代码 这是一种全局通用的断网提示，当然了，也可以根据自己的项目需求操作。具体操作就仁者见仁智者见智了。 如果更多的需求，或者说是不一样的需求，可以根据自己的需求进行一个改进。","categories":[{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/categories/vue/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/tags/vue/"},{"name":"axios","slug":"axios","permalink":"https://WLL-1017065322.github.io/blog/tags/axios/"}],"author":"along"},{"title":"vue axios封装","slug":"vue axios封装","date":"2019-07-24T16:00:00.000Z","updated":"2019-10-28T10:13:42.674Z","comments":true,"path":"2019/07/25/vue axios封装/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/07/25/vue axios封装/","excerpt":"","text":"第一步还是先下载axios 1cnpm install axios -S 第二步建立一个http.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118import axios from &apos;axios&apos;;import &#123; Message &#125; from &apos;element-ui&apos;;axios.defaults.timeout = 5000;axios.defaults.baseURL =&apos;&apos;;//http request 拦截器axios.interceptors.request.use( config =&gt; &#123; // const token = getCookie(&apos;名称&apos;);注意使用的时候需要引入cookie方法，推荐js-cookie config.data = JSON.stringify(config.data); config.headers = &#123; &apos;Content-Type&apos;:&apos;application/x-www-form-urlencoded&apos; &#125; // if(token)&#123; // config.params = &#123;&apos;token&apos;:token&#125; // &#125; return config; &#125;, error =&gt; &#123; return Promise.reject(err); &#125;);//http response 拦截器axios.interceptors.response.use( response =&gt; &#123; if(response.data.errCode ==2)&#123; router.push(&#123; path:&quot;/login&quot;, querry:&#123;redirect:router.currentRoute.fullPath&#125;//从哪个页面跳转 &#125;) &#125; return response; &#125;, error =&gt; &#123; return Promise.reject(error) &#125;)/** * 封装get方法 * @param url * @param data * @returns &#123;Promise&#125; */export function fetch(url,params=&#123;&#125;)&#123; return new Promise((resolve,reject) =&gt; &#123; axios.get(url,&#123; params:params &#125;) .then(response =&gt; &#123; resolve(response.data); &#125;) .catch(err =&gt; &#123; reject(err) &#125;) &#125;)&#125;/** * 封装post请求 * @param url * @param data * @returns &#123;Promise&#125; */ export function post(url,data = &#123;&#125;)&#123; return new Promise((resolve,reject) =&gt; &#123; axios.post(url,data) .then(response =&gt; &#123; resolve(response.data); &#125;,err =&gt; &#123; reject(err) &#125;) &#125;) &#125; /** * 封装patch请求 * @param url * @param data * @returns &#123;Promise&#125; */export function patch(url,data = &#123;&#125;)&#123; return new Promise((resolve,reject) =&gt; &#123; axios.patch(url,data) .then(response =&gt; &#123; resolve(response.data); &#125;,err =&gt; &#123; reject(err) &#125;) &#125;)&#125; /** * 封装put请求 * @param url * @param data * @returns &#123;Promise&#125; */export function put(url,data = &#123;&#125;)&#123; return new Promise((resolve,reject) =&gt; &#123; axios.put(url,data) .then(response =&gt; &#123; resolve(response.data); &#125;,err =&gt; &#123; reject(err) &#125;) &#125;)&#125; 第三步 在main.js中引入 1234567import axios from &apos;axios&apos;import &#123;post,fetch,patch,put&#125; from &apos;./utils/http&apos;//定义全局变量Vue.prototype.$post=post;Vue.prototype.$fetch=fetch;Vue.prototype.$patch=patch;Vue.prototype.$put=put; 最后在组件里直接使用 12345678 mounted()&#123; this.$fetch(&apos;/api/v2/movie/top250&apos;) .then((response) =&gt; &#123; console.log(response) &#125;) &#125;,其余的方法一样","categories":[{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/tags/vue/"},{"name":"axios","slug":"axios","permalink":"https://WLL-1017065322.github.io/blog/tags/axios/"}],"author":"along"},{"title":"axios的二次封装","slug":"axios的二次封装","date":"2019-07-23T16:00:00.000Z","updated":"2019-10-28T08:06:07.423Z","comments":true,"path":"2019/07/24/axios的二次封装/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/07/24/axios的二次封装/","excerpt":"","text":"一、场景在vue2.x的版本中请求数据推荐使用的axios，之前我常常使用的axios的别名方法,比如说在vue组件中: 1234567axios.get('http://localhost:3000/user') .then(res =&gt; &#123; console.log(res) &#125;) .catch(err =&gt; &#123; console.log(err) &#125;) 如果一个页面或者组件发多个请求,那写法上还是比较麻烦的，并没有async,await的写法清爽。每发起一个请求，就要写.then，.catch这些代码，这也太麻烦了吧，请求过多的话，接口难维护，重复的代码量也会增多。这里我们来封装一个接口。这里默认你已经会axios的基本用法了，还没接触axios的移步官网。 二、目录结构 这里把接口代码放在requests.js文件。 三、接口实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import axios from 'axios'import &#123; MessageBox, Message&#125; from \"element-ui\"import &#123; getToken &#125; from '@/utils/auth'import store from '@/store'// 默认情况下，axios将JavaScript对象序列化为JSON。要以application/x-www-form-urlencoded格式发送数据，可以使用qs库进行编码import qs from 'qs'// create an axios instanceconst service = axios.create(&#123; // baseURL: 'localhost:8080', // url = base url + request url withCredentials: true, // send cookies when cross-domain requests timeout: 5000 // request timeout&#125;)// request interceptorservice.interceptors.request.use( config =&gt; &#123; // do something before request is sent if (store.getters.token) &#123; // let each request carry token // ['X-Token'] is a custom headers key // please modify it according to the actual situation config.headers['X-Token'] = getToken() &#125; return config &#125;, error =&gt; &#123; // do something with request error console.log(error) // for debug return Promise.reject(error) &#125;)// response interceptorservice.interceptors.response.use( response =&gt; &#123; const res = response.data // 2000状态码表示正确；下面进行错误处理 if (res.code !== 20000) &#123; Message(&#123; message: res.message || 'error', type: 'error', duration: 5 * 1000 &#125;) // 50008: Illegal token; 50012: Other clients logged in; 50014: Token expired; if (res.code === 50008 || res.code === 50012 || res.code === 50014) &#123; // to re-login MessageBox.confirm('You have been logged out, you can cancel to stay on this page, or log in again', 'Confirm logout', &#123; confirmButtonText: 'Re-Login', cancelButtonText: 'Cancel', type: 'warning' &#125;).then(() =&gt; &#123; // 返回promise对象store.dispatch('user/resetToken') store.dispatch('user/resetToken').then(() =&gt; &#123; location.reload() &#125;) &#125;) &#125; return Promise.reject(res.message || 'error') &#125; else &#123; return res &#125; &#125;, error =&gt; &#123; Message(&#123; message: error.message, type: 'error', duration: 5 * 1000 &#125;) return Promise.reject(error) &#125;)const httpServer = (method, opts) =&gt; &#123; let httpDefaultOpts = &#123; method: method, url: opts.url, params:opts, data: qs.stringify(opts.data), // headers: method === 'get' ? &#123;'X-Requested-With': 'XMLHttpRequest'&#125;:&#123;'content-type': 'application/x-www-form-urlencoded'&#125; &#125; if (method === 'get')&#123; delete httpDefaultOpts.data &#125;else&#123; delete httpDefaultOpts.params &#125; console.log('opt', httpDefaultOpts) return new Promise((resolve, reject) =&gt; &#123; service(httpDefaultOpts).then(res =&gt; &#123; resolve(res) &#125;).catch(err =&gt; &#123; reject(err) &#125;) &#125;) // end promise&#125;export default httpServer 接口写好了，接下来就差调用了，在组件中调用 1234567891011121314151617181920212223import httpServer from &apos;@/utils/requests&apos;……mounted() &#123; this.imgPost()&#125;,methods: &#123; async imgPost() &#123; console.log(&apos;imgPost&apos;) let opts = &#123; data: &#123; firstName: &apos;Fred&apos; &#125;, url: &apos;/api/imgOperate&apos; &#125; let res = await httpServer(&apos;post&apos;, opts) this.compareShow = true console.log(&apos;end&apos;, res) &#125;&#125;…… 组件挂载时就调用接口。但现在没有真正的API接口，可以用mockjs来模拟接口。对mockjs不了解的可去看上一篇文章。 1234567891011121314151617181920212223242526272829// 引入mockjsconst Mock = require('mockjs')// 设置请求延时时间Mock.setup(&#123; timeout:2000&#125;)// 获取 mock.Random 对象const Random = Mock.Random// mock一组数据const produceNewsData = function () &#123; let newImg = &#123; title: Random.csentence(5, 30), // Random.csentence( min, max ) thumbnail_pic_s: Random.dataImage('300x250', 'mock的图片'), // Random.dataImage( size, text ) 生成一段随机的 Base64 图片编码 author_name: Random.cname(), // Random.cname() 随机生成一个常见的中文姓名 date: Random.date() + ' ' + Random.time() // Random.date()指示生成的日期字符串的格式,默认为yyyy-MM-dd；Random.time() 返回一个随机的时间字符串 &#125; return &#123; data: newImg, code: 20000, message: 'success' &#125;&#125;// 拦截ajax请求，配置mock的数据Mock.mock('/api/imgOperate', 'post', produceNewsData) 四、效果 通过控制台可以看到请求参数，返回结果成功。0zcl/CNode通过控制台可以看到请求参数，返回结果成功。项目代码已存放到git。用到的技术有vue,vuex,axios,mockjs,less,vue-router,vue filter过滤器，阿里iconfont，element-ui，还有引用第三方库。如果是入门vue不久，把项目clone下来当作练习也是不错的。","categories":[{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/categories/vue/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/tags/vue/"},{"name":"axios","slug":"axios","permalink":"https://WLL-1017065322.github.io/blog/tags/axios/"}],"author":"along"},{"title":"axios为何需要封装","slug":"axios为何需要封装","date":"2019-07-20T16:00:00.000Z","updated":"2019-10-28T08:05:24.770Z","comments":true,"path":"2019/07/21/axios为何需要封装/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/07/21/axios为何需要封装/","excerpt":"","text":"关于axios的一些封装关于Axios的封装 为何需要在封装应用场景，项目中涉及100个AJAX请求，其中： 1.其中60个需要在请求头header设置token headers: {token: token}用于权限校验; 2.其中20个为上传EXCEL文件需要在请求头中设置Content-Type; 123headers: &#123; &apos;Content-Type&apos;: `multipart/form-data; boundary=$&#123;data._boundary&#125;`&#125; 上面说的 1、2、3可以在全局request拦截中进行处理，但是代价极大，需要为这100个接口都做判断再做相应处理… ；当然也可以不用全局拦截，为每个接口都单独定义，我相信有不少同学仍是这样处理的，但是只要有改动，例如现在我要求所有的请求头都新增一个参数，那就只能一个一个接口的改…..这不是我们想要的结果，所以 我们需要对AJAX再封装！AJAX再封装！AJAX再封装！，因为相当重要，所以要多说几遍…. ③最后20个请求用来获取文件流，需要指定接受类型responseType: &#39;blob&#39; 需要对全局发起request进行拦截并做异步处理（强调：是异步处理）； 如果你的项目已经做到一半，现在后端要加上token权限做认证； 封装实现封装其实很简单，就是对原来真正的AJAX套一个壳，这个壳就是一个函数！ 在这个函数里都干了些什么见不得人事呢？干什么都可以，上面说的1、 2、 3、 4、 5都可以在这里悄悄的进行，那对原来的AJAX链式调用有影响吗？答案是肯定的：没有影响。 先来看看我在代码里调用的AJAX： 123456_initEditParams () &#123; this.$axios(&apos;Common/Permission/Get&apos;, &#123;Id&#125;).then(res =&gt; &#123; .... .... &#125;)&#125;, this.$axios可以直接调用是因为这里把请求方法之类的配置项全放在封装里面进行了。 这里也是通过Vue.prototype.$axios = axios添加到vue全局实例的，但这里添加的axios不是直接引入的axios插件，而是一个方法 12import &#123;axios&#125; from &apos;./utils/common&apos;Vue.prototype.$axios = axios 当然。也可以不用添加到全局实例里面，可以在组件中通过import语法引入使用。当然是项目里大量使用的封装方法直接使用Vue.prototype添加到vue实例。接下来我们看看axios方法都做了些啥： 12345678910111213141516171819202122232425262728import Axios from &apos;axios&apos;import Store from &apos;../vuex&apos;/********************************* ** Fn: axios ** Intro: 公用封装的axios 已在main.js中进行 $axios代理 ** Intro: Store.state.permission.constUrl 为公用的接口前缀地址 ** Intro: url 方法接受参数 为定义的 接口地址后缀 ** Intro: data 方法接受参数 为定义的参数 ** Author: zyx*********************************/export function axios (url, data) &#123; return new Promise((resolve, reject) =&gt; &#123; Axios(&#123; url: `$&#123;Store.state.permission.constUrl&#125;$&#123;url&#125;`, method: &apos;post&apos;, data: data, headers: &#123; token: Store.state.permission.token &#125; &#125;).then(res =&gt; &#123; resolve(res) &#125;).catch(err =&gt; &#123; reject(err) &#125;) &#125;)&#125; Axios的封装 在目录下新建一个Axios文件夹，在文件夹下新建文件axios.js，文件内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118import Axios from &quot;axios&quot;;import qs from &quot;qs&quot;;import router from &quot;@/router/router.js&quot;;// import &#123; Message &#125; from &quot;element-ui&quot;;/****** 创建axios实例 ******/const Service = Axios.create(&#123; baseURL: process.env.BASE_URL, // api的base_url timeout: 10000, // 请求超时时间 responseType: &quot;json&quot;, withCredentials: true, // 是否允许带cookie这些 headers: &#123; // &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded;charset=utf-8&quot; &quot;Content-Type&quot;: &quot;application/json;charset=utf-8&quot; &#125;&#125;);// 设置请求拦截器Service.interceptors.request.use(config =&gt; &#123; // 在发送请求之前做某件事 if (config.method === &quot;post&quot;) &#123; // 序列化 // config.data = qs.stringify(config.data); // config.data = JSON.stringify(config.data); // 温馨提示,若是公司的提交能直接接受json 格式,可以不用 qs 来序列化的 &#125; // 若是有做鉴权token , 就给头部带上token // 若是需要跨站点,存放到 cookie 会好一点,限制也没那么多,有些浏览环境限制了 localstorage 的使用 // if (localStorage.token) &#123; // config.headers.Authorization = localStorage.token; // &#125; return config; &#125;, error =&gt; &#123; // error 的回调信息,看公司的定义 Message(&#123; showClose: true, message: error, type: &quot;warning&quot; &#125;); return Promise.reject(error);&#125;)// 响应拦截 http 请求回来的一些状态码，包括我们自己的服务器返回的错误码进行一个逻辑处理。Service.interceptors.response.use(res =&gt; &#123; //对响应数据做些事 // if (res.data &amp;&amp; !res.data.success) &#123; // Message(&#123; // // 饿了么的消息弹窗组件,类似toast // showClose: true, // message: res.data.error.message.message ? // res.data.error.message.message : // res.data.error.message, // type: &quot;error&quot; // &#125;); // return Promise.reject(res.data.error.message); // &#125; return res;&#125;, (error) =&gt; &#123; // 错误处理方式1：// if (error.data) &#123;// switch (error.data.code) &#123;// case 401:// // 返回 401 清除token信息并跳转到登录页面// // store.commit(&quot;del_token&quot;);// router.push(&#123;// path: &quot;/login&quot;,// // 记录原来的页面路径用于登录后调回原页面// query: &#123;// redirect: router.currentRoute.fullPath// &#125;// &#125;);// break;// &#125;// &#125; // 错误处理方式2： // 用户登录的时候会拿到一个基础信息,比如用户名,token,过期时间戳 // 直接丢localStorage或者sessionStorage if (!window.localStorage.getItem(&quot;username&quot;)) &#123; // 若是接口访问的时候没有发现有鉴权的基础信息,直接返回登录页 router.push(&#123; path: &quot;/login&quot; &#125;); &#125; else &#123; // 下面是接口回调的satus ,因为我做了一些错误页面,所以都会指向对应的报错页面 if (error.response.status === 403) &#123; router.push(&#123; path: &quot;/error/403&quot; &#125;); &#125; if (error.response.status === 500) &#123; router.push(&#123; path: &quot;/error/500&quot; &#125;); &#125; if (error.response.status === 502) &#123; router.push(&#123; path: &quot;/error/502&quot; &#125;); &#125; if (error.response.status === 404) &#123; router.push(&#123; path: &quot;/error/404&quot; &#125;); &#125; &#125; // 返回 response 里的错误信息 let errorInfo = error.data.error ? error.data.error.message : error.data; return Promise.reject(errorInfo);&#125;)//封装后导出export default Service; 这种方法使用方式有两种： 使用方式1：1：全局配置：在main.js文件里导入封装的axios文件 import axios from ‘@/Axios/axios’; 2：绑定到Vue实例 1Vue.prototype.$axios= axios; //在其他vue组件中就可以this.axios调用使用: 3：在需要使用的单文件VUE组件里面直接使用(因为是全局配置，在使用的单文件里面不需要引入) 12this.$axios.get(url,&#123;params:&#123;ID:888&#125;&#125;).then(res=&gt;&#123;&#125;).catch(error=&gt;&#123;&#125;)this.$axios.post(url,&#123;id:888,name:&quot;sdsdsd&quot;&#125;).then(res=&gt;&#123;&#125;).catch(error=&gt;&#123;&#125;) 使用方式2：在Axios文件夹下（或者其他文件夹）先新建一个api(任意名称)文件：api.js 1：该文件里面下业务接口请求相关的函数： 1234567891011121314151617// 封装后使用的方式import request from &quot;@/Axios/axios.js&quot;export function tableList(query)&#123; return request(&#123; url: &apos;http://yapi.demo.qunar.com/mock/27844/apitest/list&apos;, method: &apos;get&apos;, params: query &#125;)&#125;export function goodsList(query)&#123; return request(&#123; url: &apos;http://yapi.demo.qunar.com/mock/27844/apitest/list&apos;, method: &apos;get&apos;, params: query &#125;)&#125; 2:在需要使用的单文件里面导入需要调用的接口函数 比如:home.vue单文件里面 123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;div class=&quot;mainBox&quot;&gt; &lt;table-component v-if=&quot;data.length&gt;0&quot; :goodslist=&quot;data&quot;&gt;&lt;/table-component&gt; &lt;/div&gt;&lt;/template&gt;&lt;style rel=&quot;stylesheet/scss&quot; lang=&quot;scss&quot; scoped&gt;&lt;/style&gt;&lt;script&gt; // 导入接口函数import &#123;tableList&#125; from &quot;../Axios/api.js&quot; ;import tableComponent from &quot;@/view/table/table&quot;;export default &#123; data() &#123; return &#123; data:[] &#125; &#125;, mounted() &#123; this.getData() &#125;, methods:&#123; getData()&#123; //使用接口函数 tableList().then(res=&gt;&#123; console.log(res.data); this.data = res.data.list &#125;) &#125; &#125;, components: &#123; tableComponent &#125;,&#125;&lt;/script&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/categories/vue/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/tags/vue/"},{"name":"axios","slug":"axios","permalink":"https://WLL-1017065322.github.io/blog/tags/axios/"}],"author":"along"},{"title":"axios post 后端拿不到数据","slug":"axios post 后端拿不到数据","date":"2019-07-16T16:00:00.000Z","updated":"2019-10-28T08:04:48.856Z","comments":true,"path":"2019/07/17/axios post 后端拿不到数据/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/07/17/axios post 后端拿不到数据/","excerpt":"","text":"1.是因为数据格式不对，通俗来说，后端需要的是JSON字符串(formData类型)，不是对象（Request Payload格式），而axios默认的post方法是以对象形式发送，比如 { id：1， lastid: 3 }变成JSON对象（Request Payload） 方法一：【用 URLSearchParams 传递参数】let param = new URLSearchParams() param.append(‘username’, ‘admin’) param.append(‘pwd’, ‘admin’) axios({ method: ‘post’, url: ‘/api/lockServer/search’, data: param }) 需要注意的是：URLSearchParams 不支持所有的浏览器，但是总体的支持情况还是 OK 的，所以优先推荐这种简单直接的解决方案方法二：【还需要额外的操作，（我们要将参数转换为query参数）】引入 qs ，这个库是 axios 里面包含的，不需要再下载了。import Qs from ‘qs’ let data = { “username”: “admin”, “pwd”: “admin” } axios({ method: ‘post’, url: ‘/api/lockServer/search’, data: Qs.stringify(data) })","categories":[{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/categories/vue/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/tags/vue/"},{"name":"axios","slug":"axios","permalink":"https://WLL-1017065322.github.io/blog/tags/axios/"}],"author":"along"},{"title":"vuex","slug":"vuex","date":"2019-07-12T16:00:00.000Z","updated":"2019-10-28T08:56:10.565Z","comments":true,"path":"2019/07/13/vuex/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/07/13/vuex/","excerpt":"","text":"一. 什么是Vuex?Vuex是一个专门为Vue.js应用程序开发的状态管理模式, 它采用集中式存储管理所有组件的公共状态, 并以相应的规则保证状态以一种可预测的方式发生变化. Vuex核心 上图中绿色虚线包裹起来的部分就是Vuex的核心, state中保存的就是公共状态, 改变state的唯一方式就是通过mutations进行更改. 可能你现在看这张图有点不明白, 等经过本文的解释和案例演示, 再回来看这张图, 相信你会有更好的理解. 二. 为什么要使用Vuex?试想这样的场景, 比如一个Vue的根实例下面有一个根组件名为App.vue, 它下面有两个子组件A.vue和B.vue, App.vue想要与A.vue或者B.vue通讯可以通过props传值的方式, 但是如果A.vue和B.vue之间的通讯就很麻烦了, 他们需要共有的父组件通过自定义事件进行实现, A组件想要和B组件通讯往往是这样的: 组件通讯 A组件说: “报告老大, 能否帮我托个信给小弟B” =&gt; dispatch一个事件给App App老大说: “包在我身上, 它需要监听A组件的dispatch的时间, 同时需要broadcast一个事件给B组件” B小弟说: “信息已收到”, 它需要on监听App组件分发的事件 这只是一条通讯路径, 如果父组件下有多个子组件, 子组件之间通讯的路径就会变的很繁琐, 父组件需要监听大量的事件, 还需要负责分发给不同的子组件, 很显然这并不是我们想要的组件化的开发体验. Vuex就是为了解决这一问题出现的 三.如何引入Vuex? 下载vuex: npm install vuex --save 在main.js添加: 12345678910111213import Vuex from &apos;vuex&apos;Vue.use( Vuex );const store = new Vuex.Store(&#123; //待添加&#125;)new Vue(&#123; el: &apos;#app&apos;, store, render: h =&gt; h(App)&#125;) 四. Vuex的核心概念?在介绍Vuex的核心概念之前, 我使用vue-cli初始化了一个demo, 准备以代码的形式来说明Vuex的核心概念, 大家可以在github上的master分支进行下载.这个demo分别有两个组件ProductListOne.vue和ProductListTwo.vue, 在App.vue的datat中保存着共有的商品列表, 代码和初始化的效果如下图所示: 初始化效果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131//App.vue中的初始化代码&lt;template&gt;&lt;div id=&quot;app&quot;&gt; &lt;product-list-one v-bind:products=&quot;products&quot;&gt;&lt;/product-list-one&gt; &lt;product-list-two v-bind:products=&quot;products&quot;&gt;&lt;/product-list-two&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ProductListOne from &apos;./components/ProductListOne.vue&apos;import ProductListTwo from &apos;./components/ProductListTwo.vue&apos;export default &#123; name: &apos;app&apos;, components: &#123; &apos;product-list-one&apos;: ProductListOne, &apos;product-list-two&apos;: ProductListTwo &#125;, data () &#123; return &#123; products: [ &#123;name: &apos;鼠标&apos;, price: 20&#125;, &#123;name: &apos;键盘&apos;, price: 40&#125;, &#123;name: &apos;耳机&apos;, price: 60&#125;, &#123;name: &apos;显示屏&apos;, price: 80&#125; ] &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;body&#123; font-family: Ubuntu; color: #555;&#125;&lt;/style&gt;//ProductListOne.vue&lt;template&gt; &lt;div id=&quot;product-list-one&quot;&gt; &lt;h2&gt;Product List One&lt;/h2&gt; &lt;ul&gt; &lt;li v-for=&quot;product in products&quot;&gt; &lt;span class=&quot;name&quot;&gt;&#123;&#123; product.name &#125;&#125;&lt;/span&gt; &lt;span class=&quot;price&quot;&gt;$&#123;&#123; product.price &#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: [&apos;products&apos;], data () &#123; return &#123; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;#product-list-one&#123; background: #FFF8B1; box-shadow: 1px 2px 3px rgba(0,0,0,0.2); margin-bottom: 30px; padding: 10px 20px;&#125;#product-list-one ul&#123; padding: 0;&#125;#product-list-one li&#123; display: inline-block; margin-right: 10px; margin-top: 10px; padding: 20px; background: rgba(255,255,255,0.7);&#125;.price&#123; font-weight: bold; color: #E8800C;&#125;&lt;/style&gt;//ProductListTwo.vue&lt;template&gt; &lt;div id=&quot;product-list-two&quot;&gt; &lt;h2&gt;Product List Two&lt;/h2&gt; &lt;ul&gt; &lt;li v-for=&quot;product in products&quot;&gt; &lt;span class=&quot;name&quot;&gt;&#123;&#123; product.name &#125;&#125;&lt;/span&gt; &lt;span class=&quot;price&quot;&gt;$&#123;&#123; product.price &#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: [&apos;products&apos;], data () &#123; return &#123; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;#product-list-two&#123; background: #D1E4FF; box-shadow: 1px 2px 3px rgba(0,0,0,0.2); margin-bottom: 30px; padding: 10px 20px;&#125;#product-list-two ul&#123; padding: 0; list-style-type: none;&#125;#product-list-two li&#123; margin-right: 10px; margin-top: 10px; padding: 20px; background: rgba(255,255,255,0.7);&#125;.price&#123; font-weight: bold; color: #860CE8; display: block;&#125;&lt;/style&gt; 核心概念1: Statestate就是Vuex中的公共的状态, 我是将state看作是所有组件的data, 用于保存所有组件的公共数据. 此时我们就可以把App.vue中的两个组件共同使用的data抽离出来, 放到state中,代码如下: 1234567891011121314151617181920212223//main.jsimport Vue from &apos;vue&apos;import App from &apos;./App.vue&apos;import Vuex from &apos;vuex&apos;Vue.use( Vuex )const store = new Vuex.Store(&#123; state:&#123; products: [ &#123;name: &apos;鼠标&apos;, price: 20&#125;, &#123;name: &apos;键盘&apos;, price: 40&#125;, &#123;name: &apos;耳机&apos;, price: 60&#125;, &#123;name: &apos;显示屏&apos;, price: 80&#125; ] &#125;&#125;)new Vue(&#123; el: &apos;#app&apos;, store, render: h =&gt; h(App)&#125;) 此时,ProductListOne.vue和ProductListTwo.vue也需要做相应的更改 12345678910111213141516//ProductListOne.vueexport default &#123; data () &#123; return &#123; products : this.$store.state.products //获取store中state的数据 &#125; &#125;&#125;//ProductListTwo.vueexport default &#123; data () &#123; return &#123; products: this.$store.state.products //获取store中state的数据 &#125; &#125;&#125; 此时的页面如下图所示, 可以看到, 将公共数据抽离出来后, 页面没有发生变化. state效果 到此处的Github仓库中代码为: 分支code01 核心概念2: Getters我将getters属性理解为所有组件的computed属性, 也就是计算属性. vuex的官方文档也是说到可以将getter理解为store的计算属性, getters的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。 此时,我们可以在main.js中添加一个getters属性, 其中的saleProducts对象将state中的价格减少一半(除以2) 12345678910111213141516171819202122//main.jsconst store = new Vuex.Store(&#123; state:&#123; products: [ &#123;name: &apos;鼠标&apos;, price: 20&#125;, &#123;name: &apos;键盘&apos;, price: 40&#125;, &#123;name: &apos;耳机&apos;, price: 60&#125;, &#123;name: &apos;显示屏&apos;, price: 80&#125; ] &#125;, getters:&#123; //添加getters saleProducts: (state) =&gt; &#123; let saleProducts = state.products.map( product =&gt; &#123; return &#123; name: product.name, price: product.price / 2 &#125; &#125;) return saleProducts; &#125; &#125; &#125;) 将productListOne.vue中的products的值更换为this.$store.getters.saleProducts 1234567export default &#123; data () &#123; return &#123; products : this.$store.getters.saleProducts &#125; &#125;&#125; 现在的页面中,Product List One中的每项商品的价格都减少了一半 getters效果 到此处的Github仓库中代码为: 分支code02 核心概念3: Mutations我将mutaions理解为store中的methods, mutations对象中保存着更改数据的回调函数,该函数名官方规定叫type, 第一个参数是state, 第二参数是payload, 也就是自定义的参数. 下面,我们在main.js中添加mutations属性,其中minusPrice这个回调函数用于将商品的价格减少payload这么多, 代码如下: 1234567891011121314151617181920212223242526272829//main.jsconst store = new Vuex.Store(&#123; state:&#123; products: [ &#123;name: &apos;鼠标&apos;, price: 20&#125;, &#123;name: &apos;键盘&apos;, price: 40&#125;, &#123;name: &apos;耳机&apos;, price: 60&#125;, &#123;name: &apos;显示屏&apos;, price: 80&#125; ] &#125;, getters:&#123; saleProducts: (state) =&gt; &#123; let saleProducts = state.products.map( product =&gt; &#123; return &#123; name: product.name, price: product.price / 2 &#125; &#125;) return saleProducts; &#125; &#125;, mutations:&#123; //添加mutations minusPrice (state, payload ) &#123; let newPrice = state.products.forEach( product =&gt; &#123; product.price -= payload &#125;) &#125; &#125;&#125;) 在ProductListTwo.vue中添加一个按钮,为其添加一个点击事件, 给点击事件触发minusPrice方法 12345678910111213//ProductListTwo.vue&lt;template&gt; &lt;div id=&quot;product-list-two&quot;&gt; &lt;h2&gt;Product List Two&lt;/h2&gt; &lt;ul&gt; &lt;li v-for=&quot;product in products&quot;&gt; &lt;span class=&quot;name&quot;&gt;&#123;&#123; product.name &#125;&#125;&lt;/span&gt; &lt;span class=&quot;price&quot;&gt;$&#123;&#123; product.price &#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;button @click=&quot;minusPrice&quot;&gt;减少价格&lt;/button&gt; //添加按钮 &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt; 在ProductListTwo.vue中注册minusPrice方法, 在该方法中commitmutations中的minusPrice这个回调函数 注意:调用mutaions中回调函数, 只能使用store.commit(type, payload) 12345678910111213//ProductListTwo.vueexport default &#123; data () &#123; return &#123; products: this.$store.state.products &#125; &#125;, methods: &#123; minusPrice() &#123; this.$store.commit(&apos;minusPrice&apos;, 2); //提交`minusPrice,payload为2 &#125; &#125;&#125; 添加按钮, 可以发现, Product List Two中的价格减少了2, 当然你可以自定义 1payload ,以此自定义减少对应的价格. mutations效果 (Product List One中的价格没有发生变化，原因是getter 监听的是map方法产生的新对象) 到此处的Github仓库中代码为: 分支code03 核心概念4: Actionsactions 类似于 mutations，不同在于： actions提交的是mutations而不是直接变更状态 actions中可以包含异步操作, mutations中绝对不允许出现异步 actions中的回调函数的第一个参数是context, 是一个与store实例具有相同属性和方法的对象 此时,我们在store中添加actions属性, 其中minusPriceAsync采用setTimeout来模拟异步操作,延迟2s执行 该方法用于异步改变我们刚才在mutaions中定义的minusPrice 123456789101112131415161718192021222324252627282930313233343536//main.jsconst store = new Vuex.Store(&#123; state:&#123; products: [ &#123;name: &apos;鼠标&apos;, price: 20&#125;, &#123;name: &apos;键盘&apos;, price: 40&#125;, &#123;name: &apos;耳机&apos;, price: 60&#125;, &#123;name: &apos;显示屏&apos;, price: 80&#125; ] &#125;, getters:&#123; saleProducts: (state) =&gt; &#123; let saleProducts = state.products.map( product =&gt; &#123; return &#123; name: product.name, price: product.price / 2 &#125; &#125;) return saleProducts; &#125; &#125;, mutations:&#123; minusPrice (state, payload ) &#123; let newPrice = state.products.forEach( product =&gt; &#123; product.price -= payload &#125;) &#125; &#125;, actions:&#123; //添加actions minusPriceAsync( context, payload ) &#123; setTimeout( () =&gt; &#123; context.commit( &apos;minusPrice&apos;, payload ); //context提交 &#125;, 2000) &#125; &#125;&#125;) 在ProductListTwo.vue中添加一个按钮,为其添加一个点击事件, 给点击事件触发minusPriceAsync方法 12345678910111213&lt;template&gt; &lt;div id=&quot;product-list-two&quot;&gt; &lt;h2&gt;Product List Two&lt;/h2&gt; &lt;ul&gt; &lt;li v-for=&quot;product in products&quot;&gt; &lt;span class=&quot;name&quot;&gt;&#123;&#123; product.name &#125;&#125;&lt;/span&gt; &lt;span class=&quot;price&quot;&gt;$&#123;&#123; product.price &#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;button @click=&quot;minusPrice&quot;&gt;减少价格&lt;/button&gt; &lt;button @click=&quot;minusPriceAsync&quot;&gt;异步减少价格&lt;/button&gt; //添加按钮 &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt; 在ProductListTwo.vue中注册minusPriceAsync方法, 在该方法中dispatchactions中的minusPriceAsync这个回调函数 123456789101112131415export default &#123; data () &#123; return &#123; products: this.$store.state.products &#125; &#125;, methods: &#123; minusPrice() &#123; this.$store.commit(&apos;minusPrice&apos;, 2); &#125;, minusPriceAsync() &#123; this.$store.dispatch(&apos;minusPriceAsync&apos;, 5); //分发actions中的minusPriceAsync这个异步函数 &#125; &#125;&#125; 添加按钮, 可以发现, Product List Two中的价格延迟2s后减少了5 actions效果 到此处的Github仓库中代码为: 分支code04 核心概念5: Modules 由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割 12345678910111213141516171819202122const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态 【相关链接】 本文代码地址: https://github.com/Lee-Tanghui/Vuex-Demo Vuex官方文档: https://vuex.vuejs.org/zh-cn/intro.html Vuex官方案例演示源码: https://github.com/vuejs/vuex/tree/dev/examples 作者：李棠辉 链接：https://www.jianshu.com/p/a804606ad8e9 来源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","categories":[{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/categories/vue/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"https://WLL-1017065322.github.io/blog/tags/vuex/"}],"author":"along"},{"title":"vuerouter传参","slug":"vuerouter传参","date":"2019-07-08T16:00:00.000Z","updated":"2019-10-28T08:02:59.173Z","comments":true,"path":"2019/07/09/vuerouter传参/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/07/09/vuerouter传参/","excerpt":"","text":"123456789101112131415161718192021222324// params使用场景router.push(&apos;/users/123&apos;) // 跳转时router.push(&#123; // 另一种方式跳转 name: &apos;users&apos;, params: &#123; id: 123 &#125;&#125;)// 获取idroute.params.id // 123// 实际URL地址 =&gt; localhost:8080/users/123// query使用场景router.push(&apos;books?q=123&apos;) // 跳转时router.push(&#123; // 另一种方式跳转 path: &apos;/books&apos;, query: &#123; q: 123 &#125;&#125;)// 获取queryroute.query.q // 123// 实际URL地址 =&gt; localhost:8080/books?q=123 &lt;router-link&gt; Props#to 类型: string | Location required 表示目标路由的链接。当被点击后，内部会立刻把 to 的值传到 router.push()，所以这个值可以是一个字符串或者是描述目标位置的对象。 12345678910111213141516171819&lt;!-- 字符串 --&gt;&lt;router-link to=\"home\"&gt;Home&lt;/router-link&gt;&lt;!-- 渲染结果 --&gt;&lt;a href=\"home\"&gt;Home&lt;/a&gt;&lt;!-- 使用 v-bind 的 JS 表达式 --&gt;&lt;router-link v-bind:to=\"'home'\"&gt;Home&lt;/router-link&gt;&lt;!-- 不写 v-bind 也可以，就像绑定别的属性一样 --&gt;&lt;router-link :to=\"'home'\"&gt;Home&lt;/router-link&gt;&lt;!-- 同上 --&gt;&lt;router-link :to=\"&#123; path: 'home' &#125;\"&gt;Home&lt;/router-link&gt;&lt;!-- 命名的路由 --&gt;&lt;router-link :to=\"&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;\"&gt;User&lt;/router-link&gt;&lt;!-- 带查询参数，下面的结果为 /register?plan=private --&gt;&lt;router-link :to=\"&#123; path: 'register', query: &#123; plan: 'private' &#125;&#125;\"&gt;Register&lt;/router-link&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/categories/vue/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/tags/vue/"},{"name":"vue-router","slug":"vue-router","permalink":"https://WLL-1017065322.github.io/blog/tags/vue-router/"}],"author":"along"},{"title":"vuecli打包的几个问题","slug":"vuecli打包的几个问题","date":"2019-07-04T16:00:00.000Z","updated":"2019-10-28T08:03:10.230Z","comments":true,"path":"2019/07/05/vuecli打包的几个问题/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/07/05/vuecli打包的几个问题/","excerpt":"","text":"vue-cli项目打包出现空白页和路径错误问题vue-cli项目打包： \\1. 命令行输入：npm run build ​ 打包出来后项目中就会多了一个文件夹dist，这就是我们打包过后的项目。 第一个问题，文件引用路径。我们直接运行打包后的文件夹中的index.html文件，会看到网页一片空白，f12调试，全是css，js路径引用错误的问题。 解决：到config文件夹中打开index.js文件。 文件里面有两个assetsPublicPath属性，更改第一个，也就是更改build里面的assetsPublicPath属性： assetsPublicPath属性作用是指定编译发布的根目录，‘/’指的是项目的根目录 ，’./’指的是当前目录。 改好之后重新打包项目，运行index.html文件，我们可以看到没有报错了。但是router-view里面的内容却出不来了。 第二个问题：router-view中的内容显示不出来。路由history模式。这个坑是当你使用了路由之后，在没有后端配合的情况下就手贱打开路由history模式的时候，打包出来的文件也会是一片空白的情况， 很多人踩这个坑的时候花了很多时间，网上的教程基本上都是说的第一个坑，这个坑很少有人提起。 解决：// mode: &#39;history&#39;,//将这个模式关闭就好 这里并不是说不能打开这个模式，这个模式需要后端设置的配合，详情可以看：路由文档","categories":[{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/categories/vue/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/tags/vue/"},{"name":"vue-cli","slug":"vue-cli","permalink":"https://WLL-1017065322.github.io/blog/tags/vue-cli/"}],"author":"along"},{"title":"vue数据添加新属性遇到的问题","slug":"vue数据添加新属性遇到的问题","date":"2019-06-28T16:00:00.000Z","updated":"2019-10-28T07:59:33.170Z","comments":true,"path":"2019/06/29/vue数据添加新属性遇到的问题/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/06/29/vue数据添加新属性遇到的问题/","excerpt":"","text":"vue为数据添加属性时遇到的坑，通过self.book[i].[‘cur’]=false;动态为数据添加属性时，数据变化了，但是视图没有发生更新。 具体原因不明白。。。。 解决方法：通过set来添加属性this.set来添加属性this.set(self.book[i],’cur’,false); 这样子来设置，就没问题了 当我们给一个比如props中，或者data中被观测的对象添加一个新的属性的时候，不能直接添加，必须使用Vue.set方法Vue.set方法用来新增对象的属性。如果要增加属性的对象是响应式的，那该方法可以确保属性被创建后也是响应式的，同时触发视图更新 这里本来food对象是没有count属性的，我们要给其添加count属性就必须使用Vue.set方法，而不能写成’this.food.count = 1’ 在开发过程中，我们时常会遇到这样一种情况：当vue的data里边声明或者已经赋值过的对象或者数组（数组里边的值是对象）时，向对象中添加新的属性，如果更新此属性的值，是不会更新视图的。 根据官方文档定义：如果在实例创建之后添加新的属性到实例上，它不会触发视图更新。 受现代 JavaScript 的限制 (以及废弃 Object.observe)，Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。 看以下实例： 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div&gt; &lt;p @click=&quot;addd(obj)&quot;&gt;&#123;&#123;obj.d&#125;&#125;&lt;/p&gt; &lt;p @click=&quot;adde(obj)&quot;&gt; &#123;&#123;obj.e&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;/template&gt; &lt;script&gt; export default &#123; data()&#123; return &#123; obj:&#123;&#125; &#125; &#125;, mounted() &#123; this.obj = &#123;d: 0&#125;; this.obj.e = 0; console.log(&apos;after--&apos;, this.obj); &#125;, methods: &#123; addd(item) &#123; item.d = item.d + 1; console.log(&apos;item--&apos;,item); &#125;, adde(item) &#123; item.e = item.e + 1; console.log(&apos;item--&apos;,item); &#125; &#125; &#125; &lt;/scirpt&gt; image.png 可以看出d属性是有get 和 set方法的，而新增的e属性是没有的。 点击触发3次addd，点击触发3次adde,页面效果及控制台信息如下 image.png image.png 此时触发1次addd,页面效果如下： image.png image.png 由此可以看出，更新新增属性e，是不会更新视图，但是会改变其值，当更新原有属性d时会更新视图，同时将新增的属性e的值也更新到视图里边 解决方案官方定义： Vue 不允许在已经创建的实例上动态添加新的根级响应式属性 (root-level reactive property)。然而它可以使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上： Vue.set(vm.obj, ‘e’, 0) 您还可以使用 vm.$set 实例方法，这也是全局 Vue.set 方法的别名： this.$set(this.obj,’e’,02) 有时你想向已有对象上添加一些属性，例如使用 Object.assign() 或 _.extend() 方法来添加属性。但是，添加到对象上的新属性不会触发更新。在这种情况下可以创建一个新的对象，让它包含原对象的属性和新的属性： // 代替 Object.assign(this.obj, { a: 1, e: 2 }) this.obj= Object.assign({}, this.obj, { a: 1, e: 2 }) 上述实例解决如下： image.png 点击触发3次addd，点击触发3次adde,页面效果及控制台信息如下： image.png image.png 权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","categories":[{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/categories/vue/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/tags/vue/"}],"author":"along"},{"title":"vue跳转","slug":"vue跳转","date":"2019-06-28T16:00:00.000Z","updated":"2019-10-28T08:00:41.092Z","comments":true,"path":"2019/06/29/vue跳转/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/06/29/vue跳转/","excerpt":"","text":"1. router-link 1`1. 不带参数`` ``this``.$router.push(``&apos;/home&apos;``)``this``.$router.push(&#123;name:``&apos;home&apos;``&#125;)``this``.$router.push(&#123;path:``&apos;/home&apos;``&#125;)``2. query传参 `` ``this``.$router.push(&#123;name:``&apos;home&apos;``,query: &#123;id:``&apos;1&apos;``&#125;&#125;)``this``.$router.push(&#123;path:``&apos;/home&apos;``,query: &#123;id:``&apos;1&apos;``&#125;&#125;)``// html 取参 $route.query.id``// script 取参 this.$route.query.id``3. params传参`` ``this``.$router.push(&#123;name:``&apos;home&apos;``,params: &#123;id:``&apos;1&apos;``&#125;&#125;) ``// 只能用 name`` ` `// 路由配置 path: &quot;/home/:id&quot; 或者 path: &quot;/home:id&quot; ,``// 不配置path ,第一次可请求,刷新页面id会消失``// 配置path,刷新页面id会保留``// html 取参 $route.params.id``// script 取参 this.$route.params.id``4. query和params区别``query类似 get, 跳转之后页面 url后面会拼接参数,类似?id=1, 非重要性的可以这样传, 密码之类还是用params刷新页面id还在`` ``params类似 post, 跳转之后页面 url后面不会拼接参数 , 但是刷新页面id 会消失` this.$router.push() (函数里面调用) 12345678910111213141516171819201. 不带参数 this.$router.push(&apos;/home&apos;)this.$router.push(&#123;name:&apos;home&apos;&#125;)this.$router.push(&#123;path:&apos;/home&apos;&#125;)2. query传参 this.$router.push(&#123;name:&apos;home&apos;,query: &#123;id:&apos;1&apos;&#125;&#125;)this.$router.push(&#123;path:&apos;/home&apos;,query: &#123;id:&apos;1&apos;&#125;&#125;)// html 取参 $route.query.id// script 取参 this.$route.query.id3. params传参 this.$router.push(&#123;name:&apos;home&apos;,params: &#123;id:&apos;1&apos;&#125;&#125;) // 只能用 name // 路由配置 path: &quot;/home/:id&quot; 或者 path: &quot;/home:id&quot; ,// 不配置path ,第一次可请求,刷新页面id会消失// 配置path,刷新页面id会保留// html 取参 $route.params.id// script 取参 this.$route.params.id4. query和params区别query类似 get, 跳转之后页面 url后面会拼接参数,类似?id=1, 非重要性的可以这样传, 密码之类还是用params刷新页面id还在 params类似 post, 跳转之后页面 url后面不会拼接参数 , 但是刷新页面id 会消失 this.$router.replace() (用法同上,push) this.$router.go(n) () 1this.$router.go(n) 向前或者向后跳转n个页面，n可为正整数或负整数 ps : 区别 1this.$router.push 跳转到指定url路径，并想history栈中添加一个记录，点击后退会返回到上一个页面 1this.$router.replace 跳转到指定url路径，但是history栈中不会有记录，点击返回会跳转到上上个页面 (就是直接替换了当前页面) 1this.$router.go(n) 向前或者向后跳转n个页面，n可为正整数或负整数 总结 以上所述是小编给大家介绍的详解vue 路由跳转四种方式 (带参数)，希望对大家有所帮助，如果大家有人疑问欢迎给我留言，小编会及时回复大家的！","categories":[{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/categories/vue/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/tags/vue/"},{"name":"vue-router","slug":"vue-router","permalink":"https://WLL-1017065322.github.io/blog/tags/vue-router/"}],"author":"along"},{"title":"vue路由导航","slug":"vue路由导航","date":"2019-06-23T16:00:00.000Z","updated":"2019-10-28T08:55:25.209Z","comments":true,"path":"2019/06/24/vue路由导航/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/06/24/vue路由导航/","excerpt":"","text":"Vue-详解设置路由导航的两种方法:和router.push(…)一、\\ to里的值可以是一个字符串路径，或者一个描述地址的对象。例如： 1234567891011121314// 字符串&lt;router-link to=&quot;apple&quot;&gt; to apple&lt;/router-link&gt;// 对象&lt;router-link :to=&quot;&#123;path:&apos;apple&apos;&#125;&quot;&gt; to apple&lt;/router-link&gt;// 命名路由&lt;router-link :to=&quot;&#123;name: &apos;applename&apos;&#125;&quot;&gt; to apple&lt;/router-link&gt;//直接路由带查询参数query，地址栏变成 /apple?color=red&lt;router-link :to=&quot;&#123;path: &apos;apple&apos;, query: &#123;color: &apos;red&apos; &#125;&#125;&quot;&gt; to apple&lt;/router-link&gt;// 命名路由带查询参数query，地址栏变成/apple?color=red&lt;router-link :to=&quot;&#123;name: &apos;applename&apos;, query: &#123;color: &apos;red&apos; &#125;&#125;&quot;&gt; to apple&lt;/router-link&gt;//直接路由带路由参数params，params 不生效，如果提供了 path，params 会被忽略&lt;router-link :to=&quot;&#123;path: &apos;apple&apos;, params: &#123; color: &apos;red&apos; &#125;&#125;&quot;&gt; to apple&lt;/router-link&gt;// 命名路由带路由参数params，地址栏是/apple/red&lt;router-link :to=&quot;&#123;name: &apos;applename&apos;, params: &#123; color: &apos;red&apos; &#125;&#125;&quot;&gt; to apple&lt;/router-link&gt; 二、router.push(…)方法 同样的规则也适用于router.push(…)方法。 1234567891011121314// 字符串router.push(&apos;apple&apos;)// 对象router.push(&#123;path:&apos;apple&apos;&#125;)// 命名路由router.push(&#123;name: &apos;applename&apos;&#125;)//直接路由带查询参数query，地址栏变成 /apple?color=redrouter.push(&#123;path: &apos;apple&apos;, query: &#123;color: &apos;red&apos; &#125;&#125;)// 命名路由带查询参数query，地址栏变成/apple?color=redrouter.push(&#123;name: &apos;applename&apos;, query: &#123;color: &apos;red&apos; &#125;&#125;)//直接路由带路由参数params，params 不生效，如果提供了 path，params 会被忽略router.push(&#123;path:&apos;applename&apos;, params:&#123; color: &apos;red&apos; &#125;&#125;)// 命名路由带路由参数params，地址栏是/apple/redrouter.push(&#123;name:&apos;applename&apos;, params:&#123; color: &apos;red&apos; &#125;&#125;) 三、注意点 1、关于带参数的路由总结如下： 无论是直接路由“path” 还是命名路由“name”，带查询参数query，地址栏会变成“/url?查询参数名：查询参数值“;直接路由“path” 带路由参数params params 不生效;命名路由“name” 带路由参数params 地址栏保持是“/url/路由参数值”; 2、设置路由map里的path值： 带路由参数params时，路由map里的path应该写成: path:’/apple/:color’ ; 带查询参数query时，路由map里的path应该写成: path:’/apple’ ； 3、获取参数方法： 在组件中： 在js里： this.$route.params.color","categories":[{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/categories/vue/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/tags/vue/"},{"name":"vue-router","slug":"vue-router","permalink":"https://WLL-1017065322.github.io/blog/tags/vue-router/"}],"author":"along"},{"title":"vue监听滚动事件 实现某元素吸顶或者固定位置显示","slug":"vue监听滚动事件 实现某元素吸顶或者固定位置显示","date":"2019-06-20T16:00:00.000Z","updated":"2019-10-28T07:57:35.645Z","comments":true,"path":"2019/06/21/vue监听滚动事件 实现某元素吸顶或者固定位置显示/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/06/21/vue监听滚动事件 实现某元素吸顶或者固定位置显示/","excerpt":"","text":"最近写了一个VUE的web app项目，需要实现某个部位吸顶的效果。即，页面往上滑动，刚好到达该部位时，该部分，固定在顶部显示。 1、监听滚动事件 利用VUE写一个在控制台打印当前的scrollTop, 首先，在mounted钩子中给window添加一个滚动滚动监听事件， mounted () { window.addEventListener(‘scroll’, this.handleScroll)},然后在方法中，添加这个handleScroll方法 handleScroll () { var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop console.log(scrollTop)}, 控制台打印结果： 2、监听元素到顶部的距离 并判断滚动的距离如果大于了元素到顶部的距离时，设置searchBar为true,否则就是false handleScroll () { let scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop let offsetTop = document.querySelector(‘#searchBar’).offsetTop scrollTop &gt; offsetTop ? this.searchBarFixed = true : this.searchBarFixed = false},先写一个该元素固定到顶部的样式，isFixed（less写法） .searchBar{ .isFixed{ position:fixed; background-color:#Fff; top:0; z-index:999; } ul { WIDTH:100%; height: 40px; line-height: 40px; display: flex; li { font-size: 0.8rem; text-align: center; flex: 1; i { font-size: 0.9rem; padding-left: 5px; color: #ccc; } } border-bottom: 1px solid #ddd; }} 然后将需要固定的元素的class与searchBar进行绑定，如果searchBar为true时，就应用这个isFixed样式 区域 价格 房型 更多 固定后的结果： 注意，如果离开该页面需要移除这个监听的事件，不然会报错。 destroyed () { window.removeEventListener(‘scroll’, this.handleScroll)},","categories":[{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/categories/vue/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/tags/vue/"}],"author":"along"},{"title":"vue的{__ob__ Observer}","slug":"vue的{__ob__ Observer}","date":"2019-06-17T16:00:00.000Z","updated":"2019-10-28T07:57:05.263Z","comments":true,"path":"2019/06/18/vue的{__ob__ Observer}/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/06/18/vue的{__ob__ Observer}/","excerpt":"","text":"_ob__: Observer这些数据是vue这个框架对数据设置的监控器，一般都是不可枚举的。 console.log这样的打印函数，被打印的变量会执行自身的toString()，这样，即便内部属性是不可枚举，实际上也能看到。 操作数据的过程中不要删除这些属性： 因为你已经将数据绑定在了vue之中，vue就肯定要为数据添加监控器的，如果你强制删掉了这些监控器，那么这些数据也就失去了监控，那么你使用vue的意义何在…… 提交数据时可以通过： console.log(JSON.stringify(this.obj))，进行获取原始数据对象 (javascript)vue中为什么[ob: Observer]下无法取到数据问题： (javascript)vue中为什么[ob: Observer]下无法取到数据 描述: vue中为什么[ob: Observer]下无法取到数据,可是控制台明明有数据 解决方案1: 问题出在异步上，跟 [ob: Observer] 无关 原因在与，你同时发起了几个请求，但是 jsonp() 调用结果返回的顺序不确定，可能会导致 index=1 的 then() 函数比 index=0 的 then() 函数先执行，此时 this.detailId 数组只有一个值，而你取的时候是 this.detailId[1]（因为 index=1的结果先返回），所以报错了 下面提供一种修复的方式，在 then() 函数里做点改动： 12345// remove// this.detailId.push(new Movie(res.id, res.wish_count))// addthis.$set(this.detailId, index, new Movie(res.id, res.wish_count)) 以上介绍了“ (javascript)vue中为什么[ob: Observer]下无法取到数据”的问题解答，希望对有需要的网友有所帮助。 2: 我也遇到这个问题 首先把数据转换 this.tableData = res.data;//后台获取的数据 this.datalist = JSON.parse(JSON.stringify(this.tableData));//把数据转化后赋予this.datalist 然后this.datalist[0].id //就可以拿到数据 ，要在数组中拿， //而不是this.datalist.id,这样是 undefined 在操作数据的时候发现，ob: Observer这个属性出现之后，如果单独拿数据的值，就会返回undefined。于是就到网上查相关的资料，发现ob: Observer是vue一个很重要的知识点。 数据对象的 ob 属性 ob: Observer这些数据是vue这个框架对数据设置的监控器，一般都是不可枚举的。 网上有很多解决的方案： 第一种：ob: Observer 是 Vue 对数据监控添加的属性，如果想去掉可以用赋值的方式。例如Object.assign({},this.owner)。 用这种方式也是可以解决。 第二种：假设list里面存放的就是那些带有ob: Observer的可以用JSON.parse(JSON.stringify(this.list)）完美解决 第三种（我自己用的）：直接操作数据 控制台输出的数据 this.tableData = res.data; //后台返回的数据赋予 this.tableData 如果在控制台输出，console.log(this.tableData.id) //就会返回undefined 如果是这样打印数据，console.log(this.tableData[0].id) //就会返回你想要的id了 式的转载都请联系作者获得授权并注明出处。","categories":[{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/categories/vue/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/tags/vue/"}],"author":"along"},{"title":"vue导航钩子","slug":"vue导航钩子","date":"2019-06-14T16:00:00.000Z","updated":"2019-10-28T07:56:42.281Z","comments":true,"path":"2019/06/15/vue导航钩子/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/06/15/vue导航钩子/","excerpt":"","text":"Vue-router导航钩子正如其名，vue-router 提供的导航钩子主要用来拦截导航，让它完成跳转或取消。 有多种方式可以在路由导航发生时执行钩子：1.全局的2.单个路由独享的3.组件级的 全局钩子1234567891011//定义一个路由const router = new VueRouter(&#123; ... &#125;)// 点击导航前调用router.beforeEach((to, from, next) =&gt; &#123; // ...&#125;)// 点击导航后调用router.afterEach(route =&gt; &#123; // ...&#125;)123456789101112 当一个导航触发时，全局的 before 钩子按照创建顺序调用。钩子是异步解析执行，此时导航在所有钩子 resolve 完之前一直处于 等待中。 每个钩子方法接收三个参数： to: Route: 即将要进入的目标 路由对象 from: Route: 当前导航正要离开的路由 next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。 next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed （确认的）。 next(false): 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 from 路由对应的地址。 next(‘/’) 或者 next({ path: ‘/’ }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。 确保要调用 next 方法，否则钩子就不会被 resolved。 单个路由独享的钩子你可以在路由配置上直接定义 beforeEnter 钩子： 1234567891011121314const router = new VueRouter(&#123; routes: [ &#123; path: '/foo', component: Foo, beforeEnter: (to, from, next) =&gt; &#123; // ... &#125;, beforeEnter: (route) =&gt; &#123; // ... &#125; &#125; ]&#125;);1234567891011121314 这些钩子与全局 before 钩子的方法参数是一样的。 组件内的钩子最后，你可以在路由组件内直接定义以下路由导航钩子： beforeRouteEnterbeforeRouteUpdate (2.2 新增)beforeRouteLeave 123456789101112131415161718const Foo = &#123; template: `...`, beforeRouteEnter (to, from, next) &#123; // 在渲染该组件的对应路由被 confirm 前调用 // 不！能！获取组件实例 `this` // 因为当钩子执行前，组件实例还没被创建 &#125;, beforeRouteUpdate (to, from, next) &#123; // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 `this` &#125;, beforeRouteLeave (to, from, next) &#123; // 导航离开该组件的对应路由时调用 // 可以访问组件实例 `this` &#125;&#125;123456789101112131415161718 beforeRouteEnter 钩子 不能 访问 this，因为钩子在导航确认前被调用,因此即将登场的新组件还没被创建。 不过，你可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。 12345beforeRouteEnter (to, from, next) &#123; next(vm =&gt; &#123; // 通过 `vm` 访问组件实例 &#125;)&#125;12345 你可以 在 beforeRouteLeave 中直接访问 this。这个 leave 钩子通常用来禁止用户在还未保存修改前突然离开。可以通过 next(false) 来取消导航。","categories":[{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/categories/vue/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/tags/vue/"}],"author":"along"},{"title":"vue插槽","slug":"vue插槽","date":"2019-06-11T16:00:00.000Z","updated":"2019-10-28T07:55:31.742Z","comments":true,"path":"2019/06/12/vue插槽/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/06/12/vue插槽/","excerpt":"","text":"单个插槽除非子组件模板包含至少一个 \\ 插口，否则父组件的内容将会被丢弃。当子组件模板只有一个没有属性的插槽时，父组件传入的整个内容片段将插入到插槽所在的 DOM 位置，并替换掉插槽标签本身。 最初在 \\ 标签中的任何内容都被视为备用内容。备用内容在子组件的作用域内编译，并且只有在宿主元素为空，且没有要插入的内容时才显示备用内容。 假定 my-component 组件有如下模板： 123456&lt;div&gt; &lt;h2&gt;我是子组件的标题&lt;/h2&gt; &lt;slot&gt; 只有在没有要分发的内容时才会显示。 &lt;/slot&gt;&lt;/div&gt; 父组件模板： 1234567&lt;div&gt; &lt;h1&gt;我是父组件的标题&lt;/h1&gt; &lt;my-component&gt; &lt;p&gt;这是一些初始内容&lt;/p&gt; &lt;p&gt;这是更多的初始内容&lt;/p&gt; &lt;/my-component&gt;&lt;/div&gt; 渲染结果： 12345678&lt;div&gt; &lt;h1&gt;我是父组件的标题&lt;/h1&gt; &lt;div&gt; &lt;h2&gt;我是子组件的标题&lt;/h2&gt; &lt;p&gt;这是一些初始内容&lt;/p&gt; &lt;p&gt;这是更多的初始内容&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 具名插槽场景： 设计组合使用的组件时，内容分发 API 是非常有用的机制 &lt;slot&gt; 元素可以用一个特殊的特性 name 来进一步配置如何分发内容。多个插槽可以有不同的名字。具名插槽将匹配内容片段中有对应 slot 特性的元素。 仍然可以有一个匿名插槽，它是默认插槽，作为找不到匹配的内容片段的备用插槽。如果没有默认插槽，这些找不到匹配的内容片段将被抛弃。 例如，假定我们有一个 app-layout 组件，它的模板为： 1234567891011&lt;div class=&quot;container&quot;&gt; &lt;header&gt; &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt; &lt;/footer&gt;&lt;/div&gt; 父组件模板： 12345678&lt;app-layout&gt; &lt;h1 slot=&quot;header&quot;&gt;这里可能是一个页面标题&lt;/h1&gt; &lt;p&gt;主要内容的一个段落。&lt;/p&gt; &lt;p&gt;另一个主要段落。&lt;/p&gt; &lt;p slot=&quot;footer&quot;&gt;这里有一些联系信息&lt;/p&gt;&lt;/app-layout&gt; 渲染结果为： 123456789101112&lt;div class=&quot;container&quot;&gt; &lt;header&gt; &lt;h1&gt;这里可能是一个页面标题&lt;/h1&gt; &lt;/header&gt; &lt;main&gt; &lt;p&gt;主要内容的一个段落。&lt;/p&gt; &lt;p&gt;另一个主要段落。&lt;/p&gt; &lt;/main&gt; &lt;footer&gt; &lt;p&gt;这里有一些联系信息&lt;/p&gt; &lt;/footer&gt; &lt;/div&gt; 作用域插槽 作用域插槽还不是特别理解。。。。。主要是没想清楚他的应用场景。。。如果有比较理解的可以留言指点一下~ 下面是一个例子但是这种场景我也没太理解这个list有何意义，通用性在哪里？http://blog.csdn.net/oak160/article/details/65447195 2.1.0 新增 作用域插槽是一种特殊类型的插槽，用作一个 (能被传递数据的) 可重用模板，来代替已经渲染好的元素。 在子组件中，只需将数据传递到插槽，就像你将 prop 传递给组件一样： 123&lt;div class=&quot;child&quot;&gt; &lt;slot text=&quot;hello from child&quot;&gt;&lt;/slot&gt;&lt;/div&gt; 在父级中，具有特殊特性 slot-scope 的 元素必须存在，表示它是作用域插槽的模板。slot-scope 的值将被用作一个临时变量名，此变量接收从子组件传递过来的 prop 对象： 12345678&lt;div class=&quot;parent&quot;&gt; &lt;child&gt; &lt;template slot-scope=&quot;props&quot;&gt; &lt;span&gt;hello from parent&lt;/span&gt; &lt;span&gt;&#123;&#123; props.text &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/child&gt;&lt;/div&gt; 如果我们渲染上述模板，得到的输出会是： 123456&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt; &lt;span&gt;hello from parent&lt;/span&gt; &lt;span&gt;hello from child&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 在 2.5.0+，slot-scope 能被用在任意元素或组件中而不再局限于 12345678910作用域插槽更典型的用例是在列表组件中，允许使用者自定义如何渲染列表的每一项：&lt;my-awesome-list :items=&quot;items&quot;&gt; &lt;!-- 作用域插槽也可以是具名的 --&gt; &lt;li slot=&quot;item&quot; slot-scope=&quot;props&quot; class=&quot;my-fancy-item&quot;&gt; &#123;&#123; props.text &#125;&#125; &lt;/li&gt;&lt;/my-awesome-list&gt; 列表组件的模板： 1234567&lt;ul&gt; &lt;slot name=&quot;item&quot; v-for=&quot;item in items&quot; :text=&quot;item.text&quot;&gt; &lt;!-- 这里写入备用内容 --&gt; &lt;/slot&gt;&lt;/ul&gt; 解构 slot-scope 的值实际上是一个可以出现在函数签名参数位置的合法的 JavaScript 表达式。这意味着在受支持的环境 (单文件组件或现代浏览器) 中，您还可以在表达式中使用 ES2015 解构： 123&lt;child&gt; &lt;span slot-scope=&quot;&#123; text &#125;&quot;&gt;&#123;&#123; text &#125;&#125;&lt;/span&gt;&lt;/child&gt; 编写可复用组件在编写组件时，最好考虑好以后是否要进行复用。一次性组件间有紧密的耦合没关系，但是可复用组件应当定义一个清晰的公开接口，同时也不要对其使用的外层数据作出任何假设。 Vue 组件的 API 来自三部分——prop、事件和插槽： Prop 允许外部环境传递数据给组件； 事件允许从组件内触发外部环境的副作用； 插槽允许外部环境将额外的内容组合在组件中。 使用 v-bind 和 v-on 的简写语法，模板的意图会更清楚且简洁： 123456789&lt;my-component :foo=&quot;baz&quot; :bar=&quot;qux&quot; @event-a=&quot;doThis&quot; @event-b=&quot;doThat&quot;&gt; &lt;img slot=&quot;icon&quot; src=&quot;...&quot;&gt; &lt;p slot=&quot;main-text&quot;&gt;Hello!&lt;/p&gt;&lt;/my-component&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/categories/vue/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/tags/vue/"}],"author":"along"},{"title":"vue备忘录","slug":"vue备忘录","date":"2019-06-09T16:00:00.000Z","updated":"2019-10-28T07:54:54.105Z","comments":true,"path":"2019/06/10/vue备忘录/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/06/10/vue备忘录/","excerpt":"","text":"路由跳转： 1 \\&lt;router-link :to=”‘/detail/‘ + item.id” tag=”li” class=”item” v-for=”item in list” :key=”item.id”&gt; 2 \\&lt;div class=”item-info” @click=”$router.push(“/“)”&gt; 3 \\ method: { linkTo(){ this.$router.push(“/“)}} tip: tag: 改变router-link标签 为 **","categories":[{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/categories/vue/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/tags/vue/"}],"author":"along"},{"title":"vue.nextTick()的使用","slug":"vue.nextTick()的使用","date":"2019-06-06T16:00:00.000Z","updated":"2019-10-28T07:54:22.194Z","comments":true,"path":"2019/06/07/vue.nextTick()的使用/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/06/07/vue.nextTick()的使用/","excerpt":"","text":"什么是Vue.nextTick()官方文档解释如下： 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。 我理解的官方文档的这句话的侧重点在最后那半句获取更新后的DOM，获取更新后的DOM言外之意就是什么操作需要用到了更新后的DOM而不能使用之前的DOM或者使用更新前的DOM或出问题，所以就衍生出了这个获取更新后的DOM的Vue方法。所以放在Vue.nextTick()回调函数中的执行的应该是会对DOM进行操作的 js代码，比如Swiper扩展包的 12345678910var swiper = new Swiper(&apos;.swiper-container&apos;, &#123; pagination: &apos;.swiper-pagination&apos;, nextButton: &apos;.swiper-button-next&apos;, prevButton: &apos;.swiper-button-prev&apos;, paginationClickable: true, spaceBetween: 30, centeredSlides: true, autoplay: 2500, autoplayDisableOnInteraction: false &#125;); 什么时候需要用的Vue.nextTick() 你在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中。原因是什么呢，原因是在created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。与之对应的就是mounted钩子函数，因为该钩子函数执行时所有的DOM挂载和渲染都已完成，此时在该钩子函数中进行任何DOM操作都不会有问题 。 在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中。 原因是，Vue是异步执行dom更新的，一旦观察到数据变化，Vue就会开启一个队列，然后把在同一个事件循环 (event loop) 当中观察到数据变化的 watcher 推送进这个队列。如果这个watcher被触发多次，只会被推送到队列一次。这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和DOm操作。而在下一个事件循环时，Vue会清空队列，并进行必要的DOM更新。当你设置 vm.someData = ‘new value’，DOM 并不会马上更新，而是在异步队列被清除，也就是下一个事件循环开始时执行更新时才会进行必要的DOM更新。如果此时你想要根据更新的 DOM 状态去做某些事情，就会出现问题。。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。","categories":[{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/categories/vue/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/tags/vue/"}],"author":"along"},{"title":"Vue-nextTick","slug":"Vue-nextTick","date":"2019-06-03T16:00:00.000Z","updated":"2019-10-28T07:53:15.712Z","comments":true,"path":"2019/06/04/Vue-nextTick/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/06/04/Vue-nextTick/","excerpt":"","text":"什么是Vue.nextTick()官方文档解释如下： 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。 我理解的官方文档的这句话的侧重点在最后那半句获取更新后的DOM，获取更新后的DOM言外之意就是什么操作需要用到了更新后的DOM而不能使用之前的DOM或者使用更新前的DOM或出问题，所以就衍生出了这个获取更新后的DOM的Vue方法。所以放在Vue.nextTick()回调函数中的执行的应该是会对DOM进行操作的 js代码，比如Swiper扩展包的 12345678910var swiper = new Swiper(&apos;.swiper-container&apos;, &#123; pagination: &apos;.swiper-pagination&apos;, nextButton: &apos;.swiper-button-next&apos;, prevButton: &apos;.swiper-button-prev&apos;, paginationClickable: true, spaceBetween: 30, centeredSlides: true, autoplay: 2500, autoplayDisableOnInteraction: false &#125;); 什么时候需要用的Vue.nextTick() 你在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中。原因是什么呢，原因是在created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。与之对应的就是mounted钩子函数，因为该钩子函数执行时所有的DOM挂载和渲染都已完成，此时在该钩子函数中进行任何DOM操作都不会有问题 。 在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中。 原因是，Vue是异步执行dom更新的，一旦观察到数据变化，Vue就会开启一个队列，然后把在同一个事件循环 (event loop) 当中观察到数据变化的 watcher 推送进这个队列。如果这个watcher被触发多次，只会被推送到队列一次。这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和DOm操作。而在下一个事件循环时，Vue会清空队列，并进行必要的DOM更新。当你设置 vm.someData = ‘new value’，DOM 并不会马上更新，而是在异步队列被清除，也就是下一个事件循环开始时执行更新时才会进行必要的DOM更新。如果此时你想要根据更新的 DOM 状态去做某些事情，就会出现问题。。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。","categories":[{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/categories/vue/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/tags/vue/"}],"author":"along"},{"title":"vue-router跳转bug","slug":"vue-router跳转bug","date":"2019-06-03T16:00:00.000Z","updated":"2019-10-28T07:53:39.738Z","comments":true,"path":"2019/06/04/vue-router跳转bug/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/06/04/vue-router跳转bug/","excerpt":"","text":"问题描述: 点击按钮 $router.push()跳转地址,但是页面会强制刷新一次. 并且去掉mode: ‘history’,会导致页面跳转后立即回到原页面 解决方案: 将链接标签的 href去掉即可","categories":[{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/categories/vue/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/tags/vue/"},{"name":"vue-router","slug":"vue-router","permalink":"https://WLL-1017065322.github.io/blog/tags/vue-router/"}],"author":"along"},{"title":"vue-cli-service","slug":"vue-cli-service","date":"2019-05-31T16:00:00.000Z","updated":"2019-10-28T07:52:29.103Z","comments":true,"path":"2019/06/01/vue-cli-service/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/06/01/vue-cli-service/","excerpt":"","text":"概述 vue启动一个项目的时候，需要执行npm run serve，其中这个serve的内容就是vue-cli-service serve。可见，项目的启动关键是这个vue-cli-service与它的参数serve。接下来我们一起看看service中主要写了什么东东（主要内容以备注形式写到代码中。）。 关键代码 vue-cli-service.js 1`const semver = require(``&apos;semver&apos;``)``const &#123; error &#125; = require(``&apos;@vue/cli-shared-utils&apos;``)``const requiredVersion = require(``&apos;../package.json&apos;``).engines.node` `// 检测node版本是否符合vue-cli运行的需求。不符合则打印错误并退出。``if` `(!semver.satisfies(process.version, requiredVersion)) &#123;`` ``error(`` ```You are using Node $&#123;process.version&#125;, but vue-cli-service ` +`` ```requires Node $&#123;requiredVersion&#125;.\\nPlease upgrade your Node version.``` ``)`` ``process.exit(1)``&#125;` `// cli-service的核心类。``const Service = require(``&apos;../lib/Service&apos;``)``// 新建一个service的实例。并将项目路径传入。一般我们在项目根路径下运行该cli命令。所以process.cwd()的结果一般是项目根路径``const service = ``new` `Service(process.env.VUE_CLI_CONTEXT || process.cwd())` `// 参数处理。``const rawArgv = process.argv.slice(2)``const args = require(``&apos;minimist&apos;``)(rawArgv, &#123;`` ``boolean: [`` ``// build`` ``&apos;modern&apos;``,`` ``&apos;report&apos;``,`` ``&apos;report-json&apos;``,`` ``&apos;watch&apos;``,`` ``// serve`` ``&apos;open&apos;``,`` ``&apos;copy&apos;``,`` ``&apos;https&apos;``,`` ``// inspect`` ``&apos;verbose&apos;`` ``]``&#125;)``const command = args._[0]` `// 将参数传入service这个实例并启动后续工作。如果我们运行的是npm run serve。则command = &quot;serve&quot;。``service.run(command, args, rawArgv).``catch``(err =&gt; &#123;`` ``error(err)`` ``process.exit(1)``&#125;)` Service.js 上面实例化并调用了service的run方法，这里从构造函数到run一路浏览即可。 1`const fs = require(``&apos;fs&apos;``)``const path = require(``&apos;path&apos;``)``const debug = require(``&apos;debug&apos;``)``const chalk = require(``&apos;chalk&apos;``)``const readPkg = require(``&apos;read-pkg&apos;``)``const merge = require(``&apos;webpack-merge&apos;``)``const Config = require(``&apos;webpack-chain&apos;``)``const PluginAPI = require(``&apos;./PluginAPI&apos;``)``const loadEnv = require(``&apos;./util/loadEnv&apos;``)``const defaultsDeep = require(``&apos;lodash.defaultsdeep&apos;``)``const &#123; warn, error, isPlugin, loadModule &#125; = require(``&apos;@vue/cli-shared-utils&apos;``)` `const &#123; defaults, validate &#125; = require(``&apos;./options&apos;``)` `module.exports = class Service &#123;`` ``constructor (context, &#123; plugins, pkg, inlineOptions, useBuiltIn &#125; = &#123;&#125;) &#123;`` ``process.VUE_CLI_SERVICE = ``this`` ``this``.initialized = ``false`` ``// 一般是项目根目录路径。`` ``this``.context = context`` ``this``.inlineOptions = inlineOptions`` ``// webpack相关收集。不是本文重点。所以未列出该方法实现`` ``this``.webpackChainFns = []`` ``this``.webpackRawConfigFns = []`` ``this``.devServerConfigFns = []`` ``//存储的命令。`` ``this``.commands = &#123;&#125;`` ``// Folder containing the target package.json for plugins`` ``this``.pkgContext = context`` ``// 键值对存储的pakcage.json对象，不是本文重点。所以未列出该方法实现`` ``this``.pkg = ``this``.resolvePkg(pkg)`` ``// **这个方法下方需要重点阅读。**`` ``this``.plugins = ``this``.resolvePlugins(plugins, useBuiltIn)`` ` ` ``// 结果为&#123;build: production, serve: development, ... &#125;。大意是收集插件中的默认配置信息`` ``// 标注build命令主要用于生产环境。`` ``this``.modes = ``this``.plugins.reduce((modes, &#123; apply: &#123; defaultModes &#125;&#125;) =&gt; &#123;`` ``return` `Object.assign(modes, defaultModes)`` ``&#125;, &#123;&#125;)`` ``&#125;` ` ``init (mode = process.env.VUE_CLI_MODE) &#123;`` ``if` `(``this``.initialized) &#123;`` ``return`` ``&#125;`` ``this``.initialized = ``true`` ``this``.mode = mode` ` ``// 加载.env文件中的配置`` ``if` `(mode) &#123;`` ``this``.loadEnv(mode)`` ``&#125;`` ``// load base .env`` ``this``.loadEnv()` ` ``// 读取用户的配置信息.一般为vue.config.js`` ``const userOptions = ``this``.loadUserOptions()`` ``// 读取项目的配置信息并与用户的配置合并(用户的优先级高)`` ``this``.projectOptions = defaultsDeep(userOptions, defaults())` ` ``debug(``&apos;vue:project-config&apos;``)(``this``.projectOptions)` ` ``// 注册插件。`` ``this``.plugins.forEach((&#123; id, apply &#125;) =&gt; &#123;`` ``apply(``new` `PluginAPI(id, ``this``), ``this``.projectOptions)`` ``&#125;)` ` ``// wepback相关配置收集`` ``if` `(``this``.projectOptions.chainWebpack) &#123;`` ``this``.webpackChainFns.push(``this``.projectOptions.chainWebpack)`` ``&#125;`` ``if` `(``this``.projectOptions.configureWebpack) &#123;`` ``this``.webpackRawConfigFns.push(``this``.projectOptions.configureWebpack)`` ``&#125;`` ``&#125;` ` ``resolvePlugins (inlinePlugins, useBuiltIn) &#123;`` ``const idToPlugin = id =&gt; (&#123;`` ``id: id.replace(/^.\\``//, &apos;built-in:&apos;),`` ``apply: require(id)`` ``&#125;)` ` ``let plugins`` ` ` ` ` ``// 主要是这里。map得到的每个插件都是一个&#123;id, apply的形式&#125;`` ``// 其中require(id)将直接import每个插件的默认导出。`` ``// 每个插件的导出api为`` ``// module.exports = (PluginAPIInstance,projectOptions) =&gt; &#123;`` ``// PluginAPIInstance.registerCommand(&apos;cmdName（例如npm run serve中的serve）&apos;, args =&gt; &#123;`` ``// // 根据命令行收到的参数，执行该插件的业务逻辑`` ``// &#125;)`` ``// // 业务逻辑需要的其他函数`` ``//&#125;`` ``// 注意着里是先在构造函数中resolve了插件。然后再run-&gt;init-&gt;方法中将命令，通过这里的的apply方法，`` ``// 将插件对应的命令注册到了service实例。`` ``const builtInPlugins = [`` ``&apos;./commands/serve&apos;``,`` ``&apos;./commands/build&apos;``,`` ``&apos;./commands/inspect&apos;``,`` ``&apos;./commands/help&apos;``,`` ``// config plugins are order sensitive`` ``&apos;./config/base&apos;``,`` ``&apos;./config/css&apos;``,`` ``&apos;./config/dev&apos;``,`` ``&apos;./config/prod&apos;``,`` ``&apos;./config/app&apos;`` ``].map(idToPlugin)`` ` ` ``// inlinePlugins与非inline得处理。默认生成的项目直接运行时候，除了上述数组的插件[&apos;./commands/serve&apos;...]外，还会有`` ``// [&apos;@vue/cli-plugin-babel&apos;,&apos;@vue/cli-plugin-eslint&apos;,&apos;@vue/cli-service&apos;]。`` ``// 处理结果是两者的合并，细节省略。`` ``if` `(inlinePlugins) &#123;`` ``//...`` ``&#125; ``else` `&#123;`` ``//...默认走这条路线`` ``plugins = builtInPlugins.concat(projectPlugins)`` ``&#125;` ` ``// Local plugins 处理package.json中引入插件的形式，具体代码省略。` ` ``return` `plugins`` ``&#125;` ` ``async run (name, args = &#123;&#125;, rawArgv = []) &#123;`` ``// mode是dev还是prod？`` ``const mode = args.mode || (name === ``&apos;build&apos;` `&amp;&amp; args.watch ? ``&apos;development&apos;` `: ``this``.modes[name])` ` ``// 收集环境变量、插件、用户配置`` ``this``.init(mode)` ` ``args._ = args._ || []`` ``let command = ``this``.commands[name]`` ``if` `(!command &amp;&amp; name) &#123;`` ``error(`command ``&quot;$&#123;name&#125;&quot;` `does not exist.`)`` ``process.exit(1)`` ``&#125;`` ``if` `(!command || args.help) &#123;`` ``command = ``this``.commands.help`` ``&#125; ``else` `&#123;`` ``args._.shift() ``// remove command itself`` ``rawArgv.shift()`` ``&#125;`` ``// 执行命令。例如vue-cli-service serve 则，执行serve命令。`` ``const &#123; fn &#125; = command`` ``return` `fn(args, rawArgv)`` ``&#125;` ` ``// 收集vue.config.js中的用户配置。并以对象形式返回。`` ``loadUserOptions () &#123;`` ``// 此处代码省略，可以简单理解为`` ``// require(vue.config.js)`` ``return` `resolved`` ``&#125;``&#125;` PluginAPI 这里主要是连接了plugin的注册和service实例。抽象过的代码如下 1`class PluginAPI &#123;` ` ``constructor (id, service) &#123;`` ``this``.id = id`` ``this``.service = service`` ``&#125;`` ``// 在service的init方法中`` ``// 该函数会被调用，调用处如下。`` ``// // apply plugins.`` ``// 这里的apply就是插件暴露出来的函数。该函数将PluginAPI实例和项目配置信息(例如vue.config.js)作为参数传入`` ``// 通过PluginAPIInstance.registerCommand方法，将命令注册到service实例。`` ``// this.plugins.forEach((&#123; id, apply &#125;) =&gt; &#123;`` ``// apply(new PluginAPI(id, this), this.projectOptions)`` ``// &#125;)`` ``registerCommand (name, opts, fn) &#123;`` ``if` `(``typeof` `opts === ``&apos;function&apos;``) &#123;`` ``fn = opts`` ``opts = ``null`` ``&#125;`` ``this``.service.commands[name] = &#123; fn, opts: opts || &#123;&#125;&#125;`` ``&#125;` `&#125;` `module.exports = PluginAPI` 总结 通过vue-cli-service中的new Service，加载插件信息，缓存到Service实例的plugins变量中。 当得到命令行参数后，在通过new Service的run方法，执行命令。 该run方法中调用了init方法获取到项目中的配置信息（默认&amp;用户的合并）,例如用户的配置在vue.config.js中。 init过程中通过pluginAPI这个类，将service和插件plugins建立关联。关系存放到service.commands中。最后通过commands[cmdArgName]调用该方法，完成了插件方法的调用。 初次阅读，只是看到了命令模式的实际应用。能想到的好就是，新增加一个插件的时候，只需要增加一个插件的文件，并不需要更改其他文件的逻辑。","categories":[{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/categories/vue/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/tags/vue/"}],"author":"along"},{"title":"vue undefined 0","slug":"vue undefined 0","date":"2019-05-28T16:00:00.000Z","updated":"2019-10-28T07:51:52.345Z","comments":true,"path":"2019/05/29/vue undefined 0/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/05/29/vue undefined 0/","excerpt":"","text":"报错: “Error in render: “TypeError: Cannot read property ‘0’ of undefined” 代码: 1&lt;img :src=&quot;imgBaseUrl + model.image1[0].substring(1, model.image1[0].length - 1)&quot; /&gt; 解决: 1234updated() &#123; console.log(&apos;this.model&apos;, this.model); this.imgMainUrl = this.imgBaseUrl + this.model.image1[0].substring(1, this.model.image1[0].length - 1); &#125;","categories":[{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/categories/vue/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/tags/vue/"}],"author":"along"},{"title":"vue uncaught SyntaxError","slug":"vue uncaught SyntaxError","date":"2019-05-23T16:00:00.000Z","updated":"2019-10-28T07:50:40.365Z","comments":true,"path":"2019/05/24/vue uncaught SyntaxError/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/05/24/vue uncaught SyntaxError/","excerpt":"","text":"vue项目 报Uncaught SyntaxError: Unexpected token &lt; 错误，一般是路径有问题（这里说是当js引用的文件是项目路径下的文件夹时,会报这个错误）。当时出现这个问题 是因为求助我的人他用了CDN 导致 (缓存) 访问了不存在的js，然后这个404错误又重新指向了一个提示的自定义页面，由于脚本里面不允许出现标签因为标签带了&lt;&gt;符号，所以，就会抛出这个异常 从而报错。 今天 发现一篇文章—Nginx解决VUE的history模式下刷新404报错介绍 说nginx配置与代码静态资源打包方式不匹配 也会导致这样的错误 20190517更新 检索资料无意发现 &lt;scrpit src=&#39;./XXX/XXX/jquery.toggle.button.html&#39; type=&#39;text/javascripnt&#39;/&gt; 这种在script中src引入html文件也会这样报错。 Uncaught SyntaxError: Unexpected token &lt;反思 自己解决的方案: 将public的css,放入asset中,并在mian.js中用import引用,","categories":[{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/categories/vue/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/tags/vue/"}],"author":"along"},{"title":"vue LF 电脑卡死","slug":"vue LF 电脑卡死","date":"2019-05-20T16:00:00.000Z","updated":"2019-10-28T07:49:55.616Z","comments":true,"path":"2019/05/21/vue LF 电脑卡死/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/05/21/vue LF 电脑卡死/","excerpt":"","text":"原因:eslint检测,大量CRLF,导致卡死; 解决: vue项目下.eslint.js rule添加: ‘linebreak-style’: ‘off’,","categories":[{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/categories/vue/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/tags/vue/"}],"author":"along"},{"title":"vue build 报错","slug":"vue build 报错","date":"2019-05-18T16:00:00.000Z","updated":"2019-10-28T07:48:20.273Z","comments":true,"path":"2019/05/19/vue build 报错/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/05/19/vue build 报错/","excerpt":"","text":"Vue中npm run build报“Error in parsing SVG: Unquoted attribute value”0.1332018.12.23 21:14:08字数 318阅读 716 自己做的一个Vue项目，在打包时老是报这个错误 1# Error in parsing SVG: Unquoted attribute value 查了查网上说的，都说报错原因是压缩和抽离CSS的插件中只允许 SVG 使用双引号 就是项目中外部引入的CSS文件里的SVG只能是双引号 我找了好久，这可把我坑坏了。。。 想想那段时间真是难受。。。 后来我找到了，分享一下，让大家快点脱坑。。。 首先，如果你项目中使用了mui的话应该在这里改 找到mui文件下的iconfont.css文件 1# mui/css/iconfont.css one.png 不要以为完了，还有 找到mui文件下的mui.css文件 1# mui/css/mui.css two.png 以上两个文件修改了再次build 如果还报SVG的错误，请查看你所有引入的外部CSS文件吧 如果你确定你引入的CSS文件中确实没有SVG或者是SVG确实是双引号，那就没办法了老兄。。。 最后：喜欢前端，欢迎探讨！！！","categories":[{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/categories/vue/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/tags/vue/"}],"author":"along"},{"title":"vue $set的使用环境","slug":"vue $set的使用环境","date":"2019-05-16T16:00:00.000Z","updated":"2019-10-28T07:47:50.093Z","comments":true,"path":"2019/05/17/vue $set的使用环境/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/05/17/vue $set的使用环境/","excerpt":"","text":"由于 JavaScript 的限制，Vue 不能检测以下数组的变动： 当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue 当你修改数组的长度时，例如：vm.items.length = newLength 举个例子： 1234567var vm = new Vue(&#123; data: &#123; items: [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] &#125;&#125;)vm.items[1] = &apos;x&apos; // 不是响应性的vm.items.length = 2 // 不是响应性的 为了解决第一类问题，以下两种方式都可以实现和 vm.items[indexOfItem] = newValue 相同的效果，同时也将在响应式系统内触发状态更新： 1234// Vue.setVue.set(vm.items, indexOfItem, newValue)// Array.prototype.splicevm.items.splice(indexOfItem, 1, newValue) 你也可以使用 vm.$set 实例方法，该方法是全局方法 Vue.set 的一个别名： 1vm.$set(vm.items, indexOfItem, newValue) 为了解决第二类问题，你可以使用 splice： 1vm.items.splice(newLength) 对象变更检测注意事项还是由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除： 123456789var vm = new Vue(&#123; data: &#123; a: 1 &#125;&#125;)// `vm.a` 现在是响应式的vm.b = 2// `vm.b` 不是响应式的 对于已经创建的实例，Vue 不允许动态添加根级别的响应式属性。但是，可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式属性。例如，对于： 1234567var vm = new Vue(&#123; data: &#123; userProfile: &#123; name: &apos;Anika&apos; &#125; &#125;&#125;) 你可以添加一个新的 age 属性到嵌套的 userProfile 对象： 1Vue.set(vm.userProfile, &apos;age&apos;, 27) 你还可以使用 vm.$set 实例方法，它只是全局 Vue.set 的别名： 1vm.$set(vm.userProfile, &apos;age&apos;, 27) 有时你可能需要为已有对象赋值多个新属性，比如使用 Object.assign() 或 _.extend()。在这种情况下，你应该用两个对象的属性创建一个新的对象。所以，如果你想添加新的响应式属性，不要像这样： 1234Object.assign(vm.userProfile, &#123; age: 27, favoriteColor: &apos;Vue Green&apos;&#125;) 你应该这样做： 1234vm.userProfile = Object.assign(&#123;&#125;, vm.userProfile, &#123; age: 27, favoriteColor: &apos;Vue Green&apos;&#125;) ##","categories":[{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/categories/vue/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/tags/vue/"}],"author":"along"},{"title":"vue 列表渲染后调用","slug":"vue 列表渲染后调用","date":"2019-05-14T16:00:00.000Z","updated":"2019-10-28T07:47:00.840Z","comments":true,"path":"2019/05/15/vue 列表渲染后调用/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/05/15/vue 列表渲染后调用/","excerpt":"","text":"在使用Vue框架的时候，有时候需要在Vue在页面数据渲染完成之后调用方法，不然获取不到准确的数据，特别是在获取列表的高度的时候，由于数据没有加载完，获取不到准确的高度。之前在使用jquery的时候，有ready可以帮助我们实现，但是Vue不存在此类方法，我们需要结合watch和this.$nextTick()来实现。 nextTick：在下次 DOM 更新循环结束之后执行延迟回调。 watch：用于观察Vue实例上的数据变动。对应一个对象,键是观察表达式,值是对应回调。 之前我是这样子使用nextTick的： 1`mounted:&#123;` `this``.$nextTick(``function``()&#123;` `/////方法` `&#125;)` `&#125;` 经测试发现实现不了所需要的效果，只有结构，没有数据，即获取不到想要的高度 后发现需要结合watch监听某个属性： 1`watch:&#123;` `asyncArray:``function``()` ` ``this``.$nextTick(``function``()&#123;`` ``//////方法`` ``&#125;);``&#125;``&#125;` 另外在做项目发现也可以: 12","categories":[{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/categories/vue/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/tags/vue/"}],"author":"along"},{"title":"vue父子传值","slug":"vue 父子传值 子组件监听父组件","date":"2019-05-12T16:00:00.000Z","updated":"2019-10-28T07:45:55.542Z","comments":true,"path":"2019/05/13/vue 父子传值 子组件监听父组件/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/05/13/vue 父子传值 子组件监听父组件/","excerpt":"","text":"什么时候使用它？ 我们都知道，当父组件向子组件传值时，子组件通过props 可以接收到父组件传过来的值但这样只能接收父组件的静态值：比如以下代码:下边是个数字框组件展示这个问题:父组件 12345678910111213141516171819&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;one v-model=&quot;value&quot; :max=&apos;10&apos; :min=&quot;0&quot;&gt;&lt;/one&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import one from &apos;./components/one&apos;export default &#123; components:&#123; one &#125;, data()&#123; return&#123; value:5 &#125; &#125;&#125;&lt;/script&gt;子组件 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div class=&quot;three&quot;&gt; &#123;&#123;currentValue&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props:&#123; max:&#123; type:Number, default:Infinity &#125;, min:&#123; type:Number, default:-Infinity &#125;, value:&#123; type:Number, default:0 &#125; &#125;, data()&#123; return&#123; currentValue:this.value &#125; &#125;&#125;;&lt;/script&gt; 以上父子组件，当你手动改变父组件中的 value 值得时候，在子组件都能立马展示出来，且数据立马会更新出来！但实际开发中我们的数据都是动态传给子组件的， 接着你就会发现一个问题来，当我们传一个动态的数据时，发现子组件的数据竟然没有变化？ 怎么解决呢，这时候就要用到vue的$watch了贴个代码演示 动态数据 传入子组件中 子组件的数据不会改变 在刚才的父组件中加入一个点击事件，我们让这个数字每次点击+1 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;one v-model=&quot;value&quot; :max=&apos;10&apos; :min=&quot;0&quot;&gt;&lt;/one&gt; &lt;button @click=&quot;addvalue&quot;&gt;+&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import one from &apos;./components/one&apos;export default &#123; components:&#123; one &#125;, data()&#123; return&#123; value:5 &#125; &#125;, methods:&#123; addvalue()&#123; //每次点击数据都加了1 this.value++ &#125; &#125;&#125;&lt;/script&gt;子组件不变 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div class=&quot;three&quot;&gt; &#123;&#123;currentValue&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props:&#123; max:&#123; type:Number, default:Infinity &#125;, min:&#123; type:Number, default:-Infinity &#125;, value:&#123; type:Number, default:0 &#125; &#125;, data()&#123; return&#123; currentValue:this.value &#125; &#125;&#125;;&lt;/script&gt; 完整代码 ，数据改变 watch监听 （一个数字框输入框组件）1父组件 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;one v-model=&quot;value&quot; :max=&apos;10&apos; :min=&quot;0&quot;&gt;&lt;/one&gt; &lt;br&gt; &#123;&#123; value &#125;&#125; &lt;br&gt; &lt;button @click=&quot;addvalue&quot;&gt;+&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import one from &apos;./components/one&apos;export default &#123; components:&#123; one &#125;, data()&#123; return&#123; value:5 &#125; &#125;, methods:&#123; addvalue()&#123; this.value++ &#125; &#125;&#125;&lt;/script&gt; 子组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;template&gt; &lt;div class=&quot;three&quot;&gt; &lt;!-- &#123;&#123;currentValue&#125;&#125;z --&gt; &lt;input type=&quot;text&quot; :value=&quot;currentValue&quot; @change=&quot;handelChange&quot;&gt; &lt;button @click=&quot;handelDown&quot; :disabled=&quot;currentValue &lt;= min&quot;&gt;-&lt;/button&gt; &lt;button @click=&quot;handelUp&quot; &gt;+&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 判断是不是数字function isValueNumber(value)&#123; return (/(^-?[0-9]+\\.&#123;1&#125;\\d+$)|(^-?[1-9][0-9]*$)|(^-?0&#123;1&#125;$)/).test(value +&apos;&apos;)&#125;export default &#123; props:&#123; max:&#123; type:Number, default:Infinity &#125;, min:&#123; type:Number, default:-Infinity &#125;, value:&#123; type:Number, default:0 &#125; &#125;, data()&#123; return&#123; currentValue:this.value &#125; &#125;, // 加入 watch 监听数据变化 watch:&#123; // 接收两个参数 第一个是改变后的新值newvalue,第二个是老值oldvalue， // 只写一个，默认是新值 value(val)&#123; // 这样重新赋值后，就得到了父组件动态改变的数据 this.currentValue = val &#125;, // 实际业务中，当子组件值改变时，有时候也会通知父组件，这时我们也要监听子组件的数据变化 currentValue(val)&#123; this.$emit(&apos;input&apos;,val) &#125; &#125;, mounted () &#123; this.updataValue(this.value) &#125;, methods:&#123; // 点击-1时，得到更新的值，告诉父组件 handelDown()&#123; if(this.currentValue &lt;= this.min) return; this.currentValue -=1; &#125;, // 点击+1 ，得到更新后的值告诉父组件 handelUp()&#123; if(this.currentValue &gt;= this.max) return; this.currentValue +=1; &#125;, updataValue(val){ if(val &gt; this.max) val = this.max if(val &lt;this.min) val = min this.currentValue = val }, // 失去焦点时，得到更新后的值 handelChange(){ let val = event.target.value.trim(); console.log(val) let max = this.max; let min = this.min; if(isValueNumber(val)){ val = Number(val) this.currentValue = val if(val &gt; max){ this.currentValue = max }else if(val &lt; min){ this.currentValue = min }else{ event.target.value = min } }else{ event.target.value = this.currentValue } } } }; &lt;/script&gt;","categories":[{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/categories/vue/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/tags/vue/"}],"author":"along"},{"title":"同源策略","slug":"同源策略","date":"2019-05-09T16:00:00.000Z","updated":"2019-06-28T13:18:32.968Z","comments":true,"path":"2019/05/10/同源策略/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/05/10/同源策略/","excerpt":"","text":"浏览器同源政策及其规避方法一、概述1.1 含义1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。 最初，它的含义是指，A网页设置的 Cookie，B网页不能打开，除非这两个网页”同源”。所谓”同源”指的是”三个相同”。 协议相同 域名相同 端口相同 举例来说，http://www.example.com/dir/page.html这个网址，协议是http://，域名是www.example.com，端口是80（默认端口可以省略）。它的同源情况如下。 http://www.example.com/dir2/other.html：同源 http://example.com/dir/other.html：不同源（域名不同） http://v2.www.example.com/dir/other.html：不同源（域名不同） http://www.example.com:81/dir/other.html：不同源（端口不同） 1.2 目的同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。 设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 Cookie，会发生什么？ 很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。 由此可见，”同源政策”是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。 1.3 限制范围随着互联网的发展，”同源政策”越来越严格。目前，如果非同源，共有三种行为受到限制。 （1） Cookie、LocalStorage 和 IndexDB 无法读取。 （2） DOM 无法获得。 （3） AJAX 请求不能发送。 虽然这些限制是必要的，但是有时很不方便，合理的用途也受到影响。下面，我将详细介绍，如何规避上面三种限制。 二、CookieCookie 是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置document.domain共享 Cookie。 举例来说，A网页是http://w1.example.com/a.html，B网页是http://w2.example.com/b.html，那么只要设置相同的document.domain，两个网页就可以共享Cookie。 12&gt; document.domain = 'example.com';&gt; 现在，A网页通过脚本设置一个 Cookie。 12&gt; document.cookie = \"test1=hello\";&gt; B网页就可以读到这个 Cookie。 12&gt; var allCookie = document.cookie;&gt; 注意，这种方法只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexDB 无法通过这种方法，规避同源政策，而要使用下文介绍的PostMessage API。 另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如.example.com。 12&gt; Set-Cookie: key=value; domain=.example.com; path=/&gt; 这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie。 三、iframe如果两个网页不同源，就无法拿到对方的DOM。典型的例子是iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信。 比如，父窗口运行下面的命令，如果iframe窗口不是同源，就会报错。 123&gt; document.getElementById(\"myIFrame\").contentWindow.document&gt; // Uncaught DOMException: Blocked a frame from accessing a cross-origin frame.&gt; 上面命令中，父窗口想获取子窗口的DOM，因为跨源导致报错。 反之亦然，子窗口获取主窗口的DOM也会报错。 123&gt; window.parent.document.body&gt; // 报错&gt; 如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的document.domain属性，就可以规避同源政策，拿到DOM。 对于完全不同源的网站，目前有三种方法，可以解决跨域窗口的通信问题。 片段识别符（fragment identifier） window.name 跨文档通信API（Cross-document messaging） 3.1 片段识别符片段标识符（fragment identifier）指的是，URL的#号后面的部分，比如http://example.com/x.html#fragment的#fragment。如果只是改变片段标识符，页面不会重新刷新。 父窗口可以把信息，写入子窗口的片段标识符。 123&gt; var src = originURL + '#' + data;&gt; document.getElementById('myIFrame').src = src;&gt; 子窗口通过监听hashchange事件得到通知。 1234567&gt; window.onhashchange = checkMessage;&gt; &gt; function checkMessage() &#123;&gt; var message = window.location.hash;&gt; // ...&gt; &#125;&gt; 同样的，子窗口也可以改变父窗口的片段标识符。 12&gt; parent.location.href= target + \"#\" + hash;&gt; 3.2 window.name浏览器窗口有window.name属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。 父窗口先打开一个子窗口，载入一个不同源的网页，该网页将信息写入window.name属性。 12&gt; window.name = data;&gt; 接着，子窗口跳回一个与主窗口同域的网址。 12&gt; location = 'http://parent.url.com/xxx.html';&gt; 然后，主窗口就可以读取子窗口的window.name了。 12&gt; var data = document.getElementById('myFrame').contentWindow.name;&gt; 这种方法的优点是，window.name容量很大，可以放置非常长的字符串；缺点是必须监听子窗口window.name属性的变化，影响网页性能。 3.3 window.postMessage上面两种方法都属于破解，HTML5为了解决这个问题，引入了一个全新的API：跨文档通信 API（Cross-document messaging）。 这个API为window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。 举例来说，父窗口http://aaa.com向子窗口http://bbb.com发消息，调用postMessage方法就可以了。 123&gt; var popup = window.open('http://bbb.com', 'title');&gt; popup.postMessage('Hello World!', 'http://bbb.com');&gt; postMessage方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即”协议 + 域名 + 端口”。也可以设为*，表示不限制域名，向所有窗口发送。 子窗口向父窗口发送消息的写法类似。 12&gt; window.opener.postMessage('Nice to see you', 'http://aaa.com');&gt; 父窗口和子窗口都可以通过message事件，监听对方的消息。 1234&gt; window.addEventListener('message', function(e) &#123;&gt; console.log(e.data);&gt; &#125;,false);&gt; message事件的事件对象event，提供以下三个属性。 event.source：发送消息的窗口 event.origin: 消息发向的网址 event.data: 消息内容 下面的例子是，子窗口通过event.source属性引用父窗口，然后发送消息。 12345&gt; window.addEventListener('message', receiveMessage);&gt; function receiveMessage(event) &#123;&gt; event.source.postMessage('Nice to see you!', '*');&gt; &#125;&gt; event.origin属性可以过滤不是发给本窗口的消息。 12345678910&gt; window.addEventListener('message', receiveMessage);&gt; function receiveMessage(event) &#123;&gt; if (event.origin !== 'http://aaa.com') return;&gt; if (event.data === 'Hello World') &#123;&gt; event.source.postMessage('Hello', event.origin);&gt; &#125; else &#123;&gt; console.log(event.data);&gt; &#125;&gt; &#125;&gt; 3.4 LocalStorage通过window.postMessage，读写其他窗口的 LocalStorage 也成为了可能。 下面是一个例子，主窗口写入iframe子窗口的localStorage。 12345678&gt; window.onmessage = function(e) &#123;&gt; if (e.origin !== 'http://bbb.com') &#123;&gt; return;&gt; &#125;&gt; var payload = JSON.parse(e.data);&gt; localStorage.setItem(payload.key, JSON.stringify(payload.data));&gt; &#125;;&gt; 上面代码中，子窗口将父窗口发来的消息，写入自己的LocalStorage。 父窗口发送消息的代码如下。 1234&gt; var win = document.getElementsByTagName('iframe')[0].contentWindow;&gt; var obj = &#123; name: 'Jack' &#125;;&gt; win.postMessage(JSON.stringify(&#123;key: 'storage', data: obj&#125;), 'http://bbb.com');&gt; 加强版的子窗口接收消息的代码如下。 123456789101112131415161718&gt; window.onmessage = function(e) &#123;&gt; if (e.origin !== 'http://bbb.com') return;&gt; var payload = JSON.parse(e.data);&gt; switch (payload.method) &#123;&gt; case 'set':&gt; localStorage.setItem(payload.key, JSON.stringify(payload.data));&gt; break;&gt; case 'get':&gt; var parent = window.parent;&gt; var data = localStorage.getItem(payload.key);&gt; parent.postMessage(data, 'http://aaa.com');&gt; break;&gt; case 'remove':&gt; localStorage.removeItem(payload.key);&gt; break;&gt; &#125;&gt; &#125;;&gt; 加强版的父窗口发送消息代码如下。 123456789101112&gt; var win = document.getElementsByTagName('iframe')[0].contentWindow;&gt; var obj = &#123; name: 'Jack' &#125;;&gt; // 存入对象&gt; win.postMessage(JSON.stringify(&#123;key: 'storage', method: 'set', data: obj&#125;), 'http://bbb.com');&gt; // 读取对象&gt; win.postMessage(JSON.stringify(&#123;key: 'storage', method: \"get\"&#125;), \"*\");&gt; window.onmessage = function(e) &#123;&gt; if (e.origin != 'http://aaa.com') return;&gt; // \"Jack\"&gt; console.log(JSON.parse(e.data).name);&gt; &#125;;&gt; 四、AJAX同源政策规定，AJAX请求只能发给同源的网址，否则就报错。 除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。 JSONP WebSocket CORS 4.1 JSONPJSONP是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。 它的基本思想是，网页通过添加一个&lt;script&gt;元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。 首先，网页动态插入&lt;script&gt;元素，由它向跨源网址发出请求。 123456789101112131415&gt; function addScriptTag(src) &#123;&gt; var script = document.createElement('script');&gt; script.setAttribute(\"type\",\"text/javascript\");&gt; script.src = src;&gt; document.body.appendChild(script);&gt; &#125;&gt; &gt; window.onload = function () &#123;&gt; addScriptTag('http://example.com/ip?callback=foo');&gt; &#125;&gt; &gt; function foo(data) &#123;&gt; console.log('Your public IP address is: ' + data.ip);&gt; &#125;;&gt; 上面代码通过动态添加&lt;script&gt;元素，向服务器example.com发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。 服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。 1234&gt; foo(&#123;&gt; \"ip\": \"8.8.8.8\"&gt; &#125;);&gt; 由于&lt;script&gt;元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。 4.2 WebSocketWebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。 下面是一个例子，浏览器发出的WebSocket请求的头信息（摘自维基百科）。 123456789&gt; GET /chat HTTP/1.1&gt; Host: server.example.com&gt; Upgrade: websocket&gt; Connection: Upgrade&gt; Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==&gt; Sec-WebSocket-Protocol: chat, superchat&gt; Sec-WebSocket-Version: 13&gt; Origin: http://example.com&gt; 上面代码中，有一个字段是Origin，表示该请求的请求源（origin），即发自哪个域名。 正是因为有了Origin这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。 123456&gt; HTTP/1.1 101 Switching Protocols&gt; Upgrade: websocket&gt; Connection: Upgrade&gt; Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=&gt; Sec-WebSocket-Protocol: chat&gt; 4.3 CORSCORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨源AJAX请求的根本解决方法。相比JSONP只能发GET请求，CORS允许任何类型的请求。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"}],"author":"along"},{"title":"我的vscode插件","slug":"我的vscode插件","date":"2019-05-01T16:00:00.000Z","updated":"2019-06-19T15:44:08.297Z","comments":true,"path":"2019/05/02/我的vscode插件/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/05/02/我的vscode插件/","excerpt":"","text":"通用插件HTML Snippets超级实用且初级的 H5代码片段以及提示 HTML CSS Support让 html 标签上写class 智能提示当前项目所支持的样式新版已经支持scss文件检索 Debugger for Chrome让 vscode 映射 chrome 的 debug功能，静态页面都可以用 vscode 来打断点调试，配置稍微复杂一些 jQuery Code Snippetsjquery 重度患者必须品，废话不多说，上图 vscode-icon让 vscode 资源树目录加上图标，必备良品！ Path Intellisense自动路劲补全， Npm Intellisenserequire 时的包提示（最新版的vscode已经集成此功能） Document thisjs 的注释模板 （注意：新版的vscode已经原生支持,在function上输入/** tab） ESlintESlint 接管原生 js 提示，可以自定制提示规则。 HTMLHinthtml代码检测 Project Manager在多个项目之前快速切换的工具 beautify格式化代码的工具 Bootstrap 3 Sinnpet常用 bootstrap 的可以下 Atuo Rename Tag修改 html 标签，自动帮你完成尾部闭合标签的同步修改，不过有些bug。 GitLens丰富的git日志插件 fileheader顶部注释模板，可定义作者、时间等信息，并会自动更新最后修改时间 filesize在底部状态栏显示当前文件大小，点击后还可以看到详细创建、修改时间 Bracket Pair Colorizer让括号拥有独立的颜色，易于区分。可以配合任意主题使用。 Vue插件以下推荐vue框架所需的插件 vetur语法高亮、智能感知、Emmet等 VueHelpersnippet代码片段 Import Cost引入包大小计算,对于项目打包后体积掌握很有帮助","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/tags/vue/"}],"author":"along"},{"title":"vue的一些坑","slug":"vue的一些坑","date":"2019-05-01T16:00:00.000Z","updated":"2019-10-28T07:40:20.728Z","comments":true,"path":"2019/05/02/vue的一些坑/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/05/02/vue的一些坑/","excerpt":"","text":"记录vue 的一些坑1.给link添加事件、给组件绑定原生事件在vue-router1中使用v-link写入路由，但是在vue-router2中要使用router-link写入路由，在浏览器渲染的时候会把router-link渲染成a。 有时候需要为router-link注册事件，对于一般的html元素，直接使用@click=”eventFun”即可，但是对于router-link，像普通html元素那样注册事件后并不管用，需要添加.native才会成功注册。 事实上给组件绑定原生事件就需要.native修饰v-on，否则无法注册成功。 1&lt;my-component v-on:click.native=&quot;doTheThing&quot;&gt;&lt;/my-component&gt; 错误事例： 12345&lt;el-inputplaceholder=&quot;请输入特定消费金额 &quot; @mouseover=&quot;test()&quot;&gt;&lt;/el-input&gt;&lt;router-link:to=&quot;item.menuUrl&quot; @click=&quot;toggleName=&apos;&apos;&quot;&gt;&lt;/router-link&gt;&lt;!--官方文档有-&gt;&lt;!--https://cn.vuejs.org/v2/guide/components.html#给组件绑定原生事件--&gt; 2.修改prop中的数据每次父组件更新时，子组件的所有 prop 都会更新为最新值。这意味着你不应该在子组件内部改变 prop。如果你这么做了，Vue 会在控制台给出警告。 在两种情况下，我们很容易忍不住想去修改 prop 中数据：Prop 作为初始值传入后，子组件想把它当作局部数据来用；Prop 作为原始数据传入，由子组件处理成其它数据输出。 对这两种情况，正确的应对方式是： 定义一个局部变量，并用 prop 的值初始化它： 1234props: [&apos;initialCounter&apos;],data: function () &#123;return &#123; counter: this.initialCounter &#125;&#125; 定义一个计算属性，处理 prop 的值并返回： 123456props: [&apos;size&apos;],computed: &#123;normalizedSize: function () &#123;return this.size.trim().toLowerCase()&#125;&#125; 3.我需要遍历的数组值更新了,值也赋值了,为什么视图不更新？因为有局限性啊,官方文档也说的很清楚，一般我们常用的手段是使用:this.$set(obj,item,value) 官方文档如下： 由于 JavaScript 的限制，Vue 不能检测以下变动的数组： 当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue当你修改数组的长度时，例如：vm.items.length = newLength为了解决第一类问题，以下两种方式都可以实现和 vm.items[indexOfItem] = newValue 相同的效果，同时也将触发状态更新： // Vue.setVue.set(example1.items, indexOfItem, newValue)// Array.prototype.spliceexample1.items.splice(indexOfItem, 1, newValue)为了解决第二类问题，你可以使用 splice：example1.items.splice(newLength) 还是由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除，对于已经创建的实例，Vue 不能动态添加根级别的响应式属性。 但是，可以使用 Vue.set(object, key, value) 方法向嵌套对象添加响应式属性。例如，对于： 1234567var vm = new Vue(&#123;data: &#123;userProfile: &#123;name: &apos;Anika&apos;&#125;&#125;&#125;) 你可以添加一个新的 age 属性到嵌套的 userProfile 对象： Vue.set(vm.userProfile, ‘age’, 27)有时你可能需要为已有对象赋予多个新属性，比如使用 Object.assign() 或 _.extend()。在这种情况下，你应该用两个对象的属性创建一个新的对象。所以，如果你想添加新的响应式属性，不要像这样： 123456789Object.assign(this.userProfile, &#123;age: 27,favoriteColor: &apos;Vue Green&apos;&#125;)你应该这样做：this.userProfile = Object.assign(&#123;&#125;, this.userProfile, &#123;age: 27,favoriteColor: &apos;Vue Green&apos;&#125;) 4.建议尽可能在使用 v-for 时提供 key123&lt;div v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;&lt;!-- 内容 --&gt;&lt;/div&gt; 它是 Vue 识别节点的一个通用机制，key 并不与 v-for 特别关联，key 还具有其他用途，我们将在后面的指南中看到其他用途，后续补充（2.2.0+ 的版本里，当在组件中使用 v-for 时，key 现在是必须的。） 5.路由模式改为history后,除了首次启动首页没报错,刷新访问路由都报错必须给对应的服务端配置查询的主页面..也可以认为是主路由入口的引导。。。Vue-Router官方文档链接 （https://router.vuejs.org/zh-cn/essentials/history-mode.html）包括动态路由匹配、向路由组件传递props等基础知识 6.Uncaught ReferenceError: xxx is not define实例内的 data 对应的变量没有声明你导入模块报这个错误,那绝逼是导出没写好 7.Error in render function:”Type Error: Cannot read property ‘xxx’ of undefined”这种问题大多都是初始化的姿势不对;比如引入echart这些…仔细去了解下生命周期,再来具体初始化;vue 组件有时候也会(嵌套组件或者 props传递初始化)..也是基本这个问题 8.Failed to mount component: template or render function not defined组件挂载失败,问题只有这么几个组件没有正确引入; 挂载点顺序错了了;自行动手排查 9.[Vue warn]: Error in render function: “TypeError: Cannot read property ‘0’ of undefined”想将seller传递给子组件使用，但是我们ajax获取数据是异步过程，也就是说一开始在初始化seller时是空对象，所以把此时的seller传给header就是undefined 使用v-if可以解决报错问题，和created为空问题 【详解vue2父组件传递props异步数据到子组件的问题】【http://www.jb51.net/article/117447.htm】 10.vue-cli 新建项目 缺少dev-server.js和dev-client.js , 怎么模拟数据在使用vue开发过程中，难免需要去本地数据地址进行请求，而原版配置在dev-server.js中，新版vue-webpack-template已经删除dev-server.js，改用webpack.dev.conf.js代替，所以 配置本地访问在webpack.dev.conf.js里配置即可。 12345678910111213141516171819202122232425262728293031323334//首先const express = require(&apos;express&apos;)const app = express()var appData = require(&apos;../data.json&apos;)var seller = appData.sellervar goods = appData.goodsvar ratings = appData.ratingsvar apiRoutes = express.Router()app.use(&apos;/api&apos;, apiRoutes)//找到devServer,添加before(app) &#123; app.get(&apos;/api/seller&apos;, (req, res) =&gt; &#123; res.json(&#123; // 这里是你的json内容 errno: 0, data: seller &#125;) &#125;), app.get(&apos;/api/goods&apos;, (req, res) =&gt; &#123; res.json(&#123; // 这里是你的json内容 errno: 0, data: goods &#125;) &#125;), app.get(&apos;/api/ratings&apos;, (req, res) =&gt; &#123; res.json(&#123; // 这里是你的json内容 errno: 0, data: ratings &#125;) &#125;)&#125; 11.[WDS] Errors while compiling. Reload prevented.有一种错误的原因是import的路径不对 import header from ‘@views/header/header.vue’ 12.应当避免在模板或计算属性中使用 $refs$refs 只在组件渲染完成后才填充，并且它是非响应式的。它仅仅是一个直接操作子组件的应急方案——应当避免在模板或计算属性中使用 $refs","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/tags/vue/"}],"author":"along"},{"title":"vue初识","slug":"vue初识","date":"2019-04-30T16:00:00.000Z","updated":"2019-06-17T15:42:48.896Z","comments":true,"path":"2019/05/01/vue初识/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/05/01/vue初识/","excerpt":"","text":"相关概念混合开发和前后端分离 混合开发(服务器端渲染) 前后端分离 后端提供接口，前端开发界面效果(专注于用户的交互) 库和框架 库 库提供大量API，需要自己调用这些API简化开发。 框架 框架提供了一些基础服务，一般不需要自己调用，会自动完成一些基本功能。 什么是Vue什么是Vue 一款非常优秀的前端 JavaScript 框架，由尤雨溪创建开发 可以轻松构建单页 (SPA) 应用程序 通过 指令 扩展了 HTML，通过 表达式 绑定数据到 HTML 最大程度上解放了 DOM 操作 它能让你更加的享受编程的乐趣 数据驱动，开源 官网 Vue的特点 简单易用 灵活渐进式 轻量高效 虚拟 DOM MVVM 组件化 Vue初体验安装Vue下载Vue Vue.js 不支持 IE8 及其以下版本 最新稳定版本：2.5.16 直接下载 开发版本：https://vuejs.org/js/vue.js 生产版本：https://vuejs.org/js/vue.min.js CDN 1&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js&quot;&gt;&lt;/script&gt; 使用 npm下载（默认安装最新稳定版） 1npm install vue Hello World通过数据绑定的方式，在界面上展示Hello World 123456789101112&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; msg: &apos;Hello World&apos; &#125; &#125;);&lt;/script&gt; Vue实例创建Vue实例每一个Vue应用都是通过Vue构造函数创建一个Vue的实例开始 123var vm = new Vue(&#123; // Vue的选项&#125;); Vue的选项 el 选项：指定Vue作用的范围 data 选项：data提供数据对象，绑定的数据 模板语法Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML ，所以能被遵循规范的浏览器和 HTML 解析器解析。 插值表达式数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值： 123&lt;h1&gt; &#123;&#123; msg &#125;&#125;&lt;/h1&gt; JavaScript表达式对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。 123456789&#123;&#123; number + 1 &#125;&#125;&#123;&#123; age &gt; 18 ? &apos;年满18岁&apos; : &apos;未满18岁&apos; &#125;&#125;&#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;&lt;h1&gt; &#123;&#123; msg &#125;&#125;&lt;/h1&gt; 注意：差值表达式中不能写语句。例如：var a = 10; 指令指令 (Directives) 是带有 v- 前缀的特殊特性。指令特性的值预期是单个 JavaScript 表达式(v-for 是例外情况，稍后我们再讨论)。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。参考文档 v-html/v-text v-text v-text和差值表达式的区别 v-text 标签的指令更新整个标签中的内容 差值表达式，可以更新标签中局部的内容 v-html 可以渲染内容中的HTML标签 尽量避免使用，否则会带来危险(XSS攻击 跨站脚本攻击) v-bind可以绑定标签上的任何属性。 动态绑定图片的路径 123456789&lt;img v-bind:src=&quot;src&quot; /&gt;&lt;script&gt; var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; src: &apos;1.jpg&apos; &#125; &#125;);&lt;/script&gt; 绑定a标签上的id 123456789&lt;a v-bind:href=&quot;&apos;del.php?id=&apos; + id&quot;&gt;删除&lt;/a&gt;&lt;script&gt; var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; id: 11 &#125; &#125;);&lt;/script&gt; 绑定class 对象语法和数组语法 对象语法 如果isActive为true，则返回的结果为 &lt;div class=&quot;active&quot;&gt;&lt;/div&gt; 1234567891011&lt;div v-bind:class=&quot;&#123;active: isActive&#125;&quot;&gt; hei&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; isActive: true &#125; &#125;);&lt;/script&gt; 数组语法 渲染的结果 &lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt; 123456789101112&lt;div v-bind:class=&quot;[activeClass, dangerClass]&quot;&gt; hei&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; activeClass: &apos;active&apos;, dangerClass: &apos;text-danger&apos; &#125; &#125;);&lt;/script&gt; 绑定style 对象语法和数组语法 对象语法 渲染的结果 123456789101112&lt;div v-bind:style=&quot;&#123;color: redColor, fontSize: font18 + &apos;px&apos;&#125;&quot;&gt; hei&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; redColor: &apos;red&apos;, font18: 18 &#125; &#125;);&lt;/script&gt; 数组语法 1234567891011121314&lt;div v-bind:style=&quot;[color, fontSize]&quot;&gt;abc&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; color: &#123; color: &apos;red&apos; &#125;, fontSize: &#123; &apos;font-size&apos;: &apos;18px&apos; &#125; &#125; &#125;);&lt;/script&gt; 简化语法 12345&lt;div v-bind:class=&quot;&#123;active: isActive&#125;&quot;&gt;&lt;/div&gt;&lt;!-- 可以简化为，简化语法更常用 --&gt;&lt;div :class=&quot;&#123;active: isActive&#125;&quot;&gt;&lt;/div&gt; v-model表单元素的绑定 双向数据绑定 数据发生变化可以更新到界面 通过界面可以更改数据 绑定文本框 当文本框的值发生边框后，div中的内容也会发生变化 12345678910&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;&lt;div&gt;&#123;&#123; name &#125;&#125;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; name: &apos;&apos; &#125; &#125;);&lt;/script&gt; 绑定多行文本框 12&lt;textarea v-model=&quot;name&quot;&gt;&lt;/textarea&gt;&lt;div&gt;&#123;&#123; name &#125;&#125;&lt;/div&gt; 注意：多行文本框中不能使用的方式绑定 绑定复选框 绑定一个复选框 12&lt;input type=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;&lt;div&gt;&#123;&#123; checked &#125;&#125;&lt;/div&gt; 绑定多个复选框 此种方式需要input标签提供value属性 123456789101112吃饭：&lt;input type=&quot;checkbox&quot; value=&quot;eat&quot; v-model=&quot;checklist&quot;&gt;&lt;br&gt;睡觉：&lt;input type=&quot;checkbox&quot; value=&quot;sleep&quot; v-model=&quot;checklist&quot;&gt;&lt;br&gt;打豆豆：&lt;input type=&quot;checkbox&quot; value=&quot;ddd&quot; v-model=&quot;checklist&quot;&gt;&lt;br&gt;&#123;&#123; checklist &#125;&#125;&lt;script&gt; var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; checklist: [] &#125; &#125;);&lt;/script&gt; 绑定单选框 1234567891011男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot; v-model=&quot;sex&quot;&gt;女&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot; v-model=&quot;sex&quot;&gt;&#123;&#123;sex&#125;&#125;&lt;script&gt; var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; sex: &apos;&apos; &#125; &#125;);&lt;/script&gt; 绑定下拉框 123456789&lt;div id=&quot;example-5&quot;&gt; &lt;select v-model=&quot;selected&quot;&gt; &lt;option disabled value=&quot;&quot;&gt;请选择&lt;/option&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;&lt;/div&gt; v-on 绑定事件 事件修饰符： .prevent .once 简化语法 1&lt;a href=&quot;#&quot; @click.prevent=&quot;handleDelete&quot;&gt;删除&lt;a&gt; v-showv-ifv-forv-cloakv-once 一次性绑定 Vue的选项对象当创建一个 Vue 实例时，你可以传入一个选项对象。你可以在 API 文档 中浏览完整的选项列表。 el 选项 参考文档：https://cn.vuejs.org/v2/api/#el 提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。可以是 CSS 选择器，也可以是一个 HTMLElement 实例。 注意： 不能作用到 &lt;html&gt; 或者 &lt;body&gt; 上 也可以通过 实例.$mount() 手动挂载 data 选项 参考文档：https://cn.vuejs.org/v2/api/#data Vue 实例的数据对象，能够响应式数据变化(双向绑定) 可以通过 vm.$data 访问原始数据对象 Vue 实例也代理了 data 对象上所有的属性，因此访问 vm.a 等价于访问 vm.$data.a 视图中绑定的数据必须显式的初始化到 data 中 methods 选项 参考文档：https://cn.vuejs.org/v2/api/#methods methods 将被混入到 Vue 实例中。可以直接通过 vm 实例访问这些方法，或者在指令表达式中使用。方法中的 this自动绑定为 Vue 实例。 注意： 不应该使用箭头函数来定义 method 函数 (例如 plus: () =&gt; this.a++)。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.a 将是 undefined。 12345678910var vm = new Vue(&#123; data: &#123; a: 1 &#125;, methods: &#123; plus: function () &#123; this.a++ &#125; &#125;&#125;)vm.plus()vm.a // 2 案例：表格操作 展示列表数据 删除数据 添加数据 总结： Vue 最大程度上减少了页面上的 DOM 操作 让开发人员更专注于业务操作 通过简洁的指令结合页面结构与逻辑数据 代码结构更合理 维护成本更低 数据驱动 VueJS 解放了传统 JavaScript 中频繁的 DOM 操作 DevToolshttps://github.com/vuejs/vue-devtools MVVM MVVMPattern.png 其它知识点过滤器Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和 v-bind 表达式 (后者从 2.1.0+ 开始支持)。 需求：对表格案例中的日期进行格式化。 1234567&lt;td&gt;&#123;&#123; item.date | fmrTime(&apos;YYYY-MM-DD HH:mm:ss&apos;) &#125;&#125;&lt;/td&gt;&lt;script&gt;Vue.filter(&apos;fmrTime&apos;, function (time, formatStr) &#123; // 使用moment.js对日期进行格式化 return moment(time).format(formatStr);&#125;);&lt;/script&gt; 计算属性模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。 计算属性当依赖的data中的数据发生变化的时候执行 计算属性是基于它们的依赖进行缓存的，计算属性只有在它的相关依赖发生改变时才会重新求值。 参考文档 通过获取时间，演示计算属性和methods中方法的区别(缓存数据的差异)。 计算属性和方法的区别 方法每次调用都会执行 计算属性只有当依赖的数据方法变化才会执行 需求：表格案例中实现搜索功能 123456789101112131415&lt;tr v-for=&quot;(item, index) in newList&quot; :key=&quot;index&quot;&gt;....&lt;tr v-if=&quot;newList.length === 0&quot;&gt;&lt;script&gt; var vm = new Vue(&#123; el: .... computed: &#123; newList() &#123; return this.list.filter((item) =&gt; &#123; return item.name.startsWith(this.searchKey); &#125;); &#125; &#125; &#125;)&lt;/script&gt; ref在Vue.js中操作DOM。 需求：表格案例中让文本框默认获得焦。 给要获取焦点的元素增加ref属性 在mounted中通过$refs获取DOM元素 123456789101112&lt;input type=&quot;text&quot; ref=&quot;username&quot; v-model=&quot;name&quot;&gt;&lt;script&gt; var vm = new Vue(&#123; el: &apos;#app&apos;, // mounted当页面加载完毕执行 mounted: function () &#123; this.$refs.username.focus(); &#125;, data....., &#125;);&lt;/script&gt; 注意：Vue.js中不推荐直接操作DOM，除非必须否则不建议这么使用。 自定义指令除了核心功能默认的指令，例如：v-model 和 v-show，Vue 也允许注册自定义指令。 需求：表格案例中让文本框默认获得焦。 给文本框增加自定义指令 v-focus 123456789&lt;input type=&quot;text&quot; v-focus v-model=&quot;name&quot;&gt;&lt;script&gt;// 全局自定义指令Vue.directive(&apos;focus&apos;, &#123; inserted: function (el) &#123; el.focus(); &#125;&#125;);&lt;/script&gt; 发送网络请求在Vue.js中发送网络请求本质还是ajax，我们可以使用插件方便操作。 vue-resource Vuejs的插件，已经不维护，作者不推荐使用 axios 可以在任何地方使用，推荐 axios既可以在浏览器端又可以在node.js中使用的发送http请求的库，支持Promise，默认不支持jsonp。官网 发送get请求 1234567axios.get(&apos;http://localhost:3000/brands&apos;) .then(res =&gt; &#123; console.log(res.data); &#125;) .catch(err =&gt; &#123; console.dir(err) &#125;); 发送delete请求 1234567axios.delete(&apos;http://localhost:3000/brands/109&apos;) .then(res =&gt; &#123; console.log(res.data); &#125;) .catch(err =&gt; &#123; console.dir(err) &#125;); 发送post请求 1234567axios.post(&apos;http://localhost:3000/brands&apos;, &#123;name: &apos;小米&apos;, date: new Date()&#125;) .then(res =&gt; &#123; console.log(res); &#125;) .catch(err =&gt; &#123; console.dir(err) &#125;); jsonp https://github.com/axios/axios/blob/master/COOKBOOK.md 1234567jsonp(&apos;http://localhost:3000/brands&apos;, (err, data) =&gt; &#123; if (err) &#123; console.dir(err.msg); &#125; else &#123; console.dir(data); &#125; &#125;); 表格案例 数据列表 删除数据 添加数据 查询数据 侦听器 监听data对象的searchKey属性的变化，执行相应的操作 1234567891011watch: &#123; searchKey: function (newValue, oldValue) &#123; // 发送请求获取列表数据 axios.get(&apos;http://localhost:3000/brands?name_like=&apos; + newValue) .then(res =&gt; &#123; this.list = res.data; &#125;) .catch(err =&gt; &#123; console.log(err); &#125;); &#125; 过渡和动画Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。 在 CSS 过渡和动画中自动应用 classVue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡 1234567// v要替换成transition组件的name属性值v-enter：定义进入过渡的开始状态。v-enter-active：定义进入过渡生效时的状态。v-enter-to: 2.1.8版及以上 定义进入过渡的结束状态。v-leave: 定义离开过渡的开始状态。v-leave-active：定义离开过渡生效时的状态。v-leave-to: 2.1.8版及以上 定义离开过渡的结束状态。 示例： 12345678910111213141516171819202122232425262728293031323334&lt;style&gt; .box &#123; position: absolute; left: 0; top: 50px; width: 100px; height: 100px; background-color: red; &#125; .slide-enter, .slide-leave-to &#123; left: 200px; opacity: 0; &#125; .slide-enter-active, .slide-leave-active &#123; transition: all 2s; &#125; .slide-enter-to, .slide-leave &#123; left: 0px; opacity: 1; &#125;&lt;/style&gt;&lt;button @click=&quot;isShow = !isShow&quot;&gt;显示/隐藏&lt;/button&gt;&lt;transition name=&quot;slide&quot;&gt; &lt;div v-show=&quot;isShow&quot; class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/transition&gt;&lt;script&gt; var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; isShow: true &#125; &#125;);&lt;/script&gt; 自定义过渡动画的类名可以通过transition组件自定义过渡动画的类名，可以方便结合第三方的动画库使用，比如：animate.css 1234567// transition组件的属性 enter-classenter-active-classenter-to-class (2.1.8+)leave-classleave-active-classleave-to-class (2.1.8+) 示例： 1234567891011121314&lt;button @click=&quot;isShow = !isShow&quot;&gt;toggle&lt;/button&gt;&lt;transition enter-active-class=&quot;animated fadeIn&quot; leave-active-class=&quot;animated fadeOut&quot;&gt; &lt;div v-show=&quot;isShow&quot;&gt;hello&lt;/div&gt;&lt;/transition&gt;&lt;script&gt; var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; isShow: true &#125; &#125;);&lt;/script&gt; 组件什么是组件组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树： components.png 组件和模块 模块：侧重于功能或者数据的封装 组件：包含了 template、style 和 script，而它的 script 可以由各种模块组成 b25efd3e8af188b5ab36ccb66baddd71_hd.jpg Vue中的组件开发组件是可复用的 Vue 实例，且带有一个名字，比如 &lt;my-breadcrumb&gt;。把这个组件作为自定义元素来使用。组件的好处是写一次可以进行任意次数的复用。 组件参考文档 全局组件123456789101112131415161718Vue.component(&apos;my-breadcrumb&apos;, &#123; template: `&lt;div&gt; &lt;span&gt;&#123;&#123; level1 &#125;&#125;&lt;/span&gt; &lt;span&gt;/&lt;/span&gt; &lt;span @click=&quot;t&quot;&gt;&#123;&#123; level2 &#125;&#125;&lt;/span&gt; &lt;div&gt;`, data() &#123; return &#123; level1: &apos;用户管理1&apos;, level2: &apos;用户列表1&apos; &#125;; &#125;, methods: &#123; t() &#123; alert(&apos;hello&apos;); &#125; &#125; &#125;); 注意： 组件的模板中必须有且只有一个根标签 组件是一个特殊的Vue实例 组件中的data是一个方法，目的是让每一个组件维护一个自己的数据 组件有自己的作用域 私有组件123456789101112131415// 私有组件var ComponentA = &#123; template: &apos;&lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;&apos;, data() &#123; return &#123; msg: &apos;hello&apos; &#125;; &#125;&#125;;var vm = new Vue(&#123; el: &apos;#app&apos;, components: &#123; &apos;component-a&apos;: ComponentA &#125;&#125;); 通过Props给子组件传值 子组件可以通过 props 选项接收一个一些值，通过 props 传递的值变成了改组件的一个属性。 1234var ComponentA = &#123; template: &apos;&lt;div&gt;&#123;&#123; title &#125;&#125;&lt;/div&gt;&apos;, props: [&apos;title&apos;],&#125;; 当然子组件具有 props 选项后，数据可以通过标签的自定义属性传递给子组件 1&lt;component-a :title=&quot;msg&quot;&gt;&lt;/component-a&gt; 在vue的实例中提供该属性值 123456789var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; msg: &apos;hello heima&apos;, &#125;, components: &#123; &apos;component-a&apos;: ComponentA &#125;&#125;); Vue实例的生命周期 什么生命周期 定义：生命周期是指vue实例或者组件从诞生到消亡经历的每一个阶段，在这些阶段的前后可以设置一些函数当做事件来调用。 参考 生命周期 生命周期中的钩子函数 123456789101112131415161718192021222324//创造vue实例之后运行此函数，vm中的data/methods中的成员不可用beforeCreate: function () &#123; console.log(&quot;beforeCreate&quot;)&#125;//创造vue实例之后运行此函数，vm中的data/methods属性可用created: function () &#123; console.log(&quot;created&quot;)&#125;//当vue实例的el节点或组件挂载到页面以前运行次函数beforeMount: function () &#123; console.log(&quot;beforeMount&quot;)&#125;//当vue实例的el节点或组件挂载到页面以后运行次函数mounted: function () &#123; console.log(&quot;mounted&quot;)&#125;//当vue实例数据发生改变前触发此函数beforeUpdate: function () &#123; console.log(&quot;beforeUpdate&quot;)&#125;//当vue实例数据发生改变后触发此函数updated: function () &#123; console.log(&quot;updated&quot;)&#125; 前端路由单页应用 什么是单页应用 单页应用(single page web application，SPA)，是在一个页面完成所有的业务功能，浏览器一开始会加载必需的HTML、CSS和JavaScript，之后所有的操作都在这张页面完成，这一切都由JavaScript来控制。 单页应用优缺点 优点 操作体验流畅 完全的前端组件化 缺点 首次加载大量资源(可以只加载所需部分) 对搜索引擎不友好 开发难度相对较高 单页应用的原理 Hash路由 利用URL上的hash，当hash改变不会引起页面刷新，所以可以利用 hash 值来做单页面应用的路由， 并且当 url 的 hash 发生变化的时候，可以触发相应 hashchange 回调函数。 模拟实现 12345678910111213var app = document.getElementById(&apos;app&apos;);window.onhashchange = function () &#123; var hash = location.hash.replace(&apos;#&apos;, &apos;&apos;); switch (hash.toLowerCase()) &#123; case &apos;/&apos;: app.innerHTML = &apos;首页内容&apos;; break; case &apos;/users&apos;: app.innerHTML = &apos;用户管理内容&apos;; break; …… &#125;&#125;; History路由 History 路由是基于 HTML5 规范，在 HTML5 规范中提供了 history.pushState || history.replaceState 来进行路由控制。 vue-router快速体验 导入vue和vue-router 设置HTML中的内容 12345&lt;!-- router-link 最终会被渲染成a标签，to指定路由的跳转地址 --&gt;&lt;router-link to=&quot;/users&quot;&gt;用户管理&lt;/router-link&gt;&lt;!-- 路由匹配到的组件将渲染在这里 --&gt;&lt;router-view&gt;&lt;/router-view&gt; 创建组件 12345678// 创建组件// 组件可以放到单独的js文件中var Home = &#123; template: &apos;&lt;div&gt;这是Home内容&lt;/div&gt;&apos;&#125;;var Users = &#123; template: &apos;&lt;div&gt;这是用户管理内容&lt;/div&gt;&apos;&#125;; 配置路由规则 1234567// 配置路由规则var router = new VueRouter(&#123; routes: [ &#123; name: &apos;home&apos;, path: &apos;/&apos;, component: Home &#125;, &#123; name: &apos;users&apos;, path: &apos;/users&apos;, component: Users &#125; ]&#125;); 设置vue的路由选项 1234var vm = new Vue(&#123; el: &apos;#app&apos;, router&#125;); 动态路由匹配假设有一个用户列表，想要删除某一个用户，需要获取用户的id传入组件内，如何实现呢？ 此时可以通过路由传参来实现，具体步骤如下： 路由规则中增加参数，在path最后增加 :id 1&#123; name: &apos;users&apos;, path: &apos;/users/:id&apos;, component: Users &#125;, 通过 传参，在路径上传入具体的值 1&lt;router-link to=&quot;/users/120&quot;&gt;用户管理&lt;/router-link&gt; 在组件内部可以使用，this.$route 获取当前路由对象 123456var Users = &#123; template: &apos;&lt;div&gt;这是用户管理内容 &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&apos;, mounted() &#123; console.log(this.$route.params.id); &#125;&#125;; webpackwebpack 是一个模块打包器。webpack 的主要目标是将 JavaScript 文件打包在一起,打包后的文件用于在浏览器中使用。 参考网站： 中文参考网站 官网 安装webpack最新webpack版本4.x 本地安装webpack 安装webpack的命令行工具 webpack-cli 1$ npm install webpack webpack-cli --save-dev 快速实践参考官网 项目结构，默认的目录和文件名称不可修改 123456 webpack-demo |- package.json+ |- /dist+ |- index.html |- /src |- index.js 入口js文件，默认名称index.js math.js 12345678export default &#123; add(a, b) &#123; return a + b; &#125;, sub(a, b) &#123; return a - b; &#125;&#125;; index.js 1234567import Math from &apos;./math&apos;;var x = 5;var y = 6;console.log(Math.add(5, 6));console.log(Math.sub(5, 6)); 运行 1$ npm webpack 配置文件 webpack.config.jswebpack4.x 以前，必须要有配置文件。在 webpack 4.x 以后，可以无须任何配置使用()，然而大多数项目会需要很复杂的设置，这就是为什么 webpack 仍然要支持。 使用步骤 项目根目录下，手动新建webpack.config.js 12345678910const path = require(&apos;path&apos;);module.exports = &#123; // 配置入口文件 entry: &apos;./src/index.js&apos;, // 配置打包的文件和路径 output: &#123; filename: &apos;bundle.js&apos;, path: path.resolve(__dirname, &apos;dist&apos;) &#125;&#125;; 运行命令 1$ npm webpack --config webpack.config.js 注意：打包的文件名改变后，要修改index.html的script标签引入的文件名 NPM脚本 输入上面的命令太繁琐，可以直接在终端运行 webpack，会默认加载webpack.config.js配置文件。 在package.json中新增 1234&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;build&quot;: &quot;webpack&quot; &#125;, 终端输入 1$ npm run build webpack常用的Loaderwebpack 最出色的功能之一就是，除了 JavaScript，还可以通过 loader 引入任何其他类型的文件。webpack 可以把所有文件作为模块，动态打包(dynamically bundle)所有依赖项。 参考文档 打包CSS 安装和配置 style-loader 和 css-loader 安装 1$ npm install --save-dev style-loader css-loader 配置，在webpack.config.js中 12345678910111213141516171819 const path = require(&apos;path&apos;); module.exports = &#123; entry: &apos;./src/index.js&apos;, output: &#123; filename: &apos;bundle.js&apos;, path: path.resolve(__dirname, &apos;dist&apos;) &#125;,+ module: &#123;+ rules: [+ &#123;+ test: /\\.css$/,+ use: [+ &apos;style-loader&apos;,+ &apos;css-loader&apos;+ ]+ &#125;+ ]+ &#125; &#125;; 在入口index.js中，导入css模块 1import &apos;./css/index.css&apos;; 运行webpack命令 1$ npm run build 打包less 安装和配置 1$ npm install less-loader less --save-dev 12345678&#123; test: /\\.less$/, use: [ &apos;style-loader&apos;, &apos;css-loader&apos;, &apos;less-loader&apos; ]&#125; less 1234@color: yellow;body &#123; background-color: @color;&#125; 打包sass 安装和配置 1$ npm install sass-loader node-sass --save-dev 12345678&#123; test: /\\.scss$/, use: [ &apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos; ]&#125; scss 1234$color: red;body &#123; background-color: $color;&#125; 加载图片使用 file-loader 可以加载图片和字体 安装和配置 1$ npm install --save-dev file-loader 123456&#123; test: /\\.(png|svg|jpg|gif)$/, use: [ &apos;file-loader&apos; ]&#125; 加载字体 配置 123456&#123; test: /\\.(woff|woff2|eot|ttf|otf)$/, use: [ &apos;file-loader&apos; ]&#125; webpack常用插件除了通过loader去处理不同的资源文件以外，webpack还支持插件机制，通过插件可以完成更多的事情。 HtmlWebpackPlugin自动生成index.html，并引入资源文件，还可以通过配置压缩HTML。 安装 1npm install --save-dev html-webpack-plugin 配置 12345678910111213141516const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);......plugins: [ new HtmlWebpackPlugin(&#123; // 文档的标题 title: &apos;Output Management&apos;, // 生成的文档文件名 filename: &apos;index.html&apos;, // 模板文件 template: &apos;index.html&apos;, minify: &#123; collapseWhitespace: true &#125; &#125;)]...... CleanWebpackPlugin清空dist目录。 安装 1npm install clean-webpack-plugin --save-dev 配置 12345const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);……new CleanWebpackPlugin([&apos;dist&apos;]),…… 使用source map参考文档 在webpack.config.js中添加 1devtool: &apos;inline-source-map&apos;, 使用 webpack-dev-serverwebpack-dev-server 为你提供了一个简单的 web 服务器，并且能够实时重新加载(live reloading)。让我们设置以下： 1$ npm install --save-dev webpack-dev-server webpack.config.js 123devServer: &#123; contentBase: &apos;./dist&apos;&#125;, package.json 1&quot;start&quot;: &quot;webpack-dev-server --open&quot; 启用HMR模块热替换(Hot Module Replacement 或 HMR)是 webpack 提供的最有用的功能之一。它允许在运行时更新各种模块，而无需进行完全刷新。 webpack.config.js 12345678910111213const webpack = require(&apos;webpack&apos;);.......devServer: &#123; contentBase: &apos;./dist&apos;, hot: true&#125;,.............. new webpack.NamedModulesPlugin(), new webpack.HotModuleReplacementPlugin()....... 综合案例单文件组件可以通过 .vue 文件封装组件，参考文档 处理 .vue 文件 — 使用 vue-loader vue-loader使用比较特殊，如下 12$ npm install vue-loader --save-dev$ npm install vue-template-compiler --save-dev 1// 配置插件 12345// 配置loader&#123; test: /\\.vue$/, loader: &apos;vue-loader&apos;&#125; 案例演示 image-20180526145007221.png 搭建项目结构 新建项目 初始化package.json 12# 注意项目名称不能有中文$ npm init -y 拷贝 webpack.config.js 到根目录 拷贝依赖 123456789101112131415161718192021&quot;devDependencies&quot;: &#123; &quot;clean-webpack-plugin&quot;: &quot;^0.1.19&quot;, &quot;css-loader&quot;: &quot;^0.28.11&quot;, &quot;file-loader&quot;: &quot;^1.1.11&quot;, &quot;html-minifier&quot;: &quot;^3.5.16&quot;, &quot;html-webpack-plugin&quot;: &quot;^3.2.0&quot;, &quot;less&quot;: &quot;^3.0.4&quot;, &quot;less-loader&quot;: &quot;^4.1.0&quot;, &quot;node-sass&quot;: &quot;^4.9.0&quot;, &quot;sass-loader&quot;: &quot;^7.0.1&quot;, &quot;style-loader&quot;: &quot;^0.21.0&quot;, &quot;url-loader&quot;: &quot;^1.0.1&quot;, &quot;vue-loader&quot;: &quot;^15.2.0&quot;, &quot;vue-template-compiler&quot;: &quot;^2.5.16&quot;, &quot;webpack&quot;: &quot;^4.8.3&quot;, &quot;webpack-cli&quot;: &quot;^2.1.4&quot;, &quot;webpack-dev-server&quot;: &quot;^3.1.4&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;vue&quot;: &quot;^2.5.16&quot; &#125; 安装依赖 1$ npm install 下载bootstrap3 1$ npm install bootstrap@3.3.7 --save 项目结构 [图片上传失败…(image-de211b-1527597271494)] 配置根组件 从模板中复制自定义样式 index.css 到assets/css目录 入口文件 src/index.js 123456789101112import Vue from &apos;vue&apos;;import App from &apos;./App.vue&apos;;// 导入bootstrap样式import &apos;bootstrap/dist/css/bootstrap.css&apos;;// 导入自定义样式import &apos;./assets/css/index.css&apos;;const vm = new Vue(&#123; el: &apos;#app&apos;, render: c =&gt; c(App)&#125;); 根组件 src/App.vue 复制模板中index.html的内容到App.vue中 运行测试 1$ npm start 提取子组件 提取头部组件 components/header.vue 提取侧边栏组件 components/sidebar.vue 提取英雄列表组件 views/hero-list.vue 根组件 src/App.vue 中加载组件 12345678910import Header from &apos;./components/header.vue&apos;;import Sidebar from &apos;./components/sidebar.vue&apos;;import Heroes from &apos;./views/heroes.vue&apos;;export default &#123; components: &#123; Header, Sidebar, Heroes &#125;&#125;; 123456789101112131415&lt;div&gt; &lt;Header&gt;&lt;/Header&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;Sidebar&gt;&lt;/Sidebar&gt; &lt;div class=&quot;col-sm-9 col-sm-offset-3 col-md-10 col-md-offset-2 main&quot;&gt; &lt;h2 class=&quot;sub-header&quot;&gt;Hero List&lt;/h2&gt; &lt;a class=&quot;btn btn-success&quot; href=&quot;add.html&quot;&gt;Add&lt;/a&gt; &lt;div class=&quot;table-responsive&quot;&gt; &lt;Heroes&gt;&lt;/Heroes&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 使用 Vue-Router 实现页面导航管理 Vue-Router 能帮我们实现点击某个导航链接的时候动态的展示一个组件 安装路由模块 1$ npm install vue-router --save 注册路由插件 在index.js中，加载路由插件 123import VueRouter from &apos;vue-router&apos;;// 注册路由插件Vue.use(VueRouter); 加载组件，配置路由规则 index.js中 123456789101112131415161718192021// 加载组件import Heroes from &apos;./views/heroes/heroes.vue&apos;;import Weapons from &apos;./views/weapons.vue&apos;;import Equips from &apos;./views/equips.vue&apos;;// 配置路由规则const router = new VueRouter(&#123; routes: [ // 设置根路径跳转到英雄管理界面 &#123;&apos;name&apos;: &apos;home&apos;, path: &apos;/&apos;, redirect: &#123;name: &apos;heroes&apos;&#125;&#125;, &#123;&apos;name&apos;: &apos;heroes&apos;, path: &apos;/heroes&apos;, component: Heroes&#125;, &#123;&apos;name&apos;: &apos;weapons&apos;, path: &apos;/weapons&apos;, component: Weapons&#125;, &#123;&apos;name&apos;: &apos;equips&apos;, path: &apos;/equips&apos;, component: Equips&#125; ]&#125;);new Vue(&#123; el: &apos;#app&apos;, render: c =&gt; c(App), // 设置路由 router&#125;); 在 src/App.vue 组件中留路由出口（告诉路由往哪里渲染 path 匹配到的组件） 1234&lt;Sidebar&gt;&lt;/Sidebar&gt;&lt;div class=&quot;col-sm-9 col-sm-offset-3 col-md-10 col-md-offset-2 main&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; 在侧边栏 src/components/sidebar.vue 组件中 增加两个导航链接 将激活-class-应用在外层元素 1234567891011&lt;ul class=&quot;nav nav-sidebar&quot;&gt; &lt;router-link to=&quot;/heroes&quot; tag=&quot;li&quot; active-class=&quot;active&quot;&gt; &lt;a&gt;英雄列表&lt;/a&gt; &lt;/router-link&gt; &lt;router-link to=&quot;/weapons&quot; tag=&quot;li&quot; active-class=&quot;active&quot;&gt; &lt;a&gt;武器列表&lt;/a&gt; &lt;/router-link&gt; &lt;router-link to=&quot;/equips&quot; tag=&quot;li&quot; active-class=&quot;active&quot;&gt; &lt;a&gt;装备列表&lt;/a&gt; &lt;/router-link&gt;&lt;/ul&gt; JSON Server可以快速开启 REST API 测试服务器的工具命令行工具。官网 安装1$ npm install json-server -g 使用1$ json-server --watch db.json 接口地址 获取英雄列表 请求路径：http://localhost:3000/heros 请求方法：GET 根据英雄id获取一个英雄 请求路径： 1http://localhost:3000/heros/:id :id 需要给定一个英雄的 id 请求方法：GET 添加英雄 请求路径：http://localhost:3000/heros 请求方法：POST 请求体： 1234&#123; name: &apos;英雄名称&apos;, gender: &apos;英雄性别&apos;&#125; 删除英雄 请求路径： 1http://localhost:3000/heros/:id :id 需要给定一个英雄的 id 请求方法：DELETE 编辑英雄 请求路径： 1http://localhost:3000/heros/:id :id 需要给定一个英雄的 id 请求方法：PATCH 请求体： 1234&#123; name: &apos;英雄名称&apos;, gender: &apos;英雄性别&apos;&#125; 实现项目功能安装 axios 到项目中 1$ npm install axios --save 英雄列表JS 1234567891011121314151617import axios from &apos;axios&apos;;export default &#123; data() &#123; return &#123; heroes: [] &#125;; &#125;, mounted() &#123; this.loadData(); &#125;, methods: &#123; async loadData() &#123; const res = await axios.get(&apos;http://localhost:3000/heros&apos;); this.heroes = res.data; &#125; &#125;&#125;; HTML 1234567891011&lt;tr v-for=&quot;(item, index) in heroes&quot; :key=&quot;item.id&quot;&gt; &lt;td&gt;&#123;&#123; index + 1 &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; item.name &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; item.gender &#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;!-- &lt;router-link :to=&quot;&apos;/edit/&apos; + item.id&quot;&gt;&lt;/router-link&gt; --&gt; &lt;a href=&quot;edit.html&quot;&gt;edit&lt;/a&gt; &amp;nbsp;&amp;nbsp; &lt;a href=&quot;javascript:window.confirm(&apos;Are you sure?&apos;)&quot;&gt;delete&lt;/a&gt; &lt;/td&gt;&lt;/tr&gt; 删除英雄HTML 12&lt;!-- prevent 修饰符，阻止后续内容的执行 --&gt;&lt;a href=&quot;#&quot; @click.prevent=&quot;handleClick(item.id)&quot;&gt;delete&lt;/a&gt; JS 12345678910111213async handleClick(id) &#123; const isConfirmed = confirm(&apos;确认要删除该英雄？&apos;); if (!isConfirmed) &#123; return; &#125; const res = await axios.delete(`http://localhost:3000/heros/$&#123;id&#125;`); if (res.status === 200) &#123; this.loadData(); alert(&apos;删除成功&apos;); &#125; else &#123; alert(&apos;删除失败&apos;); &#125;&#125; 添加英雄路由 新建 src/views/heroes/heroes-add.vue 配置路由 12345import HeroesAdd from &apos;../views/heroes/heroes-add.vue&apos;;// 增加一个路由规则&#123;&apos;name&apos;: &apos;heroesadd&apos;, path: &apos;/heroes/add&apos;, component: HeroesAdd&#125;, &#123;&apos;name&apos;: &apos;heroes&apos;, path: &apos;/heroes&apos;, component: Heroes&#125;, src/views/heroes/heroes.vue 中点击添加按钮 1&lt;router-link class=&quot;btn btn-success&quot; to=&quot;/heroes/add&quot;&gt;Add&lt;/router-link&gt; HTML 123456789101112&lt;h2 class=&quot;sub-header&quot;&gt;添加英雄&lt;/h2&gt;&lt;form&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;name&quot;&gt;英雄名称&lt;/label&gt; &lt;input type=&quot;text&quot; v-model=&quot;formData.name&quot; class=&quot;form-control&quot; id=&quot;name&quot; placeholder=&quot;英雄名称&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;sex&quot;&gt;英雄性别&lt;/label&gt; &lt;input type=&quot;text&quot; v-model=&quot;formData.gender&quot; class=&quot;form-control&quot; id=&quot;sex&quot; placeholder=&quot;英雄性别&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; @click.prevent=&quot;handleAdd&quot; class=&quot;btn btn-success&quot;&gt;Submit&lt;/button&gt;&lt;/form&gt; JS 12345678910111213141516171819202122232425import axios from &apos;axios&apos;;export default &#123; data() &#123; return &#123; formData: &#123; name: &apos;&apos;, gender: &apos;&apos; &#125; &#125;; &#125;, methods: &#123; async handleAdd() &#123; const res = await axios.post(&apos;http://localhost:3000/heros&apos;, this.formData); if (res.status === 201) &#123; // 跳转到列表页面 this.$router.push(&#123; name: &apos;heroes&apos; &#125;); &#125; else &#123; alert(&apos;添加失败&apos;); &#125; &#125; &#125;&#125;; 编辑英雄路由 新建 src/views/heroes/heroes-edit.vue 配置路由 123456import HeroesEdit from &apos;../views/heroes/heroes-edit.vue&apos;;// 增加一个路由规则&#123;&apos;name&apos;: &apos;heroes&apos;, path: &apos;/heroes&apos;, component: Heroes&#125;,&#123;&apos;name&apos;: &apos;heroesadd&apos;, path: &apos;/heroes/add&apos;, component: HeroesAdd&#125;,&#123;&apos;name&apos;: &apos;heroesedit&apos;, path: &apos;/heroes/edit/:id&apos;, component: HeroesEdit&#125;, src/views/heroes/heroes.vue 中，设置编辑 1&lt;router-link :to=&quot;&#123;name: &apos;heroesedit&apos;, params: &#123;id: item.id&#125;&#125;&quot;&gt;edit&lt;/router-link&gt; HTML 和添加英雄一样 JS 1234567891011121314151617181920212223242526272829303132333435363738import axios from &apos;axios&apos;;export default &#123; data() &#123; return &#123; formData: &#123; name: &apos;&apos;, gender: &apos;&apos; &#125;, heroId: -1 &#125;; &#125;, created() &#123; this.heroId = this.$route.params.id; this.getHeroById(); &#125;, methods: &#123; // 根据id，获取英雄信息 async getHeroById() &#123; const res = await axios.get(`http://localhost:3000/heros/$&#123;this.heroId&#125;`); if (res.status === 200) &#123; this.formData = res.data; &#125; &#125;, // 更新英雄信息 async handleEdit() &#123; const res = await axios.patch(`http://localhost:3000/heros/$&#123;this.heroId&#125;`, this.formData); if (res.status === 200) &#123; // 跳转到列表页面 this.$router.push(&#123; name: &apos;heroes&apos; &#125;); &#125; else &#123; alert(&apos;编辑失败&apos;); &#125; &#125; &#125;&#125;; NPM 缓存安装需要曾经从网络使用NPM安装过想要的包 1$ npm --cache-min 9999999 install webpack --save-dev","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://WLL-1017065322.github.io/blog/tags/vue/"}],"author":"along"},{"title":"Promise探析","slug":"promise","date":"2019-04-25T16:00:00.000Z","updated":"2019-05-12T03:46:35.920Z","comments":true,"path":"2019/04/26/promise/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/04/26/promise/","excerpt":"","text":"前言 上一篇，关于axios的二次封装，我们已经探讨过什么是Promise，它可以做什么的问题，现在，我们继续来通过一个简单的DOM案例探析。 你还在这样写？DOM原生事件 根据MDN上面的相关推荐指导，我们应该更多地去使用addEventListener，而非那些原生定义的onclick之类的。 1234567891011//比如我们尝试去添加一个动画效果 window.onload = () =&gt; &#123; document.querySelector(&apos;.app1&apos;) .addEventListener(&apos;mouseenter&apos;, (event) =&gt; &#123; const timer = setInterval(()=&gt;&#123; event.style.opacity += 0.1; if (event.style.opacity === 1) clearInterval(timer); &#125;,1000/20) &#125;); &#125; 我的天呐！一层、两层……总共三层回调，这已经调入回调地狱了，如果再深入设置其他的动画，那岂不是更乱了，想想办法吧。 jQuery写法123456789101112$(()=&gt;&#123; $(&apos;.app&apos;).hover(function(e)=&gt;&#123; const timer = setInterval(()=&gt;&#123; e.css(&#123; opacity:`++0.1` &#125;) if (e.css(&apos;opacity&apos;) === 1) clearInterval(timer); &#125;,1000/20) &#125;); &#125;);&#125;) 一样的酸爽对吧！ 这样做才爽Demo JS部分 1234567891011121314151617181920212223242526272829303132333435363738window.onload = () =&gt; &#123; return new Promise((resolve) =&gt; &#123; document.querySelector(&apos;.app1&apos;) .addEventListener(&apos;mouseenter&apos;, () =&gt; &#123; resolve(&apos;Test&apos;); &#125;); &#125;) .then((data) =&gt; &#123; console.log(data); if (data) &#123; let height = getComputedStyle(document.querySelector(&apos;.app2&apos;))[&apos;top&apos;]; let value = Number.parseInt(height); let timer = setInterval(() =&gt; &#123; value += 10; console.log(value); document.querySelector(&apos;.app2&apos;) .style.top = `-$&#123;value&#125;px`; if (value === 200) &#123; clearInterval(timer); &#125; &#125;, 1000 / 20); &#125; return true; &#125;, (err) =&gt; &#123; console.log(err); &#125;) .then((data) =&gt; &#123; console.log(data); console.log(&apos;开始执行显示&apos;); if (data) &#123; document.querySelector(&apos;.app2&apos;) .style.display = &apos;block&apos;; document.querySelector(&apos;.app2&apos;) .style.opacity = 0.6; &#125; &#125;) &#125; HTML部分 1234567&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;app1&quot;&gt; &lt;img src=&quot;./logo.png&quot; alt=&quot;logo&quot;&gt; &lt;/div&gt; &lt;div class=&quot;app2&quot;&gt; Vue.js &lt;/div&gt; CSS部分 123456789101112131415161718192021&lt;style&gt; .box&#123; width: 300px; margin: 50px auto; &#125; .app1 &#123; width: 200px; height: 200px; &#125; .app2 &#123; width: 200px; height: 200px; background-color: gainsboro; opacity: 8; display: none; text-align: center; position: relative; top: 0; &#125; &lt;/style&gt; 总结 一个Promise可以有多个then函数衔接处理，达到一个同步处理的效果，每次then之后，下一个then接收的是上一个then的return数据，第一个then则接收的是最初的promise回调resolve放行的数据。 引用自： https://ivu1314.club/categories/%E7%BB%8F%E9%AA%8C/","categories":[{"name":"First","slug":"First","permalink":"https://WLL-1017065322.github.io/blog/categories/First/"}],"tags":[{"name":"Promise","slug":"Promise","permalink":"https://WLL-1017065322.github.io/blog/tags/Promise/"}],"author":"along"},{"title":"AJAX","slug":"ajax简介","date":"2019-04-25T16:00:00.000Z","updated":"2019-05-12T03:46:35.830Z","comments":true,"path":"2019/04/26/ajax简介/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/04/26/ajax简介/","excerpt":"","text":"什么是 AJAX ？AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 AJAX = 异步 JavaScript 和 XML。Asynchronous Javascript And XML AJAX 是一种用于创建快速动态网页的技术。 通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。 有很多使用 AJAX 的应用程序案例：新浪微博、Google 地图、开心网等等。 AJAX - 创建 XMLHttpRequest 对象 XMLHttpRequest 是 AJAX 的基础。 XMLHttpRequest 对象所有现代浏览器均支持 XMLHttpRequest 对象（IE5 和 IE6 使用 ActiveXObject）。 XMLHttpRequest 用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 创建 XMLHttpRequest 对象所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。 创建 XMLHttpRequest 对象的语法： variable=new XMLHttpRequest(); 老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象： variable=new ActiveXObject(“Microsoft.XMLHTTP”); 为了应对所有的现代浏览器，包括 IE5 和 IE6，请检查浏览器是否支持 XMLHttpRequest 对象。如果支持，则创建 XMLHttpRequest 对象。如果不支持，则创建 ActiveXObject ： 兼容语法： var xmlhttp;if (window.XMLHttpRequest){// IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码xmlhttp=new XMLHttpRequest();}else{// IE6, IE5 浏览器执行代码xmlhttp=new ActiveXObject(“Microsoft.XMLHTTP”);} AJAX - 向服务器发送请求请求 XMLHttpRequest 对象用于和服务器交换数据。 向服务器发送请求如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法： xmlhttp.open(“GET”,”ajax_info.txt”,true); xmlhttp.send(); 方法 描述 open(method,url,async) 规定请求的类型、URL 以及是否异步处理请求。 method：请求的类型；GET 或 POST url：文件在服务器上的位置 async：true（异步）或 false（同步） send(string) 将请求发送到服务器。 string：仅用于 POST 请求 GET 还是 POST？与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。 然而，在以下情况中，请使用 POST 请求： 无法使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 GET 请求一个简单的 GET 请求： 实例xmlhttp.open(“GET”,”/try/ajax/demo_get.php”,true); xmlhttp.send(); POST 请求一个简单 POST 请求： 实例 xmlhttp.open(“POST”,”/try/ajax/demo_post.php”,true); xmlhttp.send(); 如果需要像 HTML 表单那样 POST 数据，请使用 setRequestHeader() 来添加 HTTP 头。然后在 send() 方法中规定您希望发送的数据： 实例 xmlhttp.open(“POST”,”/try/ajax/demo_post2.php”,true); xmlhttp.setRequestHeader(“Content-type”,”application/x-www-form-urlencoded”); xmlhttp.send(“fname=Henry&amp;lname=Ford”); 方法 描述 setRequestHeader(header,value) 向请求添加 HTTP 头。 header: 规定头的名称 value: 规定头的值 url - 服务器上的文件open() 方法的 url 参数是服务器上文件的地址： xmlhttp.open(“GET”,”ajax_test.html”,true); 该文件可以是任何类型的文件，比如 .txt 和 .xml，或者服务器脚本文件，比如 .asp 和 .php （在传回响应之前，能够在服务器上执行任务）。 异步 - True 或 False？AJAX 指的是异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。 XMLHttpRequest 对象如果要用于 AJAX 的话，其 open() 方法的 async 参数必须设置为 true： xmlhttp.open(“GET”,”ajax_test.html”,true); 对于 web 开发人员来说，发送异步请求是一个巨大的进步。很多在服务器执行的任务都相当费时。AJAX 出现之前，这可能会引起应用程序挂起或停止。 通过 AJAX，JavaScript 无需等待服务器的响应，而是： 在等待服务器响应时执行其他脚本 当响应就绪后对响应进行处理 Async=true当使用 async=true 时，请规定在响应处于 onreadystatechange 事件中的就绪状态时执行的函数： sync = false如需使用 async=false，请将 open() 方法中的第三个参数改为 false： 1xmlhttp.open(&quot;GET&quot;,&quot;test1.txt&quot;,false); 我们不推荐使用 async=false，但是对于一些小型的请求，也是可以的。 请记住，JavaScript 会等到服务器响应就绪才继续执行。如果服务器繁忙或缓慢，应用程序会挂起或停止。 注意：当您使用 async=false 时，请不要编写 onreadystatechange 函数 - 把代码放到 send() 语句后面即可： AJAX - 服务器 响应 服务器响应如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。 属性 描述 responseText 获得字符串形式的响应数据。 responseXML 获得 XML 形式的响应数据。 responseText 属性如果来自服务器的响应并非 XML，请使用 responseText 属性。 responseText 属性返回字符串形式的响应，因此您可以这样使用： document.getElementById(“myDiv”).innerHTML=xmlhttp.responseText; responseXML 属性如果来自服务器的响应是 XML，而且需要作为 XML 对象进行解析，请使用 responseXML 属性： ​ 实例请求 cd_catalog.xml 文件，并解析响应： xmlDoc=xmlhttp.responseXML; txt=””; x=xmlDoc.getElementsByTagName(“ARTIST”); for (i=0;i&lt;x.length;i++) { txt=txt + x[i].childNodes[0].nodeValue + ““; } document.getElementById(“myDiv”).innerHTML=txt; 获取元素内容 /txt=txt + x[i].childNodes[0].nodeValue + “ “; AJAX - onreadystatechange 事件 onreadystatechange 事件当请求被发送到服务器时，我们需要执行一些基于响应的任务。 每当 readyState 改变时，就会触发 onreadystatechange 事件。 readyState 属性存有 XMLHttpRequest 的状态信息。 下面是 XMLHttpRequest 对象的三个重要的属性： 属性 描述 onreadystatechange 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。 readyState 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 status 200: “OK” 404: 未找到页面 在 onreadystatechange 事件中，我们规定当服务器响应已做好被处理的准备时所执行的任务。 当 readyState 等于 4 且状态为 200 时，表示响应已就绪： 实例 xmlhttp.onreadystatechange=function() { if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) { document.getElementById(“myDiv”).innerHTML=xmlhttp.responseText; } } 注意： onreadystatechange 事件被触发 4 次（0 - 4）, 分别是： 0-1、1-2、2-3、3-4，对应着 readyState 的每个变化。 ps： xmlhttp.readyState的值及解释： 0：请求未初始化（还没有调用 open()）。 1：请求已经建立，但是还没有发送（还没有调用 send()）。 2：请求已发送，正在处理中（通常现在可以从响应中获取内容头）。 3：请求在处理中；通常响应中已有部分数据可用了，但是服务器还没有完成响应的生成。 4：响应已完成；您可以获取并使用服务器的响应了。 xmlhttp.status的值及解释： 100——客户必须继续发出请求 101——客户要求服务器根据请求转换HTTP协议版本 200——交易成功 201——提示知道新文件的URL 202——接受和处理、但处理未完成 203——返回信息不确定或不完整 204——请求收到，但返回信息为空 205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件 206——服务器已经完成了部分用户的GET请求 300——请求的资源可在多处得到 301——删除请求数据 302——在其他地址发现了请求数据 303——建议客户访问其他URL或访问方式 304——客户端已经执行了GET，但文件未变化 305——请求的资源必须从服务器指定的地址得到 306——前一版本HTTP中使用的代码，现行版本中不再使用 307——申明请求的资源临时性删除 400——错误请求，如语法错误 401——请求授权失败 402——保留有效ChargeTo头响应 403——请求不允许 404——没有发现文件、查询或URl 405——用户在Request-Line字段定义的方法不允许 406——根据用户发送的Accept拖，请求资源不可访问 407——类似401，用户必须首先在代理服务器上得到授权 408——客户端没有在用户指定的饿时间内完成请求 409——对当前资源状态，请求不能完成 410——服务器上不再有此资源且无进一步的参考地址 411——服务器拒绝用户定义的Content-Length属性请求 412——一个或多个请求头字段在当前请求中错误 413——请求的资源大于服务器允许的大小 414——请求的资源URL长于服务器允许的长度 415——请求资源不支持请求项目格式 416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段 417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求 合起来 500——服务器产生内部错误 501——服务器不支持请求的函数 502——服务器暂时不可用，有时是为了防止发生系统过载 503——服务器过载或暂停维修 504——关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长 505——服务器不支持或拒绝支请求头中指定的HTTP版本 1xx:信息响应类，表示接收到请求并且继续处理 2xx:处理成功响应类，表示动作被成功接收、理解和接受 3xx:重定向响应类，为了完成指定的动作，必须接受进一步处理 4xx:客户端错误，客户请求包含语法错误或者是不能正确执行 5xx:服务端错误，服务器不能正确执行一个正确的请求 xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200的解释：请求完成并且成功返回","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"}],"author":"alone"},{"title":"12种不宜使用的Javascript语法","slug":"12种不宜使用的Javascript语法","date":"2019-04-25T16:00:00.000Z","updated":"2019-05-12T03:46:35.827Z","comments":true,"path":"2019/04/26/12种不宜使用的Javascript语法/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/04/26/12种不宜使用的Javascript语法/","excerpt":"","text":"​ 该书的作者是Douglas Crockford，他是目前世界上最精通Javascript的人之一，也是Json格式的创造者。 ​ 他认为Javascript有很多糟粕。因为1995年Brendan Eich设计这种语言的时候，只用了三个月，很多语言特性没有经过深思熟虑，就推向了市场。结果等到人们意识到这些问题的时候，已经有100万程序员在使用它了，不可能再大幅修改语言本身了。所以，Douglas Crockford决定，他要告诉大家，Javascript中哪些部分是精粹，哪些部分是糟粕和鸡肋。 ​ 这个想法非常好，但是我不得不说，这本书写得不够好，不适合新手阅读。原因如下：1）Douglas Crockford叙述得不清晰，更像与同行讨论问题，而不是由浅入深地讲解问题。这本书的重点不是解释，所以读完后，我觉得Javascript好像变得更复杂了。2）他固执地使用铁路图（railroad diagram）解释每一条语句。全世界似乎只有他一个人使用这种比Javascript更难看懂的图。3）该书基本上是一本简化的Javascript语法手册，缺乏足够的新内容。4）该书举例过少，而且在最难的函数和对象部分，使用的例子都是环环相套、层层递进的例子，导致阅读起来很吃力。 ​ 该书最有价值的内容不是正文，反而是附录。在附录B中，Douglas Crockford列出了12种应该避免使用的Javascript语法，我觉得非常值得推广。 ============================== 1. ==​ Javascript有两组相等运算符，一组是==和!=，另一组是===和!==。前者只比较值的相等，后者除了值以外，还比较类型是否相同。 ​ 请尽量不要使用前一组，永远只使用===和!==。因为==默认会进行类型转换，规则十分难记。如果你不相信的话，请回答下面五个判断式的值是true还是false： false == ‘false’ false == undefined false == null null == undefined 0 == ‘’ 前三个是false，后两个是true。 2. withwith的本意是减少键盘输入。比如 obj.a = obj.b; obj.c = obj.d; 可以简写成 with(obj) { a = b; c = d; } 但是，在实际运行时，解释器会首先判断obj.b和obj.d是否存在，如果不存在的话，再判断全局变量b和d是否存在。这样就导致了低效率，而且可能会导致意外，因此最好不要使用with语句。 3. eval### eval用来直接执行一个字符串。这条语句也是不应该使用的，因为它有性能和安全性的问题，并且使得代码更难阅读。 eval能够做到的事情，不用它也能做到。比如 eval(“myValue = myObject.” + myKey + “;”); 可以直接写成 myValue = myObject[myKey]; 至于ajax操作返回的json字符串，可以使用官方网站提供的解析器json_parse.js运行。 4. continue这条命令的作用是返回到循环的头部，但是循环本来就会返回到头部。所以通过适当的构造，完全可以避免使用这条命令，使得效率得到改善。 5. switch 贯穿switch结构中的case语句，默认是顺序执行，除非遇到break，return和throw。有的程序员喜欢利用这个特点，比如 switch(n) { case 1: case 2: break; } 这样写容易出错，而且难以发现。因此建议避免switch贯穿，凡是有case的地方，一律加上break。 switch(n) { case 1: break; case 2: break; } 6. 单行的块结构if、while、do和for，都是块结构语句，但是也可以接受单行命令。比如 if (ok) t = true; 甚至写成 if (ok) t = true; 这样不利于阅读代码，而且将来添加语句时非常容易出错。建议不管是否只有一行命令，都一律加上大括号。 if (ok){ t = true; } 7. ++和–递增运算符++和递减运算符–，直接来自C语言，表面上可以让代码变得很紧凑，但是实际上会让代码看上去更复杂和更晦涩。因此为了代码的整洁性和易读性，不用为好。 8. 位运算符Javascript完全套用了Java的位运算符，包括按位与&amp;、按位或|、按位异或^、按位非~、左移&lt;&lt;、带符号的右移&gt;&gt;和用0补足的右移&gt;&gt;&gt;。 这套运算符针对的是整数，所以对Javascript完全无用，因为Javascript内部，所有数字都保存为双精度浮点数。如果使用它们的话，Javascript不得不将运算数先转为整数，然后再进行运算，这样就降低了速度。而且”按位与运算符”&amp;同”逻辑与运算符”&amp;&amp;，很容易混淆。 9. function语句在Javascript中定义一个函数，有两种写法： function foo() { } 和 var foo = function () { } 两种写法完全等价。但是在解析的时候，前一种写法会被解析器自动提升到代码的头部，因此违背了函数应该先定义后使用的要求，所以建议定义函数时，全部采用后一种写法。 10. 基本数据类型的包装对象Javascript的基本数据类型包括字符串、数字、布尔值，它们都有对应的包装对象String、Number和Boolean。所以，有人会这样定义相关值： new String(“Hello World”); new Number(2000); new Boolean(false); 这样写完全没有必要，而且非常费解，因此建议不要使用。 另外，new Object和new Array也不建议使用，可以用{}和[]代替。 11. new语句Javascript是世界上第一个被大量使用的支持Lambda函数的语言，本质上属于与Lisp同类的函数式编程语言。但是当前世界，90%以上的程序员都是使用面向对象编程。为了靠近主流，Javascript做出了妥协，采纳了类的概念，允许根据类生成对象。 类是这样定义的： var Cat = function (name) { this.name = name; this.saying = ‘meow’ ; } 然后，再生成一个对象 var myCat = new Cat(‘mimi’); 这种利用函数生成类、利用new生成对象的语法，其实非常奇怪，一点都不符合直觉。而且，使用的时候，很容易忘记加上new，就会变成执行函数，然后莫名其妙多出几个全局变量。所以，建议不要这样创建对象，而采用一种变通方法。 Douglas Crockford给出了一个函数： Object.beget = function (o) { var F = function (o) {}; F.prototype = o ; return new F; }; 创建对象时就利用这个函数，对原型对象进行操作： var Cat = { name:’’, saying:’meow’ }; var myCat = Object.beget(Cat); 对象生成后，可以自行对相关属性进行赋值： myCat.name = ‘mimi’; 12. void在大多数语言中，void都是一种类型，表示没有值。但是在Javascript中，void是一个运算符，接受一个运算数，并返回undefined。 void 0; // undefined 这个命令没什么用，而且很令人困惑，建议避免使用。 ​ 引用自阮一峰博客：http://www.ruanyifeng.com/blog/2010/01/12_javascript_syntax_structures_you_should_not_use.html","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"}],"author":"along"},{"title":"generator","slug":"generator","date":"2019-03-25T16:00:00.000Z","updated":"2019-05-12T03:46:35.909Z","comments":true,"path":"2019/03/26/generator/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/03/26/generator/","excerpt":"","text":"generator（生成器）是ES6标准引入的新的数据类型。一个generator看上去像一个函数，但可以返回多次。 ES6定义generator标准的哥们借鉴了Python的generator的概念和语法，如果你对Python的generator很熟悉，那么ES6的generator就是小菜一碟了。如果你对Python还不熟，赶快恶补Python教程！。 我们先复习函数的概念。一个函数是一段完整的代码，调用一个函数就是传入参数，然后返回结果： 12345function foo(x) &#123; return x + x;&#125;var r = foo(1); // 调用foo函数 函数在执行过程中，如果没有遇到return语句（函数末尾如果没有return，就是隐含的return undefined;），控制权无法交回被调用的代码。 generator跟函数很像，定义如下： 12345function* foo(x) &#123; yield x + 1; yield x + 2; return x + 3;&#125; generator和函数不同的是，generator由function*定义（注意多出的*号），并且，除了return语句，还可以用yield返回多次。 大多数同学立刻就晕了，generator就是能够返回多次的“函数”？返回多次有啥用？ 还是举个栗子吧。 我们以一个著名的斐波那契数列为例，它由0，1开头： 10 1 1 2 3 5 8 13 21 34 ... 要编写一个产生斐波那契数列的函数，可以这么写： 12345678910111213141516function fib(max) &#123; var t, a = 0, b = 1, arr = [0, 1]; while (arr.length &lt; max) &#123; [a, b] = [b, a + b]; arr.push(b); &#125; return arr;&#125;// 测试:fib(5); // [0, 1, 1, 2, 3]fib(10); // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] 函数只能返回一次，所以必须返回一个Array。但是，如果换成generator，就可以一次返回一个数，不断返回多次。用generator改写如下： 12345678910111213function* fib(max) &#123; var t, a = 0, b = 1, n = 0; while (n &lt; max) &#123; yield a; [a, b] = [b, a + b]; n ++; &#125; return;&#125; 直接调用试试： 1fib(5); // fib &#123;[[GeneratorStatus]]: &quot;suspended&quot;, [[GeneratorReceiver]]: Window&#125; 直接调用一个generator和调用函数不一样，fib(5)仅仅是创建了一个generator对象，还没有去执行它。 调用generator对象有两个方法，一是不断地调用generator对象的next()方法： 1234567var f = fib(5);f.next(); // &#123;value: 0, done: false&#125;f.next(); // &#123;value: 1, done: false&#125;f.next(); // &#123;value: 1, done: false&#125;f.next(); // &#123;value: 2, done: false&#125;f.next(); // &#123;value: 3, done: false&#125;f.next(); // &#123;value: undefined, done: true&#125; next()方法会执行generator的代码，然后，每次遇到yield x;就返回一个对象{value: x, done: true/false}，然后“暂停”。返回的value就是yield的返回值，done表示这个generator是否已经执行结束了。如果done为true，则value就是return的返回值。 当执行到done为true时，这个generator对象就已经全部执行完毕，不要再继续调用next()了。 第二个方法是直接用for ... of循环迭代generator对象，这种方式不需要我们自己判断done： &#39;use strict&#39; function* fib(max) { var t, a = 0, b = 1, n = 0; while (n &lt; max) { yield a; [a, b] = [b, a + b]; n ++; } return; } Run generator和普通函数相比，有什么用？ 因为generator可以在执行过程中多次返回，所以它看上去就像一个可以记住执行状态的函数，利用这一点，写一个generator就可以实现需要用面向对象才能实现的功能。例如，用一个对象来保存状态，得这么写： 12345678910111213141516171819var fib = &#123; a: 0, b: 1, n: 0, max: 5, next: function () &#123; var r = this.a, t = this.a + this.b; this.a = this.b; this.b = t; if (this.n &lt; this.max) &#123; this.n ++; return r; &#125; else &#123; return undefined; &#125; &#125;&#125;; 用对象的属性来保存状态，相当繁琐。 generator还有另一个巨大的好处，就是把异步回调代码变成“同步”代码。这个好处要等到后面学了AJAX以后才能体会到。 没有generator之前的黑暗时代，用AJAX时需要这么写代码： 12345678910111213141516ajax(&apos;http://url-1&apos;, data1, function (err, result) &#123; if (err) &#123; return handle(err); &#125; ajax(&apos;http://url-2&apos;, data2, function (err, result) &#123; if (err) &#123; return handle(err); &#125; ajax(&apos;http://url-3&apos;, data3, function (err, result) &#123; if (err) &#123; return handle(err); &#125; return success(result); &#125;); &#125;);&#125;); 回调越多，代码越难看。 有了generator的美好时代，用AJAX时可以这么写： 123456789try &#123; r1 = yield ajax(&apos;http://url-1&apos;, data1); r2 = yield ajax(&apos;http://url-2&apos;, data2); r3 = yield ajax(&apos;http://url-3&apos;, data3); success(r3);&#125;catch (err) &#123; handle(err);&#125; 看上去是同步的代码，实际执行是异步的。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"}],"author":"alone"},{"title":"前端工程","slug":"前端工程(基础)","date":"2019-03-06T16:00:00.000Z","updated":"2019-05-12T03:46:35.929Z","comments":true,"path":"2019/03/07/前端工程(基础)/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/03/07/前端工程(基础)/","excerpt":"","text":"喂喂喂，那个切图的，把页面写好就发给研发工程师套模板吧。 你好，切图仔。 不知道你的团队如何定义前端开发，据我所知，时至今日仍然有很多团队会把前端开发归类为产品或者设计岗位，虽然身份之争多少有些无谓，但我对这种偏见还是心存芥蒂，酝酿了许久，决定写一个系列的文章，试着从工程的角度系统的介绍一下我对前端，尤其是Web前端的理解。 只要我们还把自己的工作看作为一项软件开发活动，那么我相信读过下面的内容你也一定会有所共鸣。 前端，是一种GUI软件现如今前端可谓包罗万象，产品形态五花八门，涉猎极广，什么高大上的基础库/框架，拽炫酷的宣传页面，还有屌炸天的小游戏……不过这些一两个文件的小项目并非是前端技术的主要应用场景，更具商业价值的则是复杂的Web应用，它们功能完善，界面繁多，为用户提供了完整的产品体验，可能是新闻聚合网站，可能是在线购物平台，可能是社交网络，可能是金融信贷应用，可能是音乐互动社区，也可能是视频上传与分享平台…… 从本质上讲，所有Web应用都是一种运行在网页浏览器中的软件，这些软件的图形用户界面（Graphical User Interface，简称GUI）即为前端。 如此复杂的Web应用，动辄几十上百人共同开发维护，其前端界面通常也颇具规模，工程量不亚于一般的传统GUI软件： 尽管Web应用的复杂程度与日俱增，用户对其前端界面也提出了更高的要求，但时至今日仍然没有多少前端开发者会从软件工程的角度去思考前端开发，来助力团队的开发效率，更有甚者还对前端保留着”如玩具般简单“的刻板印象，日复一日，刀耕火种。 历史悠久的前端开发，始终像是放养的野孩子，原始如斯，不免让人慨叹！ 前端工程的三个阶段现在的前端开发倒也并非一无所有，回顾一下曾经经历过或听闻过的项目，为了提升其前端开发效率和运行性能，前端团队的工程建设大致会经历三个阶段： 第一阶段：库/框架选型 前端工程建设的第一项任务就是根据项目特征进行技术选型。 基本上现在没有人完全从0开始做网站，哪怕是政府项目用个jquery都很正常吧，React/Angularjs等框架横空出世，解放了不少生产力，合理的技术选型可以为项目节省许多工程量这点毋庸置疑。 第二阶段：简单构建优化 选型之后基本上就可以开始敲码了，不过光解决开发效率还不够，必须要兼顾运行性能。前端工程进行到第二阶段会选型一种构建工具，对代码进行压缩，校验，之后再以页面为单位进行简单的资源合并。 前端开发工程化程度之低，常常出乎我的意料，我之前在百度工作时是没有多少概念的，直到离开大公司的温室，去到业界与更多的团队交流才发现，能做到这个阶段在业界来说已然超出平均水平，属于“具备较高工程化程度”的团队了，查看网上形形色色的网页源代码，能做到最基本的JS/CSS压缩的Web应用都已跨入标准互联网公司行列，不难理解为什么很多前端团队对于前端工程构建的认知还仅停留在“压缩、校验、合并”这种程度。 第三阶段：JS/CSS模块化开发 分而治之是软件工程中的重要思想，是复杂系统开发和维护的基石，这点放在前端开发中同样适用。在解决了基本开发效率运行效率问题之后，前端团队开始思考维护效率，模块化是目前前端最流行的分治手段。 很多人觉得模块化开发的工程意义是复用，我不太认可这种看法，在我看来，模块化开发的最大价值应该是分治，是分治，分治！（重说三）。 不管你将来是否要复用某段代码，你都有充分的理由将其分治为一个模块。 JS模块化方案很多，AMD/CommonJS/UMD/ES6 Module等，对应的框架和工具也一大堆，说起来很烦，大家自行百度吧；CSS模块化开发基本都是在less、sass、stylus等预处理器的import/mixin特性支持下实现的。 虽然这些技术由来已久，在如今这个“言必及React”的时代略显落伍，但想想业界的绝大多数团队的工程化落后程度，放眼望去，毫不夸张的说，能达到第三阶段的前端团队已属于高端行列，基本具备了开发维护一般规模Web应用的能力。 然而，做到这些就够了么？Naive！ 第四阶段 前端是一种技术问题较少、工程问题较多的软件开发领域。 当我们要开发一款完整的Web应用时，前端将面临更多的工程问题，比如： 大体量：多功能、多页面、多状态、多系统； 大规模：多人甚至多团队合作开发； 高性能：CDN部署、缓存控制、文件指纹、缓存复用、请求合并、按需加载、同步/异步加载、移动端首屏CSS内嵌、HTTP 2.0服务端资源推送。 扩展阅读：大公司里怎样开发和部署前端代码？ 这些无疑是一系列严肃的系统工程问题。 前面讲的三个阶段虽然相比曾经“茹毛饮血”的时代进步不少，但用于支撑第四阶段的多人合作开发以及精细的性能优化似乎还欠缺点什么。 到底，缺什么呢？ 没有银弹读过《人月神话》的人应该都听说过，软件工程 没有银弹。没错，前端开发同样没有银弹，可是现在是连™铅弹都没有的年月！（刚有了BB弹，摔） 前端历来以“简单”著称，在前端开发者群体中，小而美的价值观占据着主要的话语权，甚至成为了某种信仰，想与其他人交流一下工程方面的心得，得到的回应往往都是两个字：太重。 重你妹！你的脑容量只有4K吗？ 工程方案其实也可以小而美！只不过它的小而美不是指代码量，而是指“规则”。找到问题的根源，用最少最简单明了的规则制定出最容易遵守最容易理解的开发规范或工具，以提升开发效率和工程质量，这同样是小而美的典范！ 2011年我有幸参与到 FIS 项目中，与百度众多大中型项目的前端研发团队共同合作，不断探索实践前端开发的工程化解决方案，13年离开百度去往UC，面对完全不同的产品形态，不同的业务场景，不同的适配终端，甚至不同的网络环境，过往的方法论仍然能够快速落地，为多个团队的不同业务场景量身定制出合理的前端解决方案。 这些经历让我明悟了一个道理： 进入第四阶段，我们只需做好两件事就能大幅提升前端开发效率，并且兼顾运行性能，那就是——组件化开发与资源管理。 第一件事：组件化开发分治的确是非常重要的工程优化手段。在我看来，前端作为一种GUI软件，光有JS/CSS的模块化还不够，对于UI组件的分治也有着同样迫切的需求： 如上图，这是我所信仰的前端组件化开发理念，简单解读一下： 页面上的每个 独立的 可视/可交互区域视为一个组件； 每个组件对应一个工程目录，组件所需的各种资源都在这个目录下就近维护； 由于组件具有独立性，因此组件与组件之间可以 自由组合； 页面只不过是组件的容器，负责组合组件形成功能完整的界面； 当不需要某个组件，或者想要替换组件时，可以整个目录删除/替换。 其中第二项描述的就近维护原则，是我觉得最具工程价值的地方，它为前端开发提供了很好的分治策略，每个开发者都将清楚的知道，自己所开发维护的功能单元，其代码必然存在于对应的组件目录中，在那个目录下能找到有关这个功能单元的所有内部逻辑，样式也好，JS也好，页面结构也好，都在那里。 组件化开发具有较高的通用性，无论是前端渲染的单页面应用，还是后端模板渲染的多页面应用，组件化开发的概念都能适用。组件HTML部分根据业务选型的不同，可以是静态的HTML文件，可以是前端模板，也可以是后端模板： 不同的技术选型决定了不同的组件封装和调用策略。 基于这样的工程理念，我们很容易将系统以独立的组件为单元进行分工划分： 由于系统功能被分治到独立的模块或组件中，粒度比较精细，组织形式松散，开发者之间不会产生开发时序的依赖，大幅提升并行的开发效率，理论上允许随时加入新成员认领组件开发或维护工作，也更容易支持多个团队共同维护一个大型站点的开发。 结合前面提到的模块化开发，整个前端项目可以划分为这么几种开发概念： 名称 说明 举例 JS模块 独立的算法和数据单元 浏览器环境检测(detect)，网络请求(ajax)，应用配置(config)，DOM操作(dom)，工具函数(utils)，以及组件里的JS单元 CSS模块 独立的功能性样式单元 栅格系统(grid)，字体图标(icon-fonts)，动画样式(animate)，以及组件里的CSS单元 UI组件 独立的可视/可交互功能单元 页头(header)，页尾(footer)，导航栏(nav)，搜索框(search) 页面 前端这种GUI软件的界面状态，是UI组件的容器 首页(index)，列表页(list)，用户管理(user) 应用 整个项目或整个站点被称之为应用，由多个页面组成 以上5种开发概念以相对较少的规则组成了前端开发的基本工程结构，基于这些理念，我眼中的前端开发就成了这个样子： 示意图 描述 整个Web应用由页面组成 页面由组件组成 一个组件一个目录，资源就近维护 组件可组合， 组件的JS可依赖其他JS模块， CSS可依赖其他CSS单元 综合上面的描述，对于一般中小规模的项目，大致可以规划出这样的源码目录结构： 如果项目规模较大，涉及多个团队协作，还可以将具有相关业务功能的页面组织在一起，形成一个子系统，进一步将整个站点拆分出多个子系统来分配给不同团队维护，针对这种情况后面我会单开文章详细介绍。 以上架构设计历经许多不同公司不同业务场景的前端团队验证，收获了不错的口碑，是行之有效的前端工程分治方案。 吐槽：我本人非常反对某些前端团队将前端开发划分为“JS开发”和“页面重构”两种岗位，更倾向于组件粒度的开发理念，对GUI软件开发的分工规划应该以功能为单位，而不是开发语言；对开发者的技术要求也应该是掌握完整的端内技术。 第二件事：“智能”静态资源管理上面提到的模块化/组件化开发，仅仅描述了一种开发理念，也可以认为是一种开发规范，倘若你认可这规范，对它的分治策略产生了共鸣，那我们就可以继续聊聊它的具体实现了。 很明显，模块化/组件化开发之后，我们最终要解决的，就是模块/组件加载的技术问题。然而前端与客户端GUI软件有一个很大的不同： 前端是一种远程部署，运行时增量下载的GUI软件 前端应用没有安装过程，其所需程序资源都部署在远程服务器，用户使用浏览器访问不同的页面来加载不同的资源，随着页面访问的增加，渐进式的将整个程序下载到本地运行，“增量下载”是前端在工程上有别于客户端GUI软件的根本原因。 上图展示了一款界面繁多功能丰富的应用，如果采用Web实现，相信也是不小的体量，如果用户第一次访问页面就强制其加载全站静态资源再展示，相信会有很多用户因为失去耐心而流失。根据“增量”的原则，我们应该精心规划每个页面的资源加载策略，使得用户无论访问哪个页面都能按需加载页面所需资源，没访问过的无需加载，访问过的可以缓存复用，最终带来流畅的应用体验。 这正是Web应用“免安装”的魅力所在。 由“增量”原则引申出的前端优化技巧几乎成为了性能优化的核心，有加载相关的按需加载、延迟加载、预加载、请求合并等策略；有缓存相关的浏览器缓存利用，缓存更新、缓存共享、非覆盖式发布等方案；还有复杂的BigRender、BigPipe、Quickling、PageCache等技术。这些优化方案无不围绕着如何将增量原则做到极致而展开。 所以我觉得： 第四阶段前端开发最迫切需要做好的就是在基础架构中贯彻增量原则。 相信这种贯彻不会随着时间的推移而改变，在可预见的未来，无论在HTTP1.x还是HTTP2.0时代，无论在ES5亦或者ES6/7时代，无论是AMD/CommonJS/UMD亦或者ES6 module时代，无论端内技术如何变迁，我们都有足够充分的理由要做好前端程序资源的增量加载。 正如前面说到的，第三阶段前端工程缺少点什么呢？我觉得是在其基础架构中缺少这样一种“智能”的资源加载方案。没有这样的方案，很难将前端应用的规模发展到第四阶段，很难实现落地前面介绍的那种组件化开发方案，也很难让多方合作高效率的完成一项大型应用的开发，并保证其最终运行性能良好。在第四阶段，我们需要强大的工程化手段来管理”玩具般简单“的前端开发。 在我的印象中，Facebook是这方面探索的伟大先驱之一，早在2010年的Velocity China大会上，来自Facebook的David Wei博士就为业界展示了他们令人惊艳的静态网页资源管理和优化技术。 David Wei博士在当年的交流会上提到过一些关于Facebook的一些产品数据： Facebook整站有10000+个静态资源； 每个静态资源都有可能被翻译成超过100种语言版本； 每种资源又会针对浏览器生成3种不同的版本； 要针对不同带宽的用户做5种不同的打包方法； 有3、4个不同的用户组，用于小批次体验新的产品功能； 还要考虑不同的送达方法，可以直接送达，或者通过iframe的方式提升资源并行加载的速度； 静态资源的压缩和非压缩状态可切换，用于调试和定位线上问题 这是一个状态爆炸的问题，将所有状态乘起来，整个网站的资源组合方式会达到几百万种之多（去重之后统计大概有300万种组合方式）。支撑这么大规模前端项目运行的底层架构正是魏博士在那次演讲中分享的Static Resource Management System(静态资源管理系统)，用以解决Facebook项目中有关前端工程的3D问题（Development，Deployment，Debugging）。 那段时间 FIS 项目正好遇到瓶颈，当时的FIS还是一个用php写的task-based构建工具，那时候对于前端工程的认知度很低，觉得前端构建不就是几个压缩优化校验打包任务的组合吗，写好流程调度，就针对不同需求写插件呗，看似非常简单。但当我们支撑越来越多的业务团队，接触到各种不同的业务场景时，我们深刻的感受到task-based工具的粗糙，团队每天疲于根据各种业务场景编写各种打包插件，构建逻辑异常复杂，隐隐看到不可控的迹象。 我们很快意识到把基础架构放到构建工具中实现是一件很愚蠢的事，试图依靠构建工具实现各种优化策略使得构建变成了一个巨大的黑盒，一旦发生问题，定位起来非常困难，而且每种业务场景都有不同的优化需求，构建工具只能通过静态分析来优化加载，具有很大的局限性，单页面/多页面/PC端/移动端/前端渲染/后端渲染/多语言/多皮肤/高级优化等等资源加载问题，总不能给每个都写一套工具吧，更何况这些问题彼此之间还可以有多种组合应用，工具根本写不过来。 Facebook的做法无疑为我们亮起了一盏明灯，不过可惜它并不开源（不是技术封锁，而是这个系统依赖FB体系中的其他方面，通用性不强，开源意义不大），我们只能尝试挖掘相关信息，网上对它的完整介绍还是非常非常少，分析facebook的前端代码也没有太多收获，后来无意中发现了facebook使用的项目管理工具phabricator中的一个静态管理方案Celerity，以及相关的说明，看它的描述很像是Facebook静态资源管理系统的一个mini版！ 简单看过整个系统之后发现原理并不复杂（小而美的典范），它是通过一个小工具扫描所有静态资源，生成一张资源表，然后有一个PHP实现的资源管理框架（Celerity）提供了资源加载接口，替代了传统的script/link等静态的资源加载标签，最终通过查表来加载资源。 虽然没有真正看过FB的那套系统，但眼前的这个小小的框架给了当时的我们足够多的启示： 静态资源管理系统 = 资源表 + 资源加载框架 多么优雅的实现啊！ 资源表是一份数据文件（比如JSON），是项目中所有静态资源（主要是JS和CSS）的构建信息记录，通过构建工具扫描项目源码生成，是一种k-v结构的数据，以每个资源的id为key，记录了资源的类别、部署路径、依赖关系、打包合并等内容，比如： 12345678910111213141516&#123; &quot;a.js&quot;: &#123; &quot;url&quot;: &quot;/static/js/a.5f100fa.js&quot;, &quot;dep&quot;: [ &quot;b.js&quot;, &quot;a.css&quot; ] &#125;, &quot;a.css&quot;: &#123; &quot;url&quot;: &quot;/static/css/a.63cf374.css&quot;, &quot;dep&quot;: [ &quot;button.css&quot; ] &#125;, &quot;b.js&quot;: &#123; &quot;url&quot;: &quot;/static/js/b.97193bf.js&quot; &#125;, &quot;button.css&quot;: &#123; &quot;url&quot;: &quot;/static/css/button.de33108.css&quot; &#125;&#125; 而资源加载框架则提供一些资源引用的API，让开发者根据id来引用资源，替代静态的script/link标签来收集、去重、按需加载资源。调用这些接口时，框架通过查表来查找资源的各项信息，并递归查找其依赖的资源的信息，然后我们可以在这个过程中实现各种性能优化算法来“智能”加载资源。 根据业务场景的不同，加载框架可以在浏览器中用JS实现，也可以是后端模板引擎中用服务端语言实现，甚至二者的组合，不一而足。 有关加载框架的具体实现我曾写过很多文章介绍，可以扩展阅读： 前端工程与性能优化 前端工程与模块化框架 这种设计很快被验证具有足够的灵活性，能够完美支撑不同团队不同技术规范下的性能优化需求，前面提到的按需加载、延迟加载、预加载、请求合并、文件指纹、CDN部署、Bigpipe、Quickling、BigRender、首屏CSS内嵌、HTTP 2.0服务端推送等等性能优化手段都可以很容易的在这种架构上实现，甚至可以根据性能日志自动进行优化（Facebook已实现）。 因为有了资源表，我们可以很方便的控制资源加载，通过各种手段在运行时计算页面的资源使用情况，从而获得最佳加载性能。无论是前端渲染的单页面应用，还是后端渲染的多页面应用，这种方法都同样适用。 此外，它还很巧妙的约束了构建工具的职责——只生成资源表。资源表是非常通用的数据结构，无论什么业务场景，其业务代码最终都可以被扫描为相同结构的表数据，并标记资源间的依赖关系，有了表之后我们只需根据不同的业务场景定制不同的资源加载框架就行了，从此彻底告别一个团队维护一套工具的时代！！！ 恩，如你所见，虽然彻底告别了一个团队一套工具的时代，但似乎又进入了一个团队一套框架的时代。其实还是有差别的，因为框架具有很大的灵活性，而且不那么黑盒，采用框架实现资源管理相比构建更容易调试、定位和升级变更。 深耕静态资源加载框架可以带来许多收益，而且有足够的灵活性和健壮性面向未来的技术变革，这个我们留作后话。 总结回顾一下前面提到过的前端工程三个阶段： 第一阶段：库/框架选型 第二阶段：简单构建优化 第三阶段：JS/CSS模块化开发 现在补充上第四阶段： 第四阶段：组件化开发与资源管理 由于先天缺陷，前端相比其他软件开发，在基础架构上更加迫切的需要组件化开发和资源管理，而解决资源管理的方法其实一点也不复杂： 一个通用的资源表生成工具 + 基于表的资源加载框架 近几年来各种你听到过的各种资源加载优化策略大部分都可以在这样一套基础上实现，而这种优化对于业务来说是完全透明的，不需要重构的性能优化——这不正是我们一直所期盼的吗？正如魏小亮博士所说：我们可以把优秀的人集中起来去优化加载。 如何选型技术、如何定制规范、如何分治系统、如何优化性能、如何加载资源，当你从切图开始转变为思考这些问题的时候，我想说： 你好，工程师！","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"}],"author":"along"},{"title":"前端工程与性能优化","slug":"前端工程与性能优化","date":"2019-03-04T16:00:00.000Z","updated":"2019-05-12T03:46:35.930Z","comments":true,"path":"2019/03/05/前端工程与性能优化/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/03/05/前端工程与性能优化/","excerpt":"","text":"优化方向 优化手段 请求数量 合并脚本和样式表，CSS Sprites，拆分初始化负载，划分主域 请求带宽 开启GZip，精简JavaScript，移除重复脚本，图像优化 缓存利用 使用CDN，使用外部JavaScript和CSS，添加Expires头，减少DNS查找，配置ETag，使AjaX可缓存 页面结构 将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出 代码校验 避免CSS表达式，避免重定向 链接地址： fouber/blog#10 http://velocity.oreilly.com.cn/2010/index.php?func=session&amp;name=%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E8%B5%84%E6%BA%90%E7%9A%84%E7%AE%A1%E7%90%86%E5%92%8C%E4%BC%98%E5%8C%96","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"}],"author":"along"},{"title":"前端演变的理解","slug":"前端演变的理解","date":"2019-03-01T16:00:00.000Z","updated":"2019-05-12T03:46:35.931Z","comments":true,"path":"2019/03/02/前端演变的理解/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/03/02/前端演变的理解/","excerpt":"","text":"什么是前端web应用是一种运行在浏览器中的软件，这些软件的图形用户界面（Graphical User Interface, 即GUI）称为前端。（前端是一种GUI应用） 前后端不分离时代 web1.0早期，前后端开发是一体的，网站开发采用后端为主的mvc模式，前端相当于后端的view层。前端的主要工作是编写页面模板，后端代码根据浏览器请求，读取模板，替换变量，生成静态页面，发送给浏览器。 Ajax技术诞生 web2.0 AJAX不是JavaScript的规范，Asynchronous JavaScript and XML，意思就是用JavaScript执行异步网络请求。 2005年 Ajax 正式提出，前后端分工逐渐清晰，前后端协作的关键是Ajax接口。前端不再是后端的模板，前后端分离，网页也从静态网页转为动态网页。前端开始逐渐复杂。 前端mv*为了降低前端开发的复杂度，出现了大量前端MV*框架比如Backbone，KnockoutJS、AngularJS 等等，对代码进行合理的分层，如models，controllers，view，viewmodel等，让代码各施其职。 前端工程化随着前后端分工的清晰，前端工作的复杂度的增高，开始出现了前端工程化的概念，前端工程化分为几个阶段 技术选型 构建优化 js/css模块化 组件化开发与资源管理 构建优化比如grunt，gulp，对网站资源进行优化如代码压缩，校验，资源合并，对简化前端开发中很多复杂重复的工作，提高开发效率，和执行运行性能。 模块化js的模块化方案很多，如AMD/CommonJS/ES6 Module等css的模块化主要是靠less，sass，stylus等预处理器的import/mixin来支持实现模块化打包工具webpack，parcel，browserify等等 模块化的主要思想在于分而治之，是复杂系统开发和维护的基石。将一个复杂的应用，分成多个更小的部分进行开发与维护，最后再由每一个模块相互作用构成我们的整个应用。 组件化和资源管理组件化也是对分治思想的一种实践，前端作为一种GUI软件，在大型应用中还需要对ui进行组件化开发 页面上每个独立的可视/可交互区域为一个组件 组件间可以自由组合，替换 页面为组件的容器 静态资源管理目前大多数的前端应用都是远程部署，运行时增量下载的GUI软件由“增量”原则引申出的前端优化技巧几乎成为了性能优化的核心，有加载相关的按需加载、延迟加载、预加载、请求合并等策略；有缓存相关的浏览器缓存利用，缓存更新、缓存共享、非覆盖式发布等方案等等有关前端工程化更详细的了解可到 前端工程 了解 大前端随着nodejs的出现，JavaScript的覆盖范围扩大，大前端的概念也开始出现。大前端的原始定义可以定义为前端技术的扩大化。再后来react native的出现，JavaScript的覆盖范围再一次扩大，拥有了开发跨平台app的能力，大前端的概念进一步加深。前端的工作不再局限于“前端”，必要时时兼顾后端和移动端开发。 总结所以我认为现在的前端应该具备的技术有： html，css，JavaScript过硬的基础。 了解模块化，工程化 深入学习一门JavaScript框架 gulp等自动化构建工具 webpack等模块化资源打包工具 scss，es6等提高生成效率的工具 一门后端语言 有能力的话学习如react native等跨平台技术 作者：holyZheng https://github.com/HolyZheng/holyZheng-blog/issues/1","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"}],"author":"along"},{"title":"错误处理","slug":"错误处理","date":"2019-02-25T16:00:00.000Z","updated":"2019-05-12T03:46:35.937Z","comments":true,"path":"2019/02/26/错误处理/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/02/26/错误处理/","excerpt":"","text":"错误处理在执行JavaScript代码的时候，有些情况下会发生错误。 错误分两种，一种是程序写的逻辑不对，导致代码执行异常。例如： 12var s = null;var len = s.length; // TypeError：null变量没有length属性 对于这种错误，要修复程序。 一种是执行过程中，程序可能遇到无法预测的异常情况而报错，例如，网络连接中断，读取不存在的文件，没有操作权限等。 对于这种错误，我们需要处理它，并可能需要给用户反馈。 错误处理是程序设计时必须要考虑的问题。对于C这样贴近系统底层的语言，错误是通过错误码返回的： 123456int fd = open(&quot;/path/to/file&quot;, O_RDONLY);if (fd == -1) &#123; printf(&quot;Error when open file!&quot;);&#125; else &#123; // TODO&#125; 通过错误码返回错误，就需要约定什么是正确的返回值，什么是错误的返回值。上面的open()函数约定返回-1表示错误。 显然，这种用错误码表示错误在编写程序时十分不便。 因此，高级语言通常都提供了更抽象的错误处理逻辑try … catch … finally，JavaScript也不例外。 try … catch … finally使用try … catch … finally处理错误时，我们编写的代码如下： &#39;use strict&#39;; `// 直接运行` 1234567891011var r1, r2, s = null;try &#123; r1 = s.length; // 此处应产生错误 r2 = 100; // 该语句不会执行&#125; catch (e) &#123; console.log('出错了：' + e);&#125; finally &#123; console.log('finally');&#125;console.log('r1 = ' + r1); // r1应为undefinedconsole.log('r2 = ' + r2); // r2应为undefined 1234出错了：TypeError: Cannot read property 'length' of nullfinallyr1 = undefinedr2 = undefined 运行后可以发现，输出提示类似“出错了：TypeError: Cannot read property ‘length’ of null”。 我们来分析一下使用try … catch … finally的执行流程。 当代码块被try { ... }包裹的时候，就表示这部分代码执行过程中可能会发生错误，一旦发生错误，就不再继续执行后续代码，转而跳到catch块。catch (e) { ... }包裹的代码就是错误处理代码，变量e表示捕获到的错误。最后，无论有没有错误，finally一定会被执行。 所以，有错误发生时，执行流程像这样： 先执行try { ... }的代码； 执行到出错的语句时，后续语句不再继续执行，转而执行catch (e) { ... }代码； 最后执行finally { ... }代码。 而没有错误发生时，执行流程像这样： 先执行try { ... }的代码； 因为没有出错，catch (e) { ... }代码不会被执行； 最后执行finally { ... }代码。 最后请注意，catch和finally可以不必都出现。也就是说，try语句一共有三种形式： 完整的try … catch … finally： 1234567try &#123; ...&#125; catch (e) &#123; ...&#125; finally &#123; ...&#125; 只有try … catch，没有finally： 12345try &#123; ...&#125; catch (e) &#123; ...&#125; 只有try … finally，没有catch： 12345try &#123; ...&#125; finally &#123; ...&#125; 错误类型JavaScript有一个标准的Error对象表示错误，还有从Error派生的TypeError、ReferenceError等错误对象。我们在处理错误时，可以通过catch(e)捕获的变量e访问错误对象： 1234567891011try &#123; ...&#125; catch (e) &#123; if (e instanceof TypeError) &#123; alert(&apos;Type error!&apos;); &#125; else if (e instanceof Error) &#123; alert(e.message); &#125; else &#123; alert(&apos;Error: &apos; + e); &#125;&#125; 使用变量e是一个习惯用法，也可以以其他变量名命名，如catch(ex)。 抛出错误程序也可以主动抛出一个错误，让执行流程直接跳转到catch块。抛出错误使用throw语句。 例如，下面的代码让用户输入一个数字，程序接收到的实际上是一个字符串，然后用parseInt()转换为整数。当用户输入不合法的时候，我们就抛出错误： &#39;use strict&#39;; `// 直接运行 ` Run 12345678910111213var r, n, s;try &#123; s = prompt('请输入一个数字'); n = parseInt(s); if (isNaN(n)) &#123; throw new Error('输入错误'); &#125; // 计算平方: r = n * n; console.log(n + ' * ' + n + ' = ' + r);&#125; catch (e) &#123; console.log('出错了：' + e);&#125; 1出错了：Error: 输入错误 实际上，JavaScript允许抛出任意对象，包括数字、字符串。但是，最好还是抛出一个Error对象。 最后，当我们用catch捕获错误时，一定要编写错误处理语句： 1234567var n = 0, s;try &#123; n = s.length;&#125; catch (e) &#123; console.log(e);&#125;console.log(n); 哪怕仅仅把错误打印出来，也不要什么也不干： 123456var n = 0, s;try &#123; n = s.length;&#125; catch (e) &#123;&#125;console.log(n); 因为catch到错误却什么都不执行，就不知道程序执行过程中到底有没有发生错误。 处理错误时，请不要简单粗暴地用alert()把错误显示给用户。教程的代码使用alert()是为了便于演示。 异步错误处理：编写JavaScript代码时，我们要时刻牢记，JavaScript引擎是一个事件驱动的执行引擎，代码总是以单线程执行，而回调函数的执行需要等到下一个满足条件的事件出现后，才会被执行。 例如，setTimeout()函数可以传入回调函数，并在指定若干毫秒后执行： 123456function printTime() &#123; console.log(&apos;It is time!&apos;);&#125;setTimeout(printTime, 1000);console.log(&apos;done&apos;); 上面的代码会先打印done，1秒后才会打印It is time!。 如果printTime()函数内部发生了错误，我们试图用try包裹setTimeout()是无效的： 123456789101112function printTime() &#123; throw new Error();&#125;try &#123; setTimeout(printTime, 1000); console.log('done');&#125; catch (e) &#123; console.log('error');&#125;//done 原因就在于调用setTimeout()函数时，传入的printTime函数并未立刻执行！紧接着，JavaScript引擎会继续执行console.log(&#39;done&#39;);语句，而此时并没有错误发生。直到1秒钟后，执行printTime函数时才发生错误，但此时除了在printTime函数内部捕获错误外，外层代码并无法捕获。 所以，涉及到异步代码，无法在调用时捕获，原因就是在捕获的当时，回调函数并未执行。 类似的，当我们处理一个事件时，在绑定事件的代码处，无法捕获事件处理函数的错误。 例如，针对以下的表单： 1234&lt;form&gt; &lt;input id=\"x\"&gt; + &lt;input id=\"y\"&gt; &lt;button id=\"calc\" type=\"button\"&gt;计算&lt;/button&gt;&lt;/form&gt; 1234567891011121314151617try &#123; $btn.click(function () &#123; var x = parseFloat($('#x').val()), y = parseFloat($('#y').val()), r; if (isNaN(x) || isNaN(y)) &#123; throw new Error('输入有误'); &#125; r = x + y; alert('计算结果：' + r); &#125;);&#125; catch (e) &#123; alert('输入有误！');&#125;// 我们用下面的代码给button绑定click事件： 1234567891011121314151617'use strict'; var $btn = $('#calc'); // 取消已绑定的事件: $btn.off('click'); try &#123; $btn.click(function () &#123; var x = parseFloat($('#x').val()), y = parseFloat($('#y').val()), r; if (isNaN(x) || isNaN(y)) &#123; throw new Error('输入有误'); &#125; r = x + y; alert('计算结果：' + r); &#125;);&#125; catch (e) &#123; alert('输入有误！');&#125; 错误传播如果代码发生了错误，又没有被try … catch捕获，那么，程序执行流程会跳转到哪呢？ 12345678910function getLength(s) &#123; return s.length;&#125;function printLength() &#123; console.log(getLength(&apos;abc&apos;)); // 3 console.log(getLength(null)); // Error!&#125;printLength(); 如果在一个函数内部发生了错误，它自身没有捕获，错误就会被抛到外层调用函数，如果外层函数也没有捕获，该错误会一直沿着函数调用链向上抛出，直到被JavaScript引擎捕获，代码终止执行。 所以，我们不必在每一个函数内部捕获错误，只需要在合适的地方来个统一捕获，一网打尽： &#39;use strict&#39;; `// 直接运行，观察控制台输出 ` Run 1234567891011121314151617181920212223function main(s) &#123; console.log('BEGIN main()'); try &#123; foo(s); &#125; catch (e) &#123; console.log('出错了：' + e); &#125; console.log('END main()');&#125;function foo(s) &#123; console.log('BEGIN foo()'); bar(s); console.log('END foo()');&#125;function bar(s) &#123; console.log('BEGIN bar()'); console.log('length = ' + s.length); console.log('END bar()');&#125;main(null); 12345BEGIN main()BEGIN foo()BEGIN bar()出错了：TypeError: Cannot read property 'length' of nullEND main() 当bar()函数传入参数null时，代码会报错，错误会向上抛给调用方foo()函数，foo()函数没有try … catch语句，所以错误继续向上抛给调用方main()函数，main()函数有try … catch语句，所以错误最终在main()函数被处理了。 至于在哪些地方捕获错误比较合适，需要视情况而定。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"}],"author":"along"},{"title":"箭头函数","slug":"箭头函数","date":"2019-02-22T16:00:00.000Z","updated":"2019-05-12T03:46:35.936Z","comments":true,"path":"2019/02/23/箭头函数/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/02/23/箭头函数/","excerpt":"","text":"ES6标准新增了一种新的函数：Arrow Function（箭头函数）。 为什么叫Arrow Function？因为它的定义用的就是一个箭头： 1x =&gt; x * x 上面的箭头函数相当于： 123function (x) &#123; return x * x;&#125; 在继续学习箭头函数之前，请测试你的浏览器是否支持ES6的Arrow Function： &#39;use strict&#39;; `console.log(‘你的浏览器支持ES6的Arrow Function!’); ` Run 箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个表达式，连{ ... }和return都省略掉了。还有一种可以包含多条语句，这时候就不能省略{ ... }和return： 12345678x =&gt; &#123; if (x &gt; 0) &#123; return x * x; &#125; else &#123; return - x * x; &#125;&#125; 如果参数不是一个，就需要用括号()括起来： 1234567891011121314// 两个参数:(x, y) =&gt; x * x + y * y// 无参数:() =&gt; 3.14// 可变参数:(x, y, ...rest) =&gt; &#123; var i, sum = x + y; for (i=0; i&lt;rest.length; i++) &#123; sum += rest[i]; &#125; return sum;&#125; 如果要返回一个对象，就要注意，如果是单表达式，这么写的话会报错： 12// SyntaxError:x =&gt; &#123; foo: x &#125; 因为和函数体的{ ... }有语法冲突，所以要改为： 12// ok:x =&gt; (&#123; foo: x &#125;) this箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定。 回顾前面的例子，由于JavaScript函数对this绑定的错误处理，下面的例子无法得到预期结果： 12345678910var obj = &#123; birth: 1990, getAge: function () &#123; var b = this.birth; // 1990 var fn = function () &#123; return new Date().getFullYear() - this.birth; // this指向window或undefined &#125;; return fn(); &#125;&#125;; 现在，箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者obj： 123456789var obj = &#123; birth: 1990, getAge: function () &#123; var b = this.birth; // 1990 var fn = () =&gt; new Date().getFullYear() - this.birth; // this指向obj对象 return fn(); &#125;&#125;;obj.getAge(); // 25 如果使用箭头函数，以前的那种hack写法： 1var that = this; 就不再需要了。 由于this在箭头函数中已经按照词法作用域绑定了，所以，用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略： 123456789var obj = &#123; birth: 1990, getAge: function (year) &#123; var b = this.birth; // 1990 var fn = (y) =&gt; y - this.birth; // this.birth仍是1990 return fn.call(&#123;birth:2000&#125;, year); &#125;&#125;;obj.getAge(2015); // 25 转载自： https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001438565969057627e5435793645b7acaee3b6869d1374000","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"}],"author":"along"},{"title":"箭头函数001","slug":"微信小程序","date":"2019-02-22T16:00:00.000Z","updated":"2019-10-28T10:01:32.397Z","comments":true,"path":"2019/02/23/微信小程序/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/02/23/微信小程序/","excerpt":"","text":"指南:起步简介代码构成 .json 后缀的 JSON 配置文件 JSON 是数据格式,不是编程语言 静态配置 内容: app.json:全局配置:所有页面路径、界面表现、网络超时时间、底部 tab–字段:pages 页面路径–window 字段:顶部背景颜色，文字颜色定义等 project.config.json:工具配置;个性化配置(换电脑 page.json:页面配置;独立定义每个页面的一些属性 语法:JSON 文件都是被包裹在一个大括号中 {}，通过 key-value 的方式来表达数据。JSON 的 Key 必须包裹在一个双引号中，在实践中，编写 JSON 的时候，忘了给 Key 值加双引号或者是把双引号写成单引号是常见错误。 .wxml 后缀的 WXML 模板文件:类似 html 数据绑定: {{}};大小写敏感;属性值的绑定;未定义/undefined 不会同步到 wxml 可在{{}}进行简单的逻辑运算;三元;算数;字符串拼接 条件逻辑:\\ True \\ \\ 3 \\ 列表渲染: 123456789&lt;view wx:for=\"&#123;&#123;array&#125;&#125;\" wx:for-index=\"idx\" wx:for-item=\"itemName\" wx:key=\"unique\"&gt; //使用 wx:for-item 指定数组当前元素的变量名，使用 wx:for-index 指定数组当前下标的变量名： &#123;&#123;index&#125;&#125;: &#123;&#123;item.message&#125;&#125;&lt;/view&gt; 模板: 123456&lt;template name=\"msgItem\"&gt; &lt;view&gt; &lt;text&gt; &#123;&#123;index&#125;&#125;: &#123;&#123;msg&#125;&#125; &lt;/text&gt; &lt;text&gt; Time: &#123;&#123;time&#125;&#125; &lt;/text&gt; &lt;/view&gt;&lt;/template&gt; 引用 WXML 提供两种文件引用方式 import 和 include 1234&lt;!-- item.wxml --&gt;&lt;template name=&quot;item&quot;&gt; &lt;text&gt;&#123;&#123;text&#125;&#125;&lt;/text&gt;&lt;/template&gt; 123&lt;import src=&quot;item.wxml&quot;/&gt;&lt;template is=&quot;item&quot; data=&quot;&#123;&#123;text: &apos;forbar&apos;&#125;&#125;&quot;/&gt; 共同属性 | id | String | 组件的唯一标识 | 整个页面唯一 || ———— | ———— | ————– | —————————————- || class | String | 组件的样式类 | 在对应的 WXSS 中定义的样式类 || style | String | 组件的内联样式 | 可以动态设置的内联样式 || hidden | Boolean | 组件是否显示 | 所有组件默认显示 || data-* | Any | 自定义属性 | 组件上触发的事件时，会发送给事件处理函数 || bind/catch | EventHandler | 组件的事件 | | .wxss 后缀的 WXSS 样式文件:WXSS 具有 CSS 大部分的特性，小程序在 WXSS 也做了一些扩充和修改。rpx 全局样式和局部样式 支持部分选择器 文件组成: app.wxss(项目公共样式);page=&gt;index.wxss(页面样式);其他 尺寸单位:rpx 小程序编译后，rpx 会做一次 px 换算。换算是以 375 个物理像素为基准，也就是在一个宽度为 375 物理像素的屏幕下，1rpx = 1px。 举个例子：iPhone6 屏幕宽度为 375px，共 750 个物理像素，那么 1rpx = 375 / 750 px = 0.5px。 wxss 引用 @import ‘./test_0.wxss’ 内联样式: 1234567891011121314&lt;!--index.wxml--&gt;&lt;!--内联样式--&gt;&lt;view style=&quot;color: red; font-size: 48rpx&quot;&gt;&lt;/view&gt;&lt;!--index.wxml--&gt;&lt;!--可动态变化的内联样式--&gt;&lt;!--&#123; eleColor: &apos;red&apos;, eleFontsize: &apos;48rpx&apos;&#125;--&gt;&lt;view style=&quot;color: &#123;&#123;eleColor&#125;&#125;; font-size: &#123;&#123;eleFontsize&#125;&#125;&quot;&gt;&lt;/view&gt; 选择器 1234567891011表2-2 小程序WXSS支持的选择器| **类型** | **选择器** | **样例** | **样例描述** || :----------- | :--------- | :------------ | :--------------------------------------------- || 类选择器 | .class | .intro | 选择所有拥有 class=&quot;intro&quot; 的组件 || id选择器 | #id | #firstname | 选择拥有 id=&quot;firstname&quot; 的组件 || 元素选择器 | element | view checkbox | 选择所有文档的 view 组件和所有的 checkbox 组件 || 伪元素选择器 | ::after | view::after | 在 view 组件后边插入内容 || 伪元素选择器 | ::before | view::before | 在 view 组件前边插入内容 |权重:!import(无穷大);style=&quot;&quot;(1000);#id(100);.class(10);element(1); .js 后缀的 JS 脚本逻辑文件 小程序 js 构成:ecmascript;小程序框架;小程序 api 执行环境 ios/安卓/小程序 IDE 模块化: 12345678// moduleA.jsmodule.exports = function( value )&#123; return value * 2;&#125;// B.js// 在B.js中引用模块Avar multiplyBy2 = require(&apos;./moduleA&apos;)var result = multiplyBy2(4) 脚本执行顺序 小程序的执行的入口文件是 app.js 。并且会根据其中 require 的模块顺序决定文件的运行顺序 当 app.js 执行结束后，小程序会按照开发者在 app.json 中定义的 pages 的顺序，逐一执行 作用域 在文件中声明的变量和函数只在该文件中有效，不同的文件中可以声明相同名字的变量和函数，不会互相影响 当需要使用全局变量的时，通过使用全局函数 getApp() 获取全局的实例，并设置相关属性值，来达到设置全局变量的目的 宿主环境渲染层和逻辑层定义:微信客户端给小程序所提供的环境 小程序的运行环境:渲染层(wxml/wxss)和逻辑层(js 脚本); 渲染层:使用了 WebView 进行渲染,多个页面=&gt;存在多个 WebView 线程 逻辑层:JsCore 线程运行 JS 脚本 这两个线程的通信会经由微信客户端（下文中也会采用 Native 来代指微信客户端）做中转, 逻辑层发送网络请求也经由 Native 转发，小程序的通信模型下图所示。 程序与页面整个小程序只有一个 App 实例，是全部页面共享的 微信客户端会先根据 logs.json 配置生成一个界面，顶部的颜色和文字你都可以在这个 json 文件里边定义好。紧接着客户端就会装载这个页面的 WXML 结构和 WXSS 样式。最后客户端会装载 logs.js，你可以看到 logs.js 的大体内容就是: 12345678Page(&#123; data: &#123; // 参与页面渲染的数据 logs: [] &#125;, onLoad: function () &#123; // 页面渲染后 执行 &#125;&#125;) Page 是一个页面构造器，这个构造器就生成了一个页面。在生成页面的时候，小程序框架会把 data 数据和 index.wxml 一起渲染出最终的结构，于是就得到了你看到的小程序的样子。 在渲染完界面之后，页面实例就会收到一个 onLoad 的回调，你可以在这个回调处理你的逻辑 框架组件api服务端工具云开发扩展能力更新日志","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"}],"author":"along"},{"title":"执行上下文栈","slug":"执行上下文栈","date":"2019-02-20T16:00:00.000Z","updated":"2019-06-19T15:44:35.120Z","comments":true,"path":"2019/02/21/执行上下文栈/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/02/21/执行上下文栈/","excerpt":"","text":"在ECMASscript中的代码有三种类型：global, function和eval。 每一种代码的执行都需要依赖自身的上下文。当然global的上下文可能涵盖了很多的function和eval的实例。函数的每一次调用，都会进入函数执行中的上下文,并且来计算函数中变量等的值。eval函数的每一次执行，也会进入eval执行中的上下文，判断应该从何处获取变量的值。 注意，一个function可能产生无限的上下文环境，因为一个函数的调用（甚至递归）都产生了一个新的上下文环境。 12345678function foo(bar) &#123;&#125;// 调用相同的function，每次都会产生3个不同的上下文//（包含不同的状态，例如参数bar的值）foo(10);foo(20);foo(30); 一个执行上下文可以激活另一个上下文，就好比一个函数调用了另一个函数(或者全局的上下文调用了一个全局函数)，然后一层一层调用下去。逻辑上来说，这种实现方式是栈，我们可以称之为上下文堆栈。 激活其它上下文的某个上下文被称为 调用者(caller) 。被激活的上下文被称为被调用者(callee) 。被调用者同时也可能是调用者(比如一个在全局上下文中被调用的函数调用某些自身的内部方法)。 当一个caller激活了一个callee，那么这个caller就会暂停它自身的执行，然后将控制权交给这个callee. 于是这个callee被放入堆栈，称为进行中的上下文[running/active execution context]. 当这个callee的上下文结束之后，会把控制权再次交给它的caller，然后caller会在刚才暂停的地方继续执行。在这个caller结束之后，会继续触发其他的上下文。一个callee可以用返回（return）或者抛出异常（exception）来结束自身的上下文。 如下图，所有的ECMAScript的程序执行都可以看做是一个执行上下文堆栈[execution context (EC) stack]。堆栈的顶部就是处于激活状态的上下文。 图 4. 执行上下文栈 当一段程序开始时，会先进入全局执行上下文环境[global execution context], 这个也是堆栈中最底部的元素。此全局程序会开始初始化，初始化生成必要的对象[objects]和函数[functions]. 在此全局上下文执行的过程中，它可能会激活一些方法（当然是已经初始化过的），然后进入他们的上下文环境，然后将新的元素压入堆栈。在这些初始化都结束之后，这个系统会等待一些事件（例如用户的鼠标点击等），会触发一些方法，然后进入一个新的上下文环境。 见图5，有一个函数上下文“EC1″和一个全局上下文“Global EC”，下图展现了从“Global EC”进入和退出“EC1″时栈的变化: 图 5. 执行上下文栈的变化 ECMAScript运行时系统就是这样管理代码的执行。 关于ECMAScript执行上下文栈的内容请查阅本系列教程的第11章执行上下文(Execution context)。 如上所述，栈中每一个执行上下文可以表示为一个对象。让我们看看上下文对象的结构以及执行其代码所需的 状态(state) 。 执行上下文(Execution Context)一个执行的上下文可以抽象的理解为object。每一个执行的上下文都有一系列的属性（我们称为上下文状态），他们用来追踪关联代码的执行进度。这个图示就是一个context的结构。 图 6. 上下文结构 除了这3个所需要的属性(变量对象(variable object)，this指针(this value)，作用域链(scope chain) )，执行上下文根据具体实现还可以具有任意额外属性。接着，让我们仔细来看看这三个属性。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"}],"author":"along"},{"title":"探究同步异步工作原理","slug":"探究同步异步工作原理","date":"2019-02-18T16:00:00.000Z","updated":"2019-05-12T03:46:35.935Z","comments":true,"path":"2019/02/19/探究同步异步工作原理/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/02/19/探究同步异步工作原理/","excerpt":"","text":"前言 JS引擎在运行同步代码的时候按照顺序运行的方式，而如果遇见异步代码将会短暂挂起，放入事件循环队列(Event Loop)末端，一次执行。 12345678//you may have seen the following codefor (var i = 0; i &lt; 3; i++) &#123; setTimeout(function timeoutHandle() &#123; console.log(i); &#125;,1000);&#125; 但是如果如上述代码所示，加上一个定时器又如何理解呢？在同步代码循环结束完毕之后，三个异步事件挂起，等到1秒时间到了之后，三个异步事件依次放入事件循环队列中执行，而同步代码中循环中的每一次迭代都会给自己捕获一个i的副本，但是根据作用域的工作原理，实际情况是尽管循环中的三个函数是在各个迭代中分别定义的，但是他们都被封闭在一个共享的全局作用域中，因此实际只有一个i。 探析 对于var关键字声明变量有着诸多诟病，那就是会造成污染全局变量的风险，比如上述的for循环中，假如在for循环体之外再次打印，引擎依旧会给出泄露出去的全局变量i，当然这是很危险的。我们不妨用一下let关键字。 12345for (let i = 0; i &lt; 3; i++ )&#123; setTimeout(function timeoutHandle() &#123; console.log(i); &#125;);&#125; 你会惊喜的发现打印结果是预期顺序。 那是因为for循环的头部的let声明还会有一个特殊的行为。这个行为指出变量在循环过程中不止被声明一次。每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。 原始链接： https://bigbigdreamer.github.io/76f810b0/","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"}],"author":"along"},{"title":"原型链-继承","slug":"原型链继承","date":"2019-02-17T16:00:00.000Z","updated":"2019-05-12T03:46:35.932Z","comments":true,"path":"2019/02/18/原型链继承/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/02/18/原型链继承/","excerpt":"","text":"前言：​ 对于有基于类的语言经验 (如 Java 或 C++) 的开发人员来说，JavaScript 有点令人困惑，因为它是动态的，并且本身不提供一个 class 实现。（在 ES2015/ES6 中引入了 class 关键字，但只是语法糖，JavaScript 仍然是基于原型的）。 ​ 当谈到继承时，JavaScript 只有一种结构：对象。每个实例对象（ object ）都有一个私有属性（称之为 proto ）指向它的原型对象（ prototype ）。该原型对象也有一个自己的原型对象( proto ) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。 几乎所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例。 ​ 尽管这种原型继承通常被认为是 JavaScript 的弱点之一，但是原型继承模型本身实际上比经典模型更强大。例如，在原型模型的基础上构建经典模型相当简单。 ### 原型：原型的概念定义为：所谓原型就是指函数的prototype属性所引用的对象，这个对象就是原型。 作用1：实现对象之间的数据共享。2.在es6之前，没有class的情况下，模拟面向对象，构造函数中放私有属性，原型上放公有属性，一般为方法。 获取原型的方法：1.函数.prototype；2.对象._ proto （如果当前浏览器不支持.proto _，那么就通过对象的构造函数找：.constructor.prototype；原型本身是一个对象。 原型（prototype）： 每一个构造函数都拥有一个prototype属性，这个属性指向一个对象，也就是原型对象。当使用这个构造函数创建实例的时候，prototype属性指向的原型对象就成为实例的原型对象。 原型对象默认拥有一个constructor属性，指向指向它的那个构造函数（也就是说构造函数和原型对象是互相指向的关系）。 每个对象都拥有一个隐藏的属性[[prototype]]，指向它的原型对象，这个属性可以通过 Object.getPrototypeOf(obj) 或 obj.__proto__ 来访问。 实际上，构造函数的prototype属性与它创建的实例对象的[[prototype]]属性指向的是同一个对象，即 对象.__proto__ === 函数.prototype 。 如上文所述，原型对象就是用来存放实例中共有的那部分属性。 在JavaScript中，所有的对象都是由它的原型对象继承而来，反之，所有的对象都可以作为原型对象存在。 访问对象的属性时，JavaScript会首先在对象自身的属性内查找，若没有找到，则会跳转到该对象的原型对象中查找。 作者：clancysong 链接：https://juejin.im/post/5a94c0de5188257a8929d837 原型链：概念：原型链是一种机制，指的是JavaScript每个对象包括原型对象都有一个内置的[[proto]]属性指向创建它的函数对象的原型对象，即prototype属性。 作用：原型链的存在，主要是为了实现对象的继承。 继承：1、函数对象在JavaScript中，函数即对象。 2、原型对象当定义一个函数对象的时候，会包含一个预定义的属性，叫prototype，这就属性称之为原型对象。 123//函数对象function F()&#123;&#125;;console.log(F.prototype) 123//普通对象var a = &#123;&#125;;console.log(a.prototype);//undefined 3、__prot__JavaScript在创建对象的时候，都会有一个[[proto]]的内置属性，用于指向创建它的函数对象的prototype。原型对象也有[[proto]]属性。因此在不断的指向中，形成了原型链。 举个例子来说，我们将对象F的原型对象修改一下，就可以清楚看到上述的关系 1234567//函数对象function F()&#123;&#125;;F.prototype = &#123; hello : function()&#123;&#125;&#125;;var f = new F();console.log(f.__proto__) 4、new当使用new去调用构造函数时，相当于执行了 123var o = &#123;&#125;;o.__proto__ = F.prototype;F.call(o); 因此，在原型链的实现上，new起到了很关键的作用。 5、constructor原型对象prototype上都有个预定义的constructor属性，用来引用它的函数对象。这是一种循环引用。 12function F()&#123;&#125;;F.prototype.constructor === F; 在实际运用中，经常会有下列的写法 12345function F()&#123;&#125;;F.prototype = &#123; constructor : F, doSomething : function()&#123;&#125;&#125; 这里要加constructor是因为重写了原型对象，constructor属性就消失了，需要自己手动补上。 6、原型链的内存结构12345function F()&#123; this.name = &apos;zhang&apos;;&#125;;var f1 = new F();var f2 = new F(); 为了严谨起见，区分对象和变量 简单回顾下构造函数,原型和实例的关系: 每个构造函数(constructor)都有一个原型对象(prototype),原型对象都包含一个指向构造函数的指针,而实例(instance)都包含一个指向原型对象的内部指针. JS对象的圈子里有这么个游戏规则: 如果试图引用对象(实例instance)的某个属性,会首先在对象内部寻找该属性,直至找不到,然后才在该对象的原型(instance.prototype)里去找这个属性. 如果让原型对象指向另一个类型的实例…..有趣的事情便发生了. 即: constructor1.prototype = instance2 鉴于上述游戏规则生效,如果试图引用constructor1构造的实例instance1的某个属性p1: 1).首先会在instance1内部属性中找一遍; 2).接着会在instance1.proto(constructor1.prototype)中找一遍,而constructor1.prototype 实际上是instance2, 也就是说在instance2中寻找该属性p1; 3).如果instance2中还是没有,此时程序不会灰心,它会继续在instance2.proto(constructor2.prototype)中寻找…直至Object的原型对象 搜索轨迹: instance1–&gt; instance2 –&gt; constructor2.prototype…–&gt;Object.prototype 这种搜索的轨迹,形似一条长链, 又因prototype在这个游戏规则中充当链接的作用,于是我们把这种实例与原型的链条称作 原型链 . 下面有个例子 1234567891011121314151617function Father()&#123; this.property = true;&#125;Father.prototype.getFatherValue = function()&#123; return this.property;&#125;function Son()&#123; this.sonProperty = false;&#125;//继承 FatherSon.prototype = new Father();//Son.prototype被重写,导致Son.prototype.constructor也一同被重写Son.prototype.getSonVaule = function()&#123; return this.sonProperty;&#125;var instance = new Son();alert(instance.getFatherValue());//true12345678910111213141516 instance实例通过原型链找到了Father原型中的getFatherValue方法. 注意: 此时instance.constructor指向的是Father,这是因为Son.prototype中的constructor被重写的缘故. 确定原型和实例的关系使用原型链后, 我们怎么去判断原型和实例的这种继承关系呢? 方法一般有两种. 第一种是使用 instanceof 操作符, 只要用这个操作符来测试实例(instance)与原型链中出现过的构造函数,结果就会返回true. 以下几行代码就说明了这点. 1234alert(instance instanceof Object);//truealert(instance instanceof Father);//truealert(instance instanceof Son);//true123 由于原型链的关系, 我们可以说instance 是 Object, Father 或 Son中任何一个类型的实例. 因此, 这三个构造函数的结果都返回了true. 第二种是使用 isPrototypeOf() 方法, 同样只要是原型链中出现过的原型,isPrototypeOf() 方法就会返回true, 如下所示. 1234alert(Object.prototype.isPrototypeOf(instance));//truealert(Father.prototype.isPrototypeOf(instance));//truealert(Son.prototype.isPrototypeOf(instance));//true123 原理同上. 原型链的问题原型链并非十分完美, 它包含如下两个问题. 问题一: 当原型链中包含引用类型值的原型时,该引用类型值会被所有实例共享; 问题二: 在创建子类型(例如创建Son的实例)时,不能向超类型(例如Father)的构造函数中传递参数. 有鉴于此, 实践中很少会单独使用原型链. 为此,下面将有一些尝试以弥补原型链的不足. 借用构造函数为解决原型链中上述两个问题, 我们开始使用一种叫做借用构造函数(constructor stealing)的技术(也叫经典继承). 基本思想:即在子类型构造函数的内部调用超类型构造函数. 12345678910111213function Father()&#123; this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];&#125;function Son()&#123; Father.call(this);//继承了Father,且向父类型传递参数&#125;var instance1 = new Son();instance1.colors.push(&quot;black&quot;);console.log(instance1.colors);//&quot;red,blue,green,black&quot;var instance2 = new Son();console.log(instance2.colors);//&quot;red,blue,green&quot; 可见引用类型值是独立的123456789101112 很明显,借用构造函数一举解决了原型链的两大问题: 其一, 保证了原型链中引用类型值的独立,不再被所有实例共享; 其二, 子类型创建时也能够向父类型传递参数. 随之而来的是, 如果仅仅借用构造函数,那么将无法避免构造函数模式存在的问题–方法都在构造函数中定义, 因此函数复用也就不可用了.而且超类型(如Father)中定义的方法,对子类型而言也是不可见的. 考虑此,借用构造函数的技术也很少单独使用. 组合继承组合继承, 有时候也叫做伪经典继承,指的是将原型链和借用构造函数的技术组合到一块,从而发挥两者之长的一种继承模式. 基本思路: 使用原型链实现对原型属性和方法的继承,通过借用构造函数来实现对实例属性的继承. 这样,既通过在原型上定义方法实现了函数复用,又能保证每个实例都有它自己的属性. 如下所示. 1234567891011121314151617181920212223242526function Father(name)&#123; this.name = name; this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];&#125;Father.prototype.sayName = function()&#123; alert(this.name);&#125;;function Son(name,age)&#123; Father.call(this,name);//继承实例属性，第一次调用Father() this.age = age;&#125;Son.prototype = new Father();//继承父类方法,第二次调用Father()Son.prototype.sayAge = function()&#123; alert(this.age);&#125;var instance1 = new Son(&quot;louis&quot;,5);instance1.colors.push(&quot;black&quot;);console.log(instance1.colors);//&quot;red,blue,green,black&quot;instance1.sayName();//louisinstance1.sayAge();//5var instance1 = new Son(&quot;zhai&quot;,10);console.log(instance1.colors);//&quot;red,blue,green&quot;instance1.sayName();//zhaiinstance1.sayAge();//1012345678910111213141516171819202122232425 组合继承避免了原型链和借用构造函数的缺陷,融合了它们的优点,成为 JavaScript 中最常用的继承模式. 而且, instanceof 和 isPrototypeOf( )也能用于识别基于组合继承创建的对象. 同时我们还注意到组合继承其实调用了两次父类构造函数, 造成了不必要的消耗, 那么怎样才能避免这种不必要的消耗呢, 这个我们将在后面讲到. 原型继承该方法最初由道格拉斯·克罗克福德于2006年在一篇题为 《Prototypal Inheritance in JavaScript》(JavaScript中的原型式继承) 的文章中提出. 他的想法是借助原型可以基于已有的对象创建新对象， 同时还不必因此创建自定义类型. 大意如下: 在object()函数内部, 先创建一个临时性的构造函数, 然后将传入的对象作为这个构造函数的原型,最后返回了这个临时类型的一个新实例. 123456function object(o)&#123; function F()&#123;&#125; F.prototype = o; return new F();&#125;12345 从本质上讲, object() 对传入其中的对象执行了一次浅复制. 下面我们来看看为什么是浅复制. 123456789var person = &#123; friends : [&quot;Van&quot;,&quot;Louis&quot;,&quot;Nick&quot;]&#125;;var anotherPerson = object(person);anotherPerson.friends.push(&quot;Rob&quot;);var yetAnotherPerson = object(person);yetAnotherPerson.friends.push(&quot;Style&quot;);alert(person.friends);//&quot;Van,Louis,Nick,Rob,Style&quot;12345678 在这个例子中,可以作为另一个对象基础的是person对象,于是我们把它传入到object()函数中,然后该函数就会返回一个新对象. 这个新对象将person作为原型,因此它的原型中就包含引用类型值属性. 这意味着person.friends不仅属于person所有,而且也会被anotherPerson以及yetAnotherPerson共享. 在 ECMAScript5 中,通过新增 object.create() 方法规范化了上面的原型式继承. object.create() 接收两个参数: 一个用作新对象原型的对象 (可选的)一个为新对象定义额外属性的对象 123456789var person = &#123; friends : [&quot;Van&quot;,&quot;Louis&quot;,&quot;Nick&quot;]&#125;;var anotherPerson = Object.create(person);anotherPerson.friends.push(&quot;Rob&quot;);var yetAnotherPerson = Object.create(person);yetAnotherPerson.friends.push(&quot;Style&quot;);alert(person.friends);//&quot;Van,Louis,Nick,Rob,Style&quot;12345678 object.create() 只有一个参数时功能与上述object方法相同, 它的第二个参数与Object.defineProperties()方法的第二个参数格式相同: 每个属性都是通过自己的描述符定义的.以这种方式指定的任何属性都会覆盖原型对象上的同名属性.例如: 12345678910var person = &#123; name : &quot;Van&quot;&#125;;var anotherPerson = Object.create(person, &#123; name : &#123; value : &quot;Louis&quot; &#125;&#125;);alert(anotherPerson.name);//&quot;Louis&quot;123456789 目前支持 Object.create() 的浏览器有 IE9+, Firefox 4+, Safari 5+, Opera 12+ 和 Chrome. 提醒: 原型式继承中, 包含引用类型值的属性始终都会共享相应的值, 就像使用原型模式一样. 寄生式继承寄生式继承是与原型式继承紧密相关的一种思路， 同样是克罗克福德推而广之. 寄生式继承的思路与(寄生)构造函数和工厂模式类似, 即创建一个仅用于封装继承过程的函数,该函数在内部以某种方式来增强对象,最后再像真的是它做了所有工作一样返回对象. 如下. 12345678function createAnother(original)&#123; var clone = object(original);//通过调用object函数创建一个新对象 clone.sayHi = function()&#123;//以某种方式来增强这个对象 alert(&quot;hi&quot;); &#125;; return clone;//返回这个对象&#125;1234567 这个例子中的代码基于person返回了一个新对象–anotherPerson. 新对象不仅具有 person 的所有属性和方法, 而且还被增强了, 拥有了sayH()方法. 注意: 使用寄生式继承来为对象添加函数, 会由于不能做到函数复用而降低效率;这一点与构造函数模式类似. 寄生组合式继承前面讲过,组合继承是 JavaScript 最常用的继承模式; 不过, 它也有自己的不足. 组合继承最大的问题就是无论什么情况下,都会调用两次父类构造函数: 一次是在创建子类型原型的时候, 另一次是在子类型构造函数内部. 寄生组合式继承就是为了降低调用父类构造函数的开销而出现的 . 其背后的基本思路是: 不必为了指定子类型的原型而调用超类型的构造函数 123456function extend(subClass,superClass)&#123; var prototype = object(superClass.prototype);//创建对象 prototype.constructor = subClass;//增强对象 subClass.prototype = prototype;//指定对象&#125;12345 extend的高效率体现在它没有调用superClass构造函数,因此避免了在subClass.prototype上面创建不必要,多余的属性. 于此同时,原型链还能保持不变; 因此还能正常使用 instanceof 和 isPrototypeOf() 方法. 以上,寄生组合式继承,集寄生式继承和组合继承的优点于一身,是实现基于类型继承的最有效方法. 下面我们来看下extend的另一种更为有效的扩展. 123456789101112function extend(subClass, superClass) &#123; var F = function() &#123;&#125;; F.prototype = superClass.prototype; subClass.prototype = new F(); subClass.prototype.constructor = subClass; subClass.superclass = superClass.prototype; if(superClass.prototype.constructor == Object.prototype.constructor) &#123; superClass.prototype.constructor = superClass; &#125;&#125;1234567891011 我一直不太明白的是为什么要 “new F()“, 既然extend的目的是将子类型的 prototype 指向超类型的 prototype,为什么不直接做如下操作呢? 12subClass.prototype = superClass.prototype;//直接指向超类型prototype1 显然, 基于如上操作, 子类型原型将与超类型原型共用, 根本就没有继承关系. new 运算符为了追本溯源, 我顺便研究了new运算符具体干了什么?发现其实很简单，就干了三件事情. 1234var obj = &#123;&#125;;obj.__proto__ = F.prototype;F.call(obj);123 第一行，我们创建了一个空对象obj; 第二行，我们将这个空对象的proto成员指向了F函数对象prototype成员对象; 第三行，我们将F函数对象的this指针替换成obj，然后再调用F函数. 我们可以这么理解: 以 new 操作符调用构造函数的时候，函数内部实际上发生以下变化： 1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。 2、属性和方法被加入到 this 引用的对象中。 3、新创建的对象由 this 所引用，并且最后隐式的返回 this. proto 属性是指定原型的关键以上, 通过设置 proto 属性继承了父类, 如果去掉new 操作, 直接参考如下写法 12subClass.prototype = superClass.prototype;//直接指向超类型prototype1 那么, 使用 instanceof 方法判断对象是否是构造器的实例时, 将会出现紊乱. 假如参考如上写法, 那么extend代码应该为 123456789function extend(subClass, superClass) &#123; subClass.prototype = superClass.prototype; subClass.superclass = superClass.prototype; if(superClass.prototype.constructor == Object.prototype.constructor) &#123; superClass.prototype.constructor = superClass; &#125;&#125;12345678 此时, 请看如下测试: 1234567function a()&#123;&#125;function b()&#123;&#125;extend(b,a);var c = new a()&#123;&#125;;console.log(c instanceof a);//trueconsole.log(c instanceof b);//true123456 c被认为是a的实例可以理解, 也是对的; 但c却被认为也是b的实例, 这就不对了. 究其原因, instanceof 操作符比较的应该是 c.proto 与 构造器.prototype(即 b.prototype 或 a.prototype) 这两者是否相等, 又extend(b,a); 则b.prototype === a.prototype, 故这才打印出上述不合理的输出. 那么最终,原型链继承可以这么实现,例如: 1234567891011121314151617181920212223242526function Father(name)&#123; this.name = name; this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];&#125;Father.prototype.sayName = function()&#123; alert(this.name);&#125;;function Son(name,age)&#123; Father.call(this,name);//继承实例属性，第一次调用Father() this.age = age;&#125;extend(Son,Father)//继承父类方法,此处并不会第二次调用Father()Son.prototype.sayAge = function()&#123; alert(this.age);&#125;var instance1 = new Son(&quot;louis&quot;,5);instance1.colors.push(&quot;black&quot;);console.log(instance1.colors);//&quot;red,blue,green,black&quot;instance1.sayName();//louisinstance1.sayAge();//5var instance1 = new Son(&quot;zhai&quot;,10);console.log(instance1.colors);//&quot;red,blue,green&quot;instance1.sayName();//zhaiinstance1.sayAge();//1012345678910111213141516171819202122232425 扩展:属性查找1234使用了原型链后, 当查找一个对象的属性时，JavaScript 会向上遍历原型链，直到找到给定名称的属性为止，到查找到达原型链的顶部 - 也就是 Object.prototype - 但是仍然没有找到指定的属性，就会返回 undefined. 此时若想避免原型链查找, 建议使用 **hasOwnProperty** 方法. 因为 **hasOwnProperty** 是 JavaScript 中唯一一个处理属性但是不查找原型链的函数. 如:1console.log(instance1.hasOwnProperty(&apos;age&apos;));//true1 对比: isPrototypeOf 则是用来判断该方法所属的对象是不是参数的原型对象，是则返回true，否则返回false。如: 12console.log(Father.prototype.isPrototypeOf(instance1));//true1 instanceof &amp;&amp; typeof上面提到几次提到 instanceof 运算符. 那么到底它是怎么玩的呢? 下面让我们来趴一趴它的使用场景. instanceof 运算符是用来在运行时指出对象是否是构造器的一个实例, 例如漏写了new运算符去调用某个构造器, 此时构造器内部可以通过 instanceof 来判断.(java中功能类似) 123456789function f()&#123; if(this instanceof arguments.callee) console.log(&apos;此处作为构造函数被调用&apos;); else console.log(&apos;此处作为普通函数被调用&apos;);&#125;f();//此处作为普通函数被调用new f();//此处作为构造函数被调用12345678 以上, this instanceof arguments.callee 的值如果为 true 表示是作为构造函数被调用的,如果为 false 则表示是作为普通函数被调用的。 对比: typeof 则用以获取一个变量或者表达式的类型, 一般只能返回如下几个结果: number,boolean,string,function（函数）,object（NULL,数组，对象）,undefined。 new运算符此处引用 艾伦的 JS 对象机制深剖——new 运算符 接着上述对new运算符的研究, 我们来考察 ECMAScript 语言规范中 new 运算符的定义： The new Operator The production NewExpression : new NewExpression is evaluated as follows:Evaluate NewExpression.Call GetValue(Result(1)).If Type(Result(2)) is not Object, throw a TypeError exception.If Result(2) does not implement the internal [[Construc]] method, throw a TypeError exception.Call the [[Construct]] method on Result(2), providing no arguments (that is, an empty list of arguments).Return Result(5). 其大意是，new 后必须跟一个对象并且此对象必须有一个名为 [[Construct]] 的内部方法（其实这种对象就是构造器），否则会抛出异常 根据这些内容，我们完全可以构造一个伪 [[Construct]] 方法来模拟此流程 12345678910111213141516function MyObject(age) &#123; this.age = age;&#125;MyObject.construct = function() &#123; var o = &#123;&#125;, Constructor = MyObject; o.__proto__ = Constructor.prototype; // FF 支持用户引用内部属性 [[Prototype]] Constructor.apply(o, arguments); return o;&#125;;var obj1 = new MyObject(10);var obj2 = MyObject.construct(10);alert(obj2 instanceof MyObject);// true123456789101112131415 解释：","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"},{"name":"原型链","slug":"原型链","permalink":"https://WLL-1017065322.github.io/blog/tags/原型链/"}],"author":"along"},{"title":"闭包","slug":"闭包","date":"2019-02-14T16:00:00.000Z","updated":"2019-10-28T08:59:54.393Z","comments":true,"path":"2019/02/15/闭包/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/02/15/闭包/","excerpt":"","text":"​ 闭包是指有权访问另一个函数作用域中的变量的函数；常见方式就是在一个函数内部创建另一个函数。 ​ JavaScript 闭包的本质源自两点，词法作用域和函数当作值传递。 词法作用域，就是，按照代码书写时的样子，内部函数可以访问函数外面的变量。 引擎通过数据结构和算法表示一个函数，使得在代码解释执行时按照词法作用域的规则，可以访问外围的变量，这些变量就登记在相应的数据结构中。 ​ 通俗地讲就是别人家有某个东西，你想拿到但是因为权限不够（不打死你才怪），但是你可以跟家里的孩子套近乎，通过他拿到！这个家就是局部作用域，外部无法访问内部变量，孩子是返回对象，对家里的东西有访问权限，借助返回对象间接访问内部变量！ 例子： 12345678910function makeFunc() &#123; var name = \"Mozilla\"; function displayName() &#123; alert(name); &#125; return displayName;&#125;var myFunc = makeFunc();myFunc(); ​ JavaScript中的函数会形成闭包。 闭包是由函数以及创建该函数的词法环境组合而成。这个环境包含了这个闭包创建时所能访问的所有局部变量。在我们的例子中，myFunc 是执行 makeFunc 时创建的 displayName 函数实例的引用，而 displayName 实例仍可访问其词法作用域中的变量，即可以访问到 name 。由此，当 myFunc 被调用时，name 仍可被访问，其值 Mozilla 就被传递到alert中。 ​ 如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。 例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。原因是这将导致每次构造器被调用时，方法都会被重新赋值一次（也就是，每个对象的创建）。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"}],"author":"along"},{"title":"this指针","slug":"this指针","date":"2019-02-09T16:00:00.000Z","updated":"2019-05-12T03:46:35.926Z","comments":true,"path":"2019/02/10/this指针/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/02/10/this指针/","excerpt":"","text":"123A this value is a special object which is related with the execution context. Therefore, it may be named as a context object (i.e. an object in which context the execution context is activated).this适合执行的上下文环境息息相关的一个特殊对象。因此，它也可以称为上下文对象[context object](激活执行上下文的上下文)。 任何对象都可以作为上下文的this值。我想再次澄清对与ECMAScript中，与执行上下文相关的一些描述——特别是this的误解。通常，this 被错误地，描述为变量对象的属性。最近比如在这本书中就发现了(尽管书中提及this的那一章还不错)。 请牢记： 12a this value is a property of the execution context, but not a property of the variable object.this是执行上下文环境的一个属性，而不是某个变量对象的属性 这个特点很重要，因为和变量不同，this是没有一个类似搜寻变量的过程。当你在代码中使用了this,这个 this的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻。this的值只取决中进入上下文时的情况。 顺便说一句，和ECMAScript不同，Python有一个self的参数，和this的情况差不多，但是可以在执行过程中被改变。在ECMAScript中，是不可以给this赋值的，因为，还是那句话，this不是变量。 在global context(全局上下文)中，this的值就是指全局这个对象，这就意味着，this值就是这个变量本身。 1234567var x = 10; console.log( x, // 10 this.x, // 10 window.x // 10); 在函数上下文[function context]中，this会可能会根据每次的函数调用而成为不同的值.this会由每一次caller提供,caller是通过调用表达式[call expression]产生的（也就是这个函数如何被激活调用的）。例如，下面的例子中foo就是一个callee，在全局上下文中被激活。下面的例子就表明了不同的caller引起this的不同。 1234567891011121314151617181920212223242526// &quot;foo&quot;函数里的alert没有改变// 但每次激活调用的时候this是不同的 function foo() &#123; alert(this);&#125; // caller 激活 &quot;foo&quot;这个callee，// 并且提供&quot;this&quot;给这个 callee foo(); // 全局对象foo.prototype.constructor(); // foo.prototype var bar = &#123; baz: foo&#125;; bar.baz(); // bar (bar.baz)(); // also bar(bar.baz = bar.baz)(); // 这是一个全局对象(bar.baz, bar.baz)(); // 也是全局对象(false || bar.baz)(); // 也是全局对象 var otherFoo = bar.baz;otherFoo(); // 还是全局对象 如果要深入思考每一次函数调用中，this值的变化(更重要的是怎样变化)，你可以阅读本系列教程第10章This。上文所提及的情况都会在此章内详细讨论。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"}],"author":"along"},{"title":"作用域链","slug":"作用域链","date":"2019-02-09T16:00:00.000Z","updated":"2019-05-12T03:46:35.928Z","comments":true,"path":"2019/02/10/作用域链/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/02/10/作用域链/","excerpt":"","text":"12A scope chain is a list of objects that are searched for identifiers appear in the code of the context.作用域链是一个 对象列表(list of objects) ，用以检索上下文代码中出现的 标识符(identifiers) 。 作用域链的原理和原型链很类似，如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层。 标示符[Identifiers]可以理解为变量名称、函数声明和普通参数。例如，当一个函数在自身函数体内需要引用一个变量，但是这个变量并没有在函数内部声明（或者也不是某个参数名），那么这个变量就可以称为自由变量[free variable]。那么我们搜寻这些自由变量就需要用到作用域链。 在一般情况下，一个作用域链包括父级变量对象（variable object）（作用域链的顶部）、函数自身变量VO和活动对象（activation object）。不过，有些情况下也会包含其它的对象，例如在执行期间，动态加入作用域链中的—例如with或者catch语句。[译注：with-objects指的是with语句，产生的临时作用域对象；catch-clauses指的是catch从句，如catch(e)，这会产生异常对象，导致作用域变更]。 当查找标识符的时候，会从作用域链的活动对象部分开始查找，然后(如果标识符没有在活动对象中找到)查找作用域链的顶部，循环往复，就像作用域链那样。 1234567891011var x = 10; (function foo() &#123; var y = 20; (function bar() &#123; var z = 30; // &quot;x&quot;和&quot;y&quot;是自由变量 // 会在作用域链的下一个对象中找到（函数”bar”的互动对象之后） console.log(x + y + z); &#125;)();&#125;)(); 我们假设作用域链的对象联动是通过一个叫做parent的属性，它是指向作用域链的下一个对象。这可以在Rhino Code中测试一下这种流程，这种技术也确实在ES5环境中实现了(有一个称为outer链接).当然也可以用一个简单的数据来模拟这个模型。使用parent的概念，我们可以把上面的代码演示成如下的情况。（因此，父级变量是被存在函数的[[Scope]]属性中的）。 图 9. 作用域链 在代码执行过程中，如果使用with或者catch语句就会改变作用域链。而这些对象都是一些简单对象，他们也会有原型链。这样的话，作用域链会从两个维度来搜寻。 ​ 首先在原本的作用域链 ​ 每一个链接点的作用域的链（如果这个链接点是有prototype的话） 我们再看下面这个例子： 1234567891011121314151617181920212223242526272829303132333435Object.prototype.x = 10; var w = 20;var y = 30; // 在SpiderMonkey全局对象里// 例如，全局上下文的变量对象是从&quot;Object.prototype&quot;继承到的// 所以我们可以得到“没有声明的全局变量”// 因为可以从原型链中获取 console.log(x); // 10 (function foo() &#123; // &quot;foo&quot; 是局部变量 var w = 40; var x = 100; // &quot;x&quot; 可以从&quot;Object.prototype&quot;得到，注意值是10哦 // 因为&#123;z: 50&#125;是从它那里继承的 with (&#123;z: 50&#125;) &#123; console.log(w, x, y , z); // 40, 10, 30, 50 &#125; // 在&quot;with&quot;对象从作用域链删除之后 // x又可以从foo的上下文中得到了，注意这次值又回到了100哦 // &quot;w&quot; 也是局部变量 console.log(x, w); // 100, 40 // 在浏览器里 // 我们可以通过如下语句来得到全局的w值 console.log(window.w); // 20 &#125;)(); 我们就会有如下结构图示。这表示，在我们去搜寻parent之前，首先会去proto的链接中。 图 10. with增大的作用域链 注意，不是所有的全局对象都是由Object.prototype继承而来的。上述图示的情况可以在SpiderMonkey中测试。 只要所有外部函数的变量对象都存在，那么从内部函数引用外部数据则没有特别之处——我们只要遍历作用域链表，查找所需变量。然而，如上文所提及，当一个上下文终止之后，其状态与自身将会被 销毁(destroyed) ，同时内部函数将会从外部函数中返回。此外，这个返回的函数之后可能会在其他的上下文中被激活，那么如果一个之前被终止的含有一些自由变量的上下文又被激活将会怎样?通常来说，解决这个问题的概念在ECMAScript中与作用域链直接相关，被称为 (词法)闭包((lexical) closure)。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"}],"author":"along"},{"title":"canvas","slug":"canvas","date":"2019-02-06T16:00:00.000Z","updated":"2019-05-12T03:46:35.908Z","comments":true,"path":"2019/02/07/canvas/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/02/07/canvas/","excerpt":"","text":"Canvas是HTML5新增的组件，它就像一块幕布，可以用JavaScript在上面绘制各种图表、动画等。 没有Canvas的年代，绘图只能借助Flash插件实现，页面不得不用JavaScript和Flash进行交互。有了Canvas，我们就再也不需要Flash了，直接使用JavaScript完成绘制。 一个Canvas定义了一个指定尺寸的矩形框，在这个范围内我们可以随意绘制： 1&lt;canvas id=&quot;test-canvas&quot; width=&quot;300&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt; 由于浏览器对HTML5标准支持不一致，所以，通常在&lt;canvas&gt;内部添加一些说明性HTML代码，如果浏览器支持Canvas，它将忽略&lt;canvas&gt;内部的HTML，如果浏览器不支持Canvas，它将显示&lt;canvas&gt;内部的HTML： 123&lt;canvas id=&quot;test-stock&quot; width=&quot;300&quot; height=&quot;200&quot;&gt; &lt;p&gt;Current Price: 25.51&lt;/p&gt;&lt;/canvas&gt; 在使用Canvas前，用canvas.getContext来测试浏览器是否支持Canvas： 1234&lt;!-- HTML代码 --&gt;&lt;canvas id=&quot;test-canvas&quot; width=&quot;200&quot; heigth=&quot;100&quot;&gt; &lt;p&gt;你的浏览器不支持Canvas&lt;/p&gt;&lt;/canvas&gt; getContext(&#39;2d&#39;)方法让我们拿到一个CanvasRenderingContext2D对象，所有的绘图操作都需要通过这个对象完成。 1var ctx = canvas.getContext(&apos;2d&apos;); 如果需要绘制3D怎么办？HTML5还有一个WebGL规范，允许在Canvas中绘制3D图形： 1gl = canvas.getContext(&quot;webgl&quot;); 本节我们只专注于绘制2D图形。 绘制形状我们可以在Canvas上绘制各种形状。在绘制前，我们需要先了解一下Canvas的坐标系统： Canvas的坐标以左上角为原点，水平向右为X轴，垂直向下为Y轴，以像素为单位，所以每个点都是非负整数。 CanvasRenderingContext2D对象有若干方法来绘制图形： 12345&apos;use strict&apos;;var canvas = document.getElementById(&apos;test-shape-canvas&apos;), ctx = canvas.getContext(&apos;2d&apos;); (no output) 绘制文本绘制文本就是在指定的位置输出文本，可以设置文本的字体、样式、阴影等，与CSS完全一致： 12345&apos;use strict&apos;;var canvas = document.getElementById(&apos;test-text-canvas&apos;), ctx = canvas.getContext(&apos;2d&apos;); (no output) Canvas除了能绘制基本的形状和文本，还可以实现动画、缩放、各种滤镜和像素转换等高级操作。如果要实现非常复杂的操作，考虑以下优化方案： 通过创建一个不可见的Canvas来绘图，然后将最终绘制结果复制到页面的可见Canvas中； 尽量使用整数坐标而不是浮点数； 可以创建多个重叠的Canvas绘制不同的层，而不是在一个Canvas中绘制非常复杂的图； 背景图片如果不变可以直接用&lt;img&gt;标签并放到最底层。","categories":[{"name":"canvas","slug":"canvas","permalink":"https://WLL-1017065322.github.io/blog/categories/canvas/"}],"tags":[{"name":"canvas","slug":"canvas","permalink":"https://WLL-1017065322.github.io/blog/tags/canvas/"}],"author":"along"},{"title":"js--进阶","slug":"JS核心知识归纳(进阶)","date":"2019-02-03T16:00:00.000Z","updated":"2019-05-12T03:46:35.829Z","comments":true,"path":"2019/02/04/JS核心知识归纳(进阶)/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/02/04/JS核心知识归纳(进阶)/","excerpt":"","text":"js–进阶1.原型链许多OO语言支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，实现继承则继承实际的方法。由于函数无签名，在JavaScript中无法实现接口继承。所以只能实现方法继承。实现继承主要依赖原型链。基本思想：利用原型，让那个一个引用类型继承另一个引用类型的属性和方法。A.prototype= new B();让原型对象等于另一个类型的实例。所有函数的默认原型都是Object的实例即A继承了B ；B 继承了Object; 什么是原型对象。我们知道每个构造函数一旦创建都有prototype指针指向它的原型对象（构造函数.prototype）。而原型对象（构造函数.prototype）会默认生成一个constructor指针又指向构造函数。在创建实例时，每个实例有一个proto指向该原型对象。原型对象内创建的所有方法会被所有实例共享。例： 12345Function.prototype = &#123; constructor : Function, __proto__ : parent prototype, some prototype properties: ... &#125;; 原型对象中的方法属性是被所有实例共享的。如果含有引用类型的属性，如数组，修改person1中的数组属性，也会导致person2中的该属性发生变化。 什么是原型链？函数的原型对象constructor默认指向函数本身，原型对象除了有原型属性外，为了实现继承，还有一个原型链指针proto，该指针指向上一层的原型对象，而上一层的原型对象的结构依然类似，这样利用proto一直指向Object的原型对象上，而Object的原型对象用Object.prototype.proto = null表示原型链的最顶端，如此变形成了javascript的原型链继承，同时也解释了为什么所有的javascript对象都具有Object的基本方法。 原型链就是创建一个构造函数，它会默认生成一个prototype属性并指向原型对象。使用下一个构造函数的原型对象作为这个构造函数的实例。即 A.prototype = new B(); 在下下一个构造函数的原型对象 = new nextFuction。这样下去就会构成一条实例与原型之间的链条，这就是原型链。 2.继承构造函数A()和实例a1 a2之间的关系；var a1 = new A(); var a2 = new A();实例a1与实例a2是独立的实例和原型的关系 a1.proto = A.prototype构造函数A()和其原型的关系 A.prototype.constructor=A 6种继承方式原型链继承本质:是子用类型B的原型等于超类型的实例,B.prototype= new A() 构造函数继承本质:是子用类型的构造函数内部调用A(),B(){A.call(this,**);} 组合继承本质原型链和构造函数的组合，原型继承方法，构造函数继承属性 原型式继承本质:基于已有对象创建一个对象,即对象A的浅拷贝,var b= Object.create(A) 寄生式继承本质:创建一个用于封装继承过程的函数,function b(A){var clone = Object.create(A) ;clone.=;return clone;} 寄生组合继承本质:寄生式继承超类型A的原型,并将结果赋值给子类型的原型;或对对象A的原型浅拷贝，function B(**){ 1A.call(this,**) }function c(A,B){var clone = Object.create(A.prototype); clone.constructor = B;B.prototype=clone;) ;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132 function Person(name) &#123; this.name = [&apos;123&apos;,&apos;456&apos;,&apos;789&apos;,name]; &#125; Person.prototype.go = function()&#123; return console.log(this.name) &#125; Person.prototype.sex = [&apos;男&apos;,&apos;女&apos;]; var ren = new Person(); console.log(&apos;构造函数和原型的关系:&apos;,Person.prototype.constructor ===Person) console.log(&apos;实例和原型的关系&apos;,ren.__proto__ ===Person.prototype) // 原型链继承 // 缺点1.不能向person中传递参数； // 缺点2.超类型的原型属性会被其他实例共享，一个实例改变，则其他实例也改变。 // 下面2个原型的顺序不能换 function Shuagnfeng(love) &#123; this.love = [&apos;fd&apos;,&apos;fddfdf&apos;]; &#125; Shuagnfeng.prototype = new Person(); console.log(&apos;会误会超类型Person:&apos;,Shuagnfeng.prototype.constructor ===Person) //true console.log(&apos;构成原型链,&apos;,Shuagnfeng.prototype.__proto__ ===Person.prototype) //true Shuagnfeng.prototype.constructor ===Shuagnfeng; Shuagnfeng.prototype.goWork = function()&#123; return console.log(&apos;原型链继承的方法&apos;); &#125; var child = new Person();Shuagnfeng.prototype.name.push(121);console.log(&apos;超类型实例2 child&apos;,child.name); var xiaozhang = new Shuagnfeng(&apos;dff&apos;); var xiaozhang1 = new Shuagnfeng(&apos;zzz&apos;); xiaozhang.go(); xiaozhang.goWork(); xiaozhang.name.push(&apos;只对xiaozhang增加属于超类型Person中array值&apos;,22); xiaozhang.love.push(&apos;只对xiaozhang增加属于构造函数中array值&apos;,22); xiaozhang.sex.push(&apos;只对xiaozhang增加属于超类型的原型中array值&apos;); console.log(&apos;xiaozhang.超类型Person中name&apos;,xiaozhang.name); console.log(&apos;xiaozhang1.超类型Person中name&apos;,xiaozhang1.name); console.log(&apos;xiaozhang.构造函数中中love&apos;,xiaozhang.love); console.log(&apos;xiaozhang1.构造函数中love&apos;,xiaozhang1.love); console.log(&apos;xiaozhang.超类型的原型中sex&apos;,xiaozhang.sex); console.log(&apos;xiaozhang1.超类型的原型中sex&apos;,xiaozhang1.sex);// 构造函数的继承// 优点，不会改变引用类型的属性，能传递参数// 缺点无法复用方法； function Jianbo() &#123; Person.call(this,&apos;构造函数的继承&apos;) &#125; var xiaonie = new Jianbo(); console.log(&apos;构造函数的继承xiaonie.name可传参数&apos;,xiaonie.name); // xiaonie.go(); // 不存在// 组合继承// 原型链继承方法、构造函数继承属性 function Nb(love) &#123; Person.call(this,&apos;nb&apos;) this.love = love &#125; Nb.prototype = new Person(&apos;12&apos;); console.log(&apos;12&apos;,Nb.prototype.constructor ===Person) // true console.log(&apos;13&apos;,Nb.prototype.constructor ===Nb)// false 因为重写原型，会使原型失去了constructor属性 Nb.prototype.constructor =Nb console.log(&apos;14&apos;,Nb.prototype.constructor ===Person) // false Nb.prototype.say = function()&#123; console.log(&apos;say&apos;,&apos;say&apos;) &#125; var nb= new Nb(); var nb1= new Nb(&apos;组合继承&apos;); nb.name.push(&apos;xiaoniubi&apos;); console.log(&apos;nb.name&apos;,nb.name); console.log(&apos;nb1.name&apos;,nb1.name); console.log(&apos;nb1.love&apos;,nb1.love); nb.go(); nb.say();// 原型式继承Object.create() 将基础对象传给object()函数 // 本质是浅复制 副本的引用类型会被改变// 缺点：引用类型的属性会被共享 和原型链继承差不多// 使用场景： 让一个对象与另一个对象的保持类似function object(o)&#123; function F()&#123;&#125; F.prototype= o; return new F();&#125;var animal = &#123; name:&apos;原型式继承默认值&apos;, friends:[1,2,3,4]&#125;var haha= object(animal);var gaga = Object.create(animal);var haha1= object(animal);console.log(&apos;haha&apos;,haha.name);console.log(&apos;gaga&apos;,gaga.name);haha.name=&apos;原型式继承name值变了&apos;;haha.friends.push(&apos;原型式继承array值变了&apos;);console.log(&apos;haha&apos;,haha.name);console.log(&apos;haha1&apos;,haha1.name);console.log(&apos;haha&apos;,haha.friends);console.log(&apos;haha1&apos;,haha1.friends);// 寄生式继承// 能继承方法，但方法不能复用function createAnother(original)&#123; var clone = object(original); clone.say = function()&#123; console.log(&apos;寄生式继承方法&apos;) &#125; return clone;&#125;var hh = createAnother(animal);hh.name=&apos;寄生式继承&apos;console.log(&apos;hh&apos;,hh.name);hh.say() // 寄生组合式// 所有方式中最有效的方式 只调用继承的构造函数一次// 判断实例和原型的关系 使用instanceof 和 isPrototypeOf() console.log(&apos;实例和原型的关系&apos;,xiaozhang instanceof Shuagnfeng); console.log(&apos;实例和原型的关系&apos;,xiaozhang instanceof Person); console.log(&apos;实例和原型的关系&apos;,xiaozhang instanceof Object); console.log(&apos;实例和原型的关系&apos;,Object.prototype.isPrototypeOf(xiaozhang)); console.log(xiaozhang.__proto__); 3.事件委托事件处理程序 获取事件对象 事件目标好处 减少DOM 操作 ，减少性能 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;div id=&quot;list&quot;&gt; &lt;img id=&quot;1&quot; src=&quot;1.png&quot;&gt; &lt;img id=&quot;3.2.2&quot; src=&quot;3.2.2.png&quot;&gt; &lt;img id=&quot;3.2&quot; src=&quot;3.2.png&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var EventUtil = &#123; addHandler: function(element,type,handler) &#123; if(element.addEventListener) &#123; element.addEventListener(type,handler,false) &#125; else if(element.attachEvent)&#123; element.attachEvent(&quot;on&quot; + type, handler); &#125; else &#123; element[&quot;on&quot; + type] = handler; &#125; &#125;, removeHandler:function(element,type,handler) &#123; if(element.removeEventListener) &#123; element.removeEventListener(type,handler,false) &#125; &#125;, getEvent:function(event)&#123; return event ? event : window.event; &#125;, getTarget:function(event)&#123; return event.target || event.srcElement; &#125;, &#125; var list = document.getElementById(&apos;list&apos;) EventUtil.addHandler(list,&apos;click&apos;,function(ev)&#123; event= EventUtil.getEvent(ev); var target = EventUtil.getTarget(event); alert(target.id); &#125;) // list.onclick = function(ev)&#123;// var ev = ev || window.event;// var target = ev.target || ev.srcElement;// console.log(target.id);// &#125; &lt;/script&gt; 4.跨域造成跨域的原因：浏览器的同源策略，即XMLHttpRequest(XHR)对象只能访问同一域中的资源这是种防止恶意行为的安全策略。第二个：浏览器中不同域的框架之间是不能进行js的交互操作的。 何谓同源:URL由协议、域名、端口和路径组成，如果两个URL的协议、域名和端口相同，则表示它们同源。 在浏览器中，、、、等标签属于DOM， 非XHR对象，是可以加载跨域资源 跨域方法(实践中后两种最常用，所以重点介绍):(1) 通过jsonp跨域ajax请求受同源策略影响，不允许进行跨域请求，而script标签src属性中的链接却可以访问跨域的js脚本，利用这个特性，服务端不再返回JSON格式的数据，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。(2) 通过修改document.domain来跨子域(3) 使用window.name来进行跨域(4) 使用HTML5中新引进的window.postMessage方法来跨域传送数据(5) 使用代理服务器,使用代理方式跨域更加直接，因为同源限制是浏览器实现的。如果请求不是从浏览器发起的，就不存在跨域问题了。 123456使用本方法跨域步骤如下：1. 把访问其它域的请求替换为本域的请求2. 服务器端的动态脚本负责将本域的请求转发成实际的请求为了通过Ajax从http://localhost:8080访问http://localhost:8081/api，可以将请求发往http://localhost:8080/api。然后利用Apache Web服务器的Reverse Proxy功能做如下配置：ProxyPass /api http://localhost:8081/api (6) CORS全称是”跨域资源共享“（Cross-origin resource sharing),CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能 发送请求时，附加一个额外的Origin头部IE：XDR(XDomainRequest) 创建一个xdr实例，调用open() ,再send()方法；其他的，原生的支持，使用绝对的URL即可。 附：ajax的扩展，comment/Web Sockets(7) fetch api 5.输入url之后，到底发生了什么？ 6 JS引擎浏览器内核又可以分成两部分：渲染引擎(layout engineer或者RenderingEngine)和JS引擎。JS的引擎深入分析链接描述10分钟理解JS引擎的执行机制http://www.ruanyifeng.com/blo…JS引擎负责对JavaScript进行解释、编译和执行，以使网页达到一些动态的效果。 js的几种引入方式；js引擎是单线程 异步的— 任务队列 事件 和回调函数 Event Loop是通过的事件循环(event loop),实现单线程和异步的。单线程：同一时刻只能执行一个代码块将要执行的代码放在任务队列中，但js引擎执行代码块结束，事件循环会执行任务队列中的下一个任务。Event Loop 负责监控代码执行和管理任务队列。异步的，即可通过事件 回调等方式，向任务队列中添加新任务。 JS的执行机制是 首先判断JS是同步还是异步,同步就进入主进程,异步就进入event table异步任务在event table中注册函数,当满足触发条件后,被推入event queue同步任务进入主线程后一直执行,直到主线程空闲时,才会去event queue中查看是否有可执行的异步任务,如果有就推入主进程中以上三步循环执行,这就是event loop 准确的划分方式是:macro-task(宏任务)：包括整体代码script，setTimeout，setIntervalmicro-task(微任务)：Promise，process.nextTick按照这种分类方式:JS的执行机制是 执行一个宏任务,过程中如果遇到微任务,就将其放到微任务的【事件队列】里当前宏任务执行完成后,会查看微任务的【事件队列】,并将里面全部的微任务依次执行完重复以上2步骤,结合event loop(1) event loop(2) ,就是更为准确的JS执行机制了。 7 错误监控前端错误的分类 运行时错误（代码错误） 资源加载错误 接口错误 错误的捕获方式 运行时错误的捕获方式： 1234567try...catchwindow.onerror 含有详细的error信息 window.onerror = function(msg, url, lineNo, columnNo, error)&#123;&#125;window.addEventListener(&apos;error&apos;) window.addEventListener(&apos;error&apos;, event =&gt; &#123; console.log(&apos;addEventListener error:&apos; + event.target); &#125;, true); 资源加载错误： 123object.onerror（如img,script）performance.getEntries()Error事件捕获 接口错误： 12所有http请求都是基于xmlHttpRequest或者fetch封装的。所以要捕获全局的接口错误，方法就是封装xmlHttpRequest或者fetch 结论1.使用window.onerror捕获JS运行时错误2.使用window.addEventListener(‘unhandledrejection’)捕获未处理的promise reject错误3.重写console.error捕获console.error错误4.在跨域脚本上配置crossorigin=”anonymous”捕获跨域脚本错误window.addEventListener(‘error’)捕获资源加载错误。因为它也能捕获js运行时错误，为避免重复上报js运行时错误，此时只有event.srcElement inatanceof HTMLScriptElement或HTMLLinkElement或HTMLImageElement时才上报5.重写window.XMLHttpRequest和window.fetch捕获请求错误 延伸：跨域的js运行错误可以捕获吗，错误提示什么，应该怎么处理？ 1234可以。Script error1.在script标签增加crossorigin属性2.设置js资源响应头Access-Control-Allow-Orgin:* 上报错误的基本原理 121. 采用Ajax通信方式上报2. 利用Image对象上报 https://segmentfault.com/a/1190000014728771#articleHeader19","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"}],"author":"along"},{"title":"基本类型和引用类型的值","slug":"变量、作用域与内存问题","date":"2019-02-01T16:00:00.000Z","updated":"2019-05-12T03:46:35.933Z","comments":true,"path":"2019/02/02/变量、作用域与内存问题/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/02/02/变量、作用域与内存问题/","excerpt":"","text":"4.1基本类型和引用类型的值ECMAScript变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。 数据类型: 基本类型值：Undefined、Null、Boolean、Number、String； 引用类型值，也就是对象类型：Object、Array、Function、Date等； 声明变量时不同的内存分配 基本类型值：存储在栈（stack）中的简单数据段，它们的值直接存储在变量访问的位置。这是因为这些基本类型占据的空间是固定的，所以可以将它们存储在较小的内存区域- 栈中。这样存储更便于迅速查寻变量的值。 引用值：存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存地址。这是因为：引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。 不同的内存分配机制也带来了不同的访问机制 在javascript中是不允许直接访问保存在堆内存中的对象的，也就是说不能直接操作对象的内存空间。所以在访问一个对象时，首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，这就是传说中的按引用访问。而原始类型的值则是可以直接访问到的。 注意：当复制保存着对象的某个变量时，操作的事对象的引用。但在为对象添加属性时，操作的是实际的对象 复制变量的不同 基础类型值：在将一个保存着基础类型值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，此后这两个变量是完全独立的，他们只是拥有相同的value而已。 12345678function addTen(num) &#123; num += 10; return num;&#125;var count = 20;var result = addTen(count);console.log(count); //20 没有变化console.log(result); //30 引用值：在将一个保存着对象内存地址的变量复制给另一个变量时，会把这个内存地址赋值给新变量，也就是说这两个变量都指向了堆内存中的同一个对象，他们中任何一个作出的改变都会反映在另一个身上。（这里要理解的一点就是，复制对象时并不会在堆内存中新生成一个一模一样的对象，只是多了一个保存指向这个对象指针的变量罢了） 123456function setName(obj) &#123; obj.name = &quot;Nicholas&quot;;&#125;var person = new Object();setName(person);console.log(person.name); //&quot;Nicholas&quot; 参数传递的不同首先我们应该明确一点：ECMAScript中所有函数的参数都是按值来传递的。但是为什么涉及到基础类型与引用类型的值时仍然有区别呢，还不就是因为内存分配时的差别。 基础类型值：只是把变量里的值传递给参数，之后参数和这个变量互不影响。 引用类型值：对象变量它里面的值是这个对象在堆内存中的内存地址，这一点你要时刻铭记在心！因此它传递的值也就是这个内存地址，这也就是为什么函数内部对这个参数的修改会体现在外部的原因了，因为它们都指向同一个对象呀。或许我这么说了以后你对书上的例子还是有点不太理解，那么请看图吧： 所以，如果是按引用传递的话，是把第二格中的内容（也就是变量本身）整个传递进去（就不会有第四格的存在了）。但事实是变量把它里面的值传递（复制）给了参数，让这个参数也指向原对象。因此如果在函数内部给这个参数赋值另一个对象时，这个参数就会更改它的值为新对象的内存地址指向新的对象，但此时原来的变量仍然指向原来的对象，这时候他们是相互独立的；但如果这个参数是改变对象内部的属性的话，这个改变会体现在外部，因为他们共同指向的这个对象被修改了呀！来看下面这个例子吧：（传说中的call by sharing） 12345678910111213141516171819var obj1 = &#123; value:&apos;111&apos;&#125;; var obj2 = &#123; value:&apos;222&apos;&#125;; function changeStuff(obj)&#123; obj.value = &apos;333&apos;; obj = obj2; return obj.value;&#125; var foo = changeStuff(obj1); console.log(foo);// &apos;222&apos; 参数obj指向了新的对象obj2console.log(obj1.value);//&apos;333&apos; obj1仍然指向原来的对象,之所以value改变了,是因为changeStuff里的第一条语句，这个时候obj是指向obj1的 .再啰嗦一句，如果是按引用传递的话，这个时候obj1.value应该是等于&#39;222&#39;的 可以把ECMAScript函数的参数想象成局部变量 4.1.4 检测类型如果变量的值是一个对象或null，则typeof操作符会返回&quot;object&quot;. 通常我们并不是想知道某个值是对象，而是想知道它是什么类型的对象。为此，ECMAScript提供了instanceof操作符； 如果对象是给定引用类型的实例，那么instanceof操作符就会返回true。 123console.log(person instanceof Object); //变量person是Object吗？console.log(colors instanceof Array); //变量colors是Array吗？console.log(pattern instanceof RegExp); //变量pattern是RegExp吗? 根据规定，所有引用类型的值都是Object的实例。在检查一个引用类型值和Object构造函数时，instanceof操作符始终会返回true。 4.2执行坏境和作用域每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行后，栈将其环境弹出，把控制权返回给之前的执行环境。 每个环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它 当代码在一个环境执行时，会创建变量对象的一个作用域链。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问 4.2.1 延长作用域链有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。有两种情况下会发生这种现象。 try-catch 语句中的 catch 块 with 语句 对 with 来说，将会指定对象添加到作用域链中。对 catch 来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。 123456789101112131415var oMyself = &#123; sFirstname: &quot;Aidan&quot;, sLastName: &quot;Dai&quot;&#125;function create()&#123; var sLastName = &quot;Wen&quot; with(oMyself)&#123; //将oMyself作为自己的执行环境 sAllName = sFirstname +&quot; &quot; + sLastName; &#125; return sAllName;&#125;var sMyName = create();console.log(sMyName); //Aidan Dai 4.2.2 没有块级作用域对于有块级作用域的语言来说，for语句初始化变量的表达式所定义的变量，只会存在于循环的环境之中。而对于JavaScript来说，由for语句创建的变量i即使在for循环执行结束后，也依旧会存在于循环外部的执行环境中。 1. 声明变量使用var声明的变量会自动被添加到最接近的环境中。在函数内部，最接近环境的就是函数的局部环境；在with语句中，最接近的环境就是函数环境。如果初始化变量时没有使用var声明，该变量会自动被添加到全局环境。 注意：在编写JavaScript中，不声明而直接初始化变量时一个错误的做法，因为这样可能会导致意外。在严格模式下，初始化未经声明的变量会导致错误。 2.查询标识符搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境找到，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域向上搜索。搜索过程将一直追溯到全局环境的变量对象。在全局环境也没找到的话则说明该变量尚未声明。 1234567var color = &quot;blue&quot;;function getColor() &#123; return color;&#125;console.log(getColor()); //&quot;blue&quot;; 4.3 垃圾收集JavaScript具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。JavaScript垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是时时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。 变量生命周期 什么叫不再使用的变量？不再使用的变量也就是生命周期结束的变量，当然只可能是局部变量，全局变量的生命周期直至浏览器卸载页面才会结束。局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈或堆上分配相应的空间，以存储它们的值，然后再函数中使用这些变量，直至函数结束（闭包中由于内部函数的原因，外部函数并不能算是结束 一旦函数结束，局部变量就没有存在必要了，可以释放它们占用的内存。貌似很简单的工作，为什么会有很大开销呢？这仅仅是垃圾回收的冰山一角，就像刚刚提到的闭包，貌似函数结束了，其实还没有，垃圾回收器必须知道哪个变量有用，哪个变量没用，对于不再有用的变量打上标记，以备将来回收。用于标记无用的策略有很多，常见的有两种方式 4.3.1 标记清除这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。至于怎么标记有很多种方式，比如特殊位的反转、维护一个列表等，这些并不重要，重要的是使用什么策略，原则上讲不能够释放进入环境的变量所占的内存，它们随时可能会被调用的到。 垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了，因为环境中的变量已经无法访问到这些变量了，最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。 4.3.2 引用计数在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。 4.3.3 性能问题垃圾收集器是周期性运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大的。在这种情况下，确定垃圾收集的时间间隔是一个非常重要的问题。 事实上，在有的浏览器中可以触发垃圾收集过程，但我们不建议这样做。在IE中调用window.CollectGarbage()方法会立即执行垃圾收集。在Opera7及更高版本中，调用window.opera.collect()也会启动垃圾收集例程。 4.3.4管理内存确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保存必要数据。一旦数据不再可用，最好通过将其值设置为null来释放其引用——这个方法叫做解除引用(dereferencing)。这一做法适用于大多数全局变量和全局对象属性。局部变量会在它们离开执行环境时自动被解除引用。 12345678910function createPerson(name) &#123; var localPerson = new Object(); localPerson.name = name; return localPerson;&#125;var globalPerson = createPerson(&quot;Nicholas&quot;);//手工解除globalPerson的引用globalPerson = null; 4.4 小结基本类型值和引用类型值具有以下特点: 基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中； 从一个变量向另一个变量复制基本类型的值，会创建这个值得一个副本； 引用类型的值是对象，保存在堆内存中； 包含引用类型值得变量实际上包含的并不是对象本身，而是指向该对象的指针； 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象； 确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以使用instanceof操作符。所有变量(包括基本类型和引用类型)都存在于一个执行环境(也称为作用域)当中，这个执行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。 https://segmentfault.com/a/1190000008929249#articleHeader0","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"}],"author":"along"},{"title":"JS基础","slug":"js核心知识(基础)","date":"2019-01-31T16:00:00.000Z","updated":"2019-05-12T03:46:35.919Z","comments":true,"path":"2019/02/01/js核心知识(基础)/","link":"","permalink":"https://WLL-1017065322.github.io/blog/2019/02/01/js核心知识(基础)/","excerpt":"","text":"JS基础1.数据类型？6基本数据类型： Undefined, Null, Boolean, Number, String ,Symbol引用类型： Array Object Date Function 区别：基本类型值保存在栈空间，我们通过按值来访问的。引用类型，的值是对象，栈内存中存放地址指向堆内存中的对象。是按引用访问的。栈内存中存放的只是该对象的访问地址，在堆内存中为这个值分配空间。1.基本数据类型不可以添加/删除属性和方法；2.复制的方式不同；引用类型复制的时候，复制的是指针，2个变量实际指的是同一个对象。3.函数的参数是按值传递的检测数据类型 typeof instanceof转型数据类型 12显式：Boolean()/Number()/pareseInt()/pareseFloat()/toString()/String()隐私： +、 赋值 区别： undefined与null 的区别 null： 1234是Null类型的值.是个空值，空对象指针.typeof null，结果为Object;null用来表示尚未存在的对象. undefined : 12345是Undefined类型的值。typeof undefined，结果为undefined;一个声明了变量，但未初始化值，结果就是undefined没有返回值的函数，返回的也是undefined,没有实参的形参也是undefined; symbol表示独一无二的值Symbol 值通过Symbol函数生成对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。因为symbol的每个值不相等。Symbol 值不能与其他类型的值进行运算，会报错Symbol 值可以显式转为字符串。Symbol 值也可以转为布尔值，但是不能转为数值Symbol 值作为对象属性名时，不能用点运算符。 2.面向对象？何为面向对象 万物皆对象， 对象又有如下特点：  抽象：抓住核心问题 封装：只能通过对象来访问方法 继承：从已有的对象下继承出新的对象 多态：多对象的不同形态创建对象的5种方式 1.工厂方式创建对象：面向对象中的封装函数(内置对象) 2.构造函数创建对象 优点：创建自定义函数意味着将来可以将它的实例标识为一种特定的类型，这是构造函数胜过工厂模式的地方 缺点：每个方法都要在每个实例上重新创建一遍 3、对象字面量方式创建对象 4、用原型方式  1、优点：可以让所有的对象实例共享它所包含的属性和方法 2、缺点：原型中是所有属性都是共享的，但是实例一般都是要有自己的单独属性的。所以一般很少单独使用原型模式。 5.混合模型：构造函数模式定义实例属性，而原型模式用于定义方法和共享的属性总结：使用上述的混合法 3.Array数组的增加 1234567array.push() 向数组末尾添加元素，返回的是添加后新数组的长度，原有数组改变array.unshift() 向数组开头添加元素，返回的是添加后新数组的长度，原有数组改变array.splice(n,m) 从索引n开始删除m个元素，把删除的内容当做新数组返回，原有数组array.concat()// ES6的合并数组[...arr1, ...arr2, ...arr3]Array.prototype.push.apply(arr1,arr2);)----将arr2追加到arr1中，返回数组的长度 数组的删除 12345array.pop() 删除数组的最后一项，返回的是删除的那一项，原有数组改变array.shift() 删除数组的的第一项，返回的是删除的那一项，原有数组改变splice(n,m,x) 从索引n开始删除m个元素，然后插入元素x，把删除的内容当做新数组返回，原有数组改变。作删除使用，x不传入数据既可。slice(n,m) 从索引n开始删除m个元素,返回删除项，原数组不变length 减小数组的长度，实际是从数组尾部删除元素，改变原数组。 改 1其实只有一种 splice(),但delete方法，我个人感觉算修改不属于删除，详情请见实例 查 12345678indeOf() lastIndexOf()find()findIndex()includes()[1, 4, -5, 10].find((n) =&gt; n &lt; 0) // -5[1, 4, -5, 10].findIndex((n) =&gt; n &lt; 0) // 2[1, 2, 3].includes(2) // true 排序array.reverse() 把数组倒过来排序，原有数组改变array.sort() 可以实现由大到小或者由小到大的排序 但是直接写sort只能排序十以内的数字 3.1类型转换数组 对象 字符串 的转换； array –&gt;string： 12join(&quot;+&quot;) 把数组的每一项拿出来用指定分隔符隔开 ；tostring 把数组的每一项拿出来用逗号隔开，原有数组不变 obj –&gt; string 12JSON.parse(); //可以将json字符串转换成json对象JSON.stringify(); //可以将json对象转换成json对符串 string–&gt;array: 1split(“,”) obj –&gt; array： 12For… in循环赋值法Array.from() number –&gt; array 1Array.of() string –&gt; number (4种) 1234Number() parseFloat() // 如果parseInt()和parseFloat()不能够把指定的字符串转换为数字，它们就会返回NaN parseInt(&apos;&apos;eleven&quot;); // Returns Nan parseInt() // parseInt()是取整，即丢弃小数部分,保留整数部分 parseInt(2.7) ==&gt;3 +number // var c = +&apos;2&apos; typeof c ---number string &lt;– number (4种)var c = String(number)var c = number + ‘’var c = number.toString(8) // 将number 转换成8进制的数字 且c的类型是stringvar c = number.toFixed(1); //数字转换为字符串，并且显示小数点后的指定的位数 例 number = 123.476,则c= 123.5” 深浅拷贝对象和数组的拷贝有两种浅拷贝即 拷贝了指针指向，当一个对象的值改变会影响另一个对象的值。深拷贝， 拷贝的是真正的值。2者相互独立，互不干扰。浅拷贝的方法4种方法slice() concat() 赋值法 遍历注：concat 和 slice 对一维数组 能算是深拷贝;2维的 是浅拷贝 123456789101112131415161718192021222324252627282930var a= [1,2,3,4]b= a.concat();c=a.concat();b[0] = 5;c[0] = 6;a // [1,2,3,4]b // [5,2,3,4]c // [6,2,3,4]var aa= [[1,1],[2,2],3,4]bb= aa.concat();cc=aa.concat();bb[1][0] = 5;cc[0] = 6;aa // [[1,1],[5,2],3,4]b // [[1,1],[5,2],3,4]c // [6,[5,2],3,4]var shallowCopy = function(obj) &#123;// 只拷贝对象if (typeof obj !== &apos;object&apos;) return;// 根据obj的类型判断是新建一个数组还是对象var newObj = obj instanceof Array ? [] : &#123;&#125;;// 遍历obj，并且判断是obj的属性才拷贝for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; newObj[key] = obj[key]; &#125;&#125;return newObj;&#125; 深拷贝的方法5种方法：一维数组和对象的concat slice法 JSON.parse(JSON.stringify(arr)) 和遍历法 解构赋值法示例：（前3种毕竟简单，这里也不表述）解构赋值法：const a1 = [1, 2]; const a2 = […a1];或者const […a2] = a1; 1234567891011var deepCopy = function(obj) &#123;if (typeof obj !== &apos;object&apos;) return;var newObj = obj instanceof Array ? [] : &#123;&#125;;for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; newObj[key] = typeof obj[key] === &apos;object&apos; ? deepCopy(obj[key]) : obj[key]; &#125;&#125;return newObj;&#125; 还有一些常用方法如filter() forEach() map() every() some() 详情请见：最全最细致的数组的方法整理 es5+es6 5.对象的属性ES5的属性特性包括下面六个： configurable: 表示能否通过delete来删除属性从而重新定义属性，能够修改属性的特性,默认为true enumberable: 表示是否能通过for-in循环返回属性。默认为true writable: 是否可以修改属性, 默认为true value: 包含这个属性的数据值。读取属性值时3,从这个属性读，写入属性时，把新值保存到这个位置。默认值为undefine. getter: 在读取属性时，调用的函数 setter: 在写入属性时调用的函数 特别注意：一旦调用了Object.defineProperty方法之后，那些未定义的特性值除了configurable为false之外，其他都为undefined; 6.DOM DOM是针对HTML和XML文档的一个API(应用程序编程接口). DOM描绘了一个层次化的节点树, 允许开发人员添加, 移除和修改页面的某一部分. 常用的DOM方法:1)查找a) getElementById(id) //通过元素Id，唯一性b) getElementsByTagName() //通过标签名称c) getElementsByName() //通过元素的Name属性的值(IE容错能力较强， 1会得到一个数组，其中包括id等于name值的) 2）添加、移除、替换、插入 复制c) appendChild(node) // 可添加 可移动位置;可添加元素 可添加文本d) removeChild(node)e) replaceChild(取代别人的mode,已有节点) // 替换已有节点f) insertBefore(插入节点,已有节点) //在已有的子节点前插入一个新的子节点g) cloneNode(true/false) //深浅复制 3)创建 123createDocumentFragment() //创建一个DOM片段 createElement() //创建一个具体的元素 div p span createTextNode() //创建一个文本节点 4)i) getAttribute()j) setAttribute() 5 常用的DOM属性a) innerHTML 节点(元素)的文本值b) parentNode 节点(元素)的父节点c) childNodesd) attributes 节点(元素)的属性节点 6.两个节点的关系 7.JS获取盒模型宽高为了方便书写，以下用dom来表示获取的HTML的节点。 dom.style.width/height 这种方式只能取到dom元素内联样式所设置的宽高，也就是说如果该节点的样式是在style标签中或外联的CSS文件中设置的话，通过这种方法是获取不到dom的宽高的。 dom.currentStyle.width/height 这种方式获取的是在页面渲染完成后的结果，就是说不管是哪种方式设置的样式，都能获取到。 但这种方式只有IE浏览器支持。 window.getComputedStyle(dom).width/height 这种方式的原理和2是一样的，这个可以兼容更多的浏览器，通用性好一些。 dom.getBoundingClientRect().width/height 这种方式是根据元素在视窗中的绝对位置来获取宽高的 dom.offsetWidth/offsetHeight这个就没什么好说的了，最常用的，也是兼容最好的。 8.通用的事件侦听器主要考核 事件处理程序 和event对象及其属性和方法 12345678910111213141516171819202122232425262728293031323334353637383940var EventUtil = &#123; addHandler: function(element,type,handler) &#123;//添加事件处理程序 if(element.addEventListener) &#123; element.addEventListener(type,handler,false) &#125; else if(element.attachEvent)&#123; element.attachEvent(&quot;on&quot; + type, handler); &#125; else &#123; element[&quot;on&quot; + type] = handler; &#125; &#125;, removeHandler:function(element,type,handler) &#123;//移除事件处理程序 if(element.removeEventListener) &#123; element.removeEventListener(type,handler,false) &#125; &#125;, getEvent:function(event)&#123;// 获取事件对象 return event ? event : window.event; &#125;, getTarget:function(event)&#123;// 获取事件的目标 return event.target || event.srcElement; &#125;, preventDefault()&#123; (event) =&gt;&#123; if(event.preventDefault)&#123;event.preventDefault()&#125; else &#123;event.returnValue= false&#125; &#125; &#125;, stopPropagation()&#123; (event) =&gt;&#123; if(event.stopPropagation)&#123;event.stopPropagation()&#125; else &#123;event.cancelBubble= true;&#125; &#125; &#125; &#125; var list = document.getElementById(&apos;list&apos;) EventUtil.addHandler(list,&apos;click&apos;,function(ev)&#123; event= EventUtil.getEvent(ev); var target = EventUtil.getTarget(event); alert(target.id); &#125;) 9.实现点击ul中li元素方法有很多，闭包法、立即执行函数法、、事件委托法；但本题主要考核 DOM事件流 利用事件委托，减少dom操作，提高性能 123456var list = document.getElementById(&apos;list&apos;) list.onclick = function(ev)&#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; console.log(target.id); &#125; 10.Ajax原生的写法 1234567891011121314151617var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; console.log(xhr.status) if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status ==304)&#123; var hh = xhr.responseText; var haha1 = document.getElementById(&apos;wokao&apos;); haha1.innerHTML = hh; &#125;else&#123; alert(&apos;failed11&apos;,xhr.status); &#125; &#125; &#125; xhr.open(&quot;get&quot;,&quot;http://10.10.65.109:8888/text.json&quot;,true); xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;); // xhr.responseType = &quot;json&quot;; xhr.send(null); 何为异步？ 异步与同步的概念实现异步的方法：回调 事件 promiseAjax最大特性：可以实现动态不刷新（局部刷新）.优点： 123通过异步模式，提升了用户体验优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。 缺点 12345671、ajax不支持浏览器back按钮。2、安全问题 AJAX暴露了与服务器交互的细节。3、对搜索引擎的支持比较弱。4、破坏了程序的异常机制。5、不容易调试。**post 和get的区别：**  GET请求会将参数跟在URL后进行传递，而POST请求则是作为HTTP消息的实体内容发送给WEB服务器。当然在Ajax请求中，这种区别对用户是不可见的。 GET方式请求的数据会被浏览器缓存起来，因此其他人就可以从浏览器的历史记录中读取到这些数据，例如账号和密码等。在某种情况下，GET方式会带来严重的安全问题。而POST方式相对来说就可以避免这些问题。 “GET方式提交的数据最多只能是1024字节”，post无 get请求和post请求在服务器端的区别:在客户端使用get请求时,服务器端使用Request.QueryString来获取参数,而客户端使用post请求时,服务器端使用Request.Form来获取参数. 12**适用场景：**POST用于创建资源，资源的内容会被编入HTTP请示的内容中。例如，处理订货表单、在数据库中加入新数据行等。 当请求无副作用时（如进行搜索），便可使用GET方法；当请求有副作用时（如添加数据行），则用POST方法。 1若符合下列任一情况，则用POST方法： 请求的结果有持续性的副作用，例如，数据库内添加新的数据行。 若使用GET方法，则表单上收集的数据可能让URL过长。 要传送的数据不是采用7位的ASCII编码。若符合下列任一情况，则用GET方法： 请求是为了查找资源，HTML表单数据仅用来帮助搜索。 请求结果无持续性的副作用。 收集的数据及HTML表单内的输入字段名称的总长不超过1024个字符。 对cookie localStorage sessionStorage的理解 localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等 1**cookie:**  cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。 cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。 sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。 存储大小： cookie数据大小不能超过4k。 sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 有期时间： localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage 数据在当前浏览器窗口关闭后自动删除。 cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 作用域不同: sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面； localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。 Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。 Web Storage 的 api 接口使用更方便。sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。 而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。 除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。总之：cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生cookie优点：极高的扩展性和可用性 缺点： 数量和长度受限、安全问题cookie 和session 的区别：1、cookie数据存放在客户的浏览器上，session数据放在服务器上。2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗 1考虑到安全应当使用session。 3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能 1考虑到减轻服务器性能方面，应当使用COOKIE。 4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。5、所以个人建议： 12将登陆信息等重要信息存放为SESSION其他信息如果需要保留，可以放在COOKIE中 12.IE的不同之处IE支持currentStyle，FIrefox使用getComputStyle IE 使用innerText，Firefox使用textContent 滤镜方面：IE:filter:alpha(opacity= num)；Firefox：-moz-opacity:num 事件方面：IE：attachEvent：火狐是addEventListener 鼠标位置：IE是event.clientX；火狐是event.pageX IE使用event.srcElement；Firefox使用event.target IE中消除list的原点仅需margin:0即可达到最终效果；FIrefox需要设置margin:0;padding:0以及list-style:none CSS圆角：ie7以下不支持圆角 13.this工作原理原则，那就是this指的是调用函数的那个对象。 javascript 的this主要是看如何调用这个函数，而不是这个函数所在的作用域。obj.fn() fn中的 this 就是 obj。 fn() this是undifine, 而在js进入函数之前，会有 if(!this) { this = window} 这样的操作。 this 一共有六种不同的值： 普通函数调用，this为全局对象或是undefined 作为对象的方法，this为那个对象 new 表达式，this为以该函数为原型的新创建的对象 使用 apply/call指定 this 用bind绑定固定的this 事件处理函数中的this是当前的触发事件的DOM元素(event.currentTarget)IE attachEvent添加的事件处理函数中this为window 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;this&lt;/title&gt;&lt;/head&gt;&lt;body&gt;在严格模式下，一般的函数调用中 this 的值是 undefined。&lt;button onclick=&quot;console.log(this)&quot; &gt; show this&lt;/button&gt;&lt;p id=&quot;hahah&quot;&gt;测试DOM元素(event.currentTarget)&lt;/p&gt;&lt;p id=&quot;ha&quot;&gt;测试DOM元素IE&lt;/p&gt;&lt;script type=&quot;text/javascript&quot;&gt;var obj=&#123;a:1&#125;;var aa = function func(a,b)&#123; console.log(&apos;this&apos;,this); console.log(&apos;this&apos;,a); return 1;&#125;var bb = function funb()&#123; console.log(&apos;this&apos;,this); &#125;bb.prototype= new aa();//obj.f = aa;/*作为对象的方法 ***/obj.f(123);//输出 obj 123aa(123); //输出 window 123(obj.f)();// obj 没懂(a=obj.f)(); // window(0,obj.f)(); // window/*call spply bind中this***/aa.call(&apos;call&apos;,1);// call 1aa.apply(&apos;apply&apos;,[1]); // apply 1var cc = aa.bind(&apos;bind&apos;,1); cc(22); //bind 1var cc1 = new cc(33)// func 1/***new 表达式，this为以 该函数为原型 的新创建的对象*/var dd = new aa(11,22); // func &#123;&#125;var bb1 = new bb();/****事件处理函数中的this**当前的触发事件的DOM元素(event.currentTarget)**IE attachEvent添加的事件处理函数中this为window*/function evtHandle(e)&#123; console.log(&apos;e.currentTarget.id&apos;,this.id); // console.log(&apos;e.target.id&apos;,this.id); // &#125;var elements = document.getElementById(&apos;hahah&apos;);var elements1 = document.getElementById(&apos;ha&apos;);elements.addEventListener(&apos;click&apos;,evtHandle,false);// ie专属 chrome下报错 // elements1.attachEvent(&apos;onclick&apos;,evtHandle);obj = &#123; go: function() &#123; console.info(&apos;oo&apos;,this) &#125; &#125;;(0 || obj.go)() // window&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 14.函数1.函数的调用方式 方法调用模型 var obj = { func : function(){};} obj.func() 函数调用模式 var aa = function(){} aa(); 构造器调用模式 apply/ call调用模式 立即执行函数(function(){}()) 区别：函数调用模式，有函数提升的；即aa() 无需必须在var aa = function(){} 后面 2.return的含义 注：return不一定非得用在function 中，也可以直接放在html中，如:onsubmit=”return false”; 语法：return 表达式;含义：语句结束函数执行，返回调用函数，而且把表达式的值作为函数的结果通常函数经过一系列的处理后需要给外部返回一个值,这个值一般用return返回出去,也可以是说return是向函数返回返回值,并终止函数的运行. return; 123含义：即 return null 无函数返回值；能中断方法的执行，但无法阻止事件的默认行为。把控制权返回给页面。 return false; 12345含义：相当于终止符；1. 一般是用来取消默认动作的。比如，终止表单提交。比如你单击一个链接除了触发你的onclick事件外还会触发一个默认事件就是执行页面的跳转。所以如果你想取消对象的默认动作（event.preventDefault();）就可以return false。2. return false 只在当前函数有效，不会影响其他外部函数的执行 retrun true； 12含义：相当于执行符。执行终止默认的事件行为 返回正确的处理结果。 15.闭包 闭包是指有权访问另一个函数作用域中的变量的函数. 创建闭包常见方式,就是在一个函数内部创建另一个函数.作用:1.匿名自执行函数 (function (){ … })(); 创建了一个匿名的函数，并立即执行它，由于外部无法引用它内部的变量，因此在执行完后很快就会被释放，关键是这种机制不会污染全局对象。2.缓存, 可保留函数内部的值3.实现封装4.实现模板5.给了js函数生成函数的能力，增加了js代码的抽象能力缺点1.造成内存泄露；变量内存无法被标记，导致内存不会被垃圾回收机制回收。为什么要用局部变量无法共享和长久的保存，而全局变量可能造成变量污染，所以我们希望有一种机制既可以长久的保存变量又不会造成全局污染。如何使用1.定义外层函数，封装被保护的局部变量。2.定义内层函数，执行对外部函数变量的操作。3.外层函数返回内层函数的对象，并且外层函数被调用，结果保存在一个全局的变量中。 123456789var getNum;function getCounter() &#123; var n = 1; var inner = function () &#123; return n++; &#125; return inner;&#125;getNum = getCounter();console.log(getNum()); //1 2 3 4 16.call aplly bindapply 、 call 、bind 三者都是用来改变函数的this对象的指向的；apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文；apply 、 call 、bind 三者都可以利用后续参数传参；bind是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。 123456789101112131415161718192021function fn(a,b)&#123; console.log(this); console.log(a); console.log(b);&#125;// bind(this,args...)bf = fn.bind(&quot;Bind this&quot;,10); // 没有任何输出，也就是说没有执行这个函数bf(); // &quot;Bind this&quot;,10,undefinedbf(20);// “Bind this”,10,20// 原函数不受影响fn(1,2); //window， 1，2bf2 = fn.bind(&quot;Bind this&quot;,1,2);bf2(); // &quot;Bind this&quot;,1,2// call(this,args...)fn.call(&quot;Call this&quot;,1) // &quot;Call this&quot;,1,undefinedfn.call(&quot;Call this&quot;,1,2) // &quot;Call this&quot;,1,2// apply(this,[args])fn.apply(&quot;Apply this&quot;,[1]) // &quot;Apply this&quot;,1,undefinedfn.apply(&quot;Apply this&quot;,[1,2]) // &quot;Apply this&quot;,1,2 17.js语言特性特性，即封装、继承、多态此处内容较多，便不详细叙述。注意一下继承的方式继承6方式： 1、拷贝继承：通用型 有new无new都可以用 2、类式继承：new构造函数—利用构造函数（类）继承的方式 3、原型继承：无new的对象—借助原型来实现对象继承对象 4. 属性继承：调用父类的构造函数call 5. 方法继承：用for in的形式 拷贝继承（jq也用拷贝继承） 18.”use strict”严格模式”的目的，主要有以下几个： 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; - 消除代码运行的一些不安全之处，保证代码运行的安全； - 提高编译器效率，增加运行速度； - 为未来新版本的Javascript做好铺垫。“严格模式”体现了Javascript更合理、更安全、更严谨的发展方向 19.加载方式1.延迟加载有些 js 代码并不是页面初始化的时候就立刻需要的，而稍后的某些情况才需要的。延迟加载就是一开始并不加载这些暂时不用的js，而是在需要的时候或稍后再通过js 的控制来异步加载。JS延迟加载有助于提高页面加载速度。 js的进程由解析和执行构成。所有的延迟加载方式都只是延迟了执行过程。解析从未停止js的执行顺序是自上而下。延迟加载几种方式： 123456defer 属性 defer的作用是，告诉浏览器，等到DOM加载完成后，再执行指定脚本。async 属性 async的作用是，使用另一个进程下载脚本，下载时不会阻塞渲染，下载好了 就执行。动态创建DOM方式 document.createElement 使用jQuery的getScript方法使用setTimeout延迟方法让JS最后加载（放在文档尾部） 2.同步加载，又称阻塞模式，会阻止浏览器的后续处理，停止了后续的解析，因此停止了后续的文件加载（如图像）、渲染、代码执行。 3.异步加载：也就是说第一个fun请求数据时，数据还未返回时便开始执行第二个fun了代表：ajax 回调 事件 promise 4.预加载一种浏览器机制，使用浏览器空闲时间来预先下载/加载用户接下来很可能会浏览的页面/资源，当用户访问某个预加载的链接时，如果从缓存命中,页面就得以快速呈现5.图片延迟加载的方式 https://segmentfault.com/a/1190000014728771#articleHeader19","categories":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://WLL-1017065322.github.io/blog/tags/javascript/"}],"author":"along"}]}