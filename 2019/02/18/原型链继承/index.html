<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>原型链-继承 | 阿龙的小型博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="along,along's Blog">
  
  <meta name="description" content="前言：​    对于有基于类的语言经验 (如 Java 或 C++) 的开发人员来说，JavaScript 有点令人困惑，因为它是动态的，并且本身不提供一个 class 实现。（在 ES2015/ES6 中引入了 class 关键字，但只是语法糖，JavaScript 仍然是基于原型的）。 ​    当谈到继承时，JavaScript 只有一种结构：对象。每个实例对象（ object ）都有一个私">
<meta name="keywords" content="javascript,原型链">
<meta property="og:type" content="article">
<meta property="og:title" content="原型链-继承">
<meta property="og:url" content="https://WLL-1017065322.github.io/myBlog/2019/02/18/原型链继承/index.html">
<meta property="og:site_name" content="阿龙的小型博客">
<meta property="og:description" content="前言：​    对于有基于类的语言经验 (如 Java 或 C++) 的开发人员来说，JavaScript 有点令人困惑，因为它是动态的，并且本身不提供一个 class 实现。（在 ES2015/ES6 中引入了 class 关键字，但只是语法糖，JavaScript 仍然是基于原型的）。 ​    当谈到继承时，JavaScript 只有一种结构：对象。每个实例对象（ object ）都有一个私">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://wll-1017065322.github.io/assets/1556451911262.png">
<meta property="og:image" content="https://wll-1017065322.github.io/assets/1556452131357.png">
<meta property="og:image" content="https://wll-1017065322.github.io/assets/3843374773-57482aac090f3_articlex.png">
<meta property="og:image" content="https://wll-1017065322.github.io/assets/49526885-57482e1c601ce_articlex.png">
<meta property="og:image" content="https://wll-1017065322.github.io/assets/2484593136-57482d7ec7cc6_articlex.png">
<meta property="og:image" content="https://segmentfault.com/img/bVwFxe">
<meta property="og:image" content="https://wll-1017065322.github.io/assets/1556452216853.png">
<meta property="og:image" content="https://wll-1017065322.github.io/assets/1556450087551.png">
<meta property="og:updated_time" content="2019-05-12T03:46:35.932Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="原型链-继承">
<meta name="twitter:description" content="前言：​    对于有基于类的语言经验 (如 Java 或 C++) 的开发人员来说，JavaScript 有点令人困惑，因为它是动态的，并且本身不提供一个 class 实现。（在 ES2015/ES6 中引入了 class 关键字，但只是语法糖，JavaScript 仍然是基于原型的）。 ​    当谈到继承时，JavaScript 只有一种结构：对象。每个实例对象（ object ）都有一个私">
<meta name="twitter:image" content="https://wll-1017065322.github.io/assets/1556451911262.png">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/myBlog/css/style.css">
  <script src="/myBlog/js/pace.min.js"></script>
  

  
  

</head>
</html>
<body>
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">
        <div id="header-menu" class="header-menu-pos animated">
            <div class="header-menu-container">
                <a href="/myBlog/" class="left">
                    <span class="site-title">along&#39;s Blog</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a href="/myBlog/">
                        <i class="fa fa-home"></i>
                        <span>主页</span>
                    </a>
                    
                    <a href="/myBlog/archives">
                        <i class="fa fa-archive"></i>
                        <span>档案</span>
                    </a>
                    
                    <a href="/myBlog/about">
                        <i class="fa fa-user"></i>
                        <span>个人信息</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/myBlog/">
                    <img src="/myBlog/images/logo.png" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        along&#39;s Blog
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        但行前路，莫问前途
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                        <a title="along’s website" target="_blank" href="http://www.wanglvlong.top/">
                            <i class="fa fa-home fa-2x"></i></a>
                    
                        <a title="Github" target="_blank" href="//github.com/WLL-1017065322">
                            <i class="fa fa-github fa-2x"></i></a>
                    
                        <a title="Weixin" target="_blank" href="//baidu.com">
                            <i class="fa fa-weixin fa-2x"></i></a>
                    
                        <a title="QQ" target="_blank" href="//qq.com">
                            <i class="fa fa-qq fa-2x"></i></a>
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-原型链继承" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="post-title" itemprop="name">
      原型链-继承
    </h1>
    <div class="post-title-bar">
      <ul>
          
              <li>
                  <i class="fa fa-book"></i>
                  
                      <a href="/myBlog/categories/javascript/">javascript</a>
                  
              </li>
          
        <li>
          <i class="fa fa-calendar"></i>  2019-02-18
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>
        </li>
      </ul>
    </div>
  

          
      </header>
    
    <div class="article-entry post-content" itemprop="articleBody">
      
            
            <h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>​    对于有基于类的语言经验 (如 Java 或 C++) 的开发人员来说，JavaScript 有点令人困惑，因为它是动态的，并且本身不提供一个 <code>class</code> 实现。（在 ES2015/ES6 中引入了 <code>class</code> 关键字，但只是语法糖，JavaScript 仍然是基于原型的）。</p>
<p>​    当谈到继承时，JavaScript 只有一种结构：对象。每个实例对象（ object ）都有一个私有属性（称之为 <strong>proto</strong> ）指向它的原型对象（ <strong>prototype</strong> ）。该原型对象也有一个自己的原型对象( <strong>proto</strong> ) ，层层向上直到一个对象的原型对象为 <code>null</code>。根据定义，<code>null</code> 没有原型，并作为这个<strong>原型链</strong>中的最后一个环节。</p>
<p>几乎所有 JavaScript 中的对象都是位于原型链顶端的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noopener"><code>Object</code></a> 的实例。</p>
<p>​    尽管这种原型继承通常被认为是 JavaScript 的弱点之一，但是原型继承模型本身实际上比经典模型更强大。例如，在原型模型的基础上构建经典模型相当简单。</p>
<p>### </p>
<h5 id="原型："><a href="#原型：" class="headerlink" title="原型："></a>原型：</h5><p>原型的概念定义为：所谓原型就是指函数的prototype属性所引用的对象，这个对象就是原型。</p>
<p>作用1：实现对象之间的数据共享。2.在es6之前，没有class的情况下，模拟面向对象，构造函数中放私有属性，原型上放公有属性，一般为方法。</p>
<p>获取原型的方法：1.函数.prototype；2.对象._ <em>proto</em> <em>（如果当前浏览器不支持.proto</em> _，那么就通过对象的构造函数找：.constructor.prototype；原型本身是一个对象。</p>
<p><img src="/assets/1556451911262.png" alt="1556451911262"></p>
<p><strong>原型（prototype）</strong>：</p>
<ul>
<li>每一个构造函数都拥有一个prototype属性，这个属性指向一个对象，也就是原型对象。当使用这个构造函数创建实例的时候，prototype属性指向的原型对象就成为实例的原型对象。</li>
<li>原型对象默认拥有一个constructor属性，指向指向它的那个构造函数（也就是说构造函数和原型对象是互相指向的关系）。</li>
<li>每个对象都拥有一个隐藏的属性[[prototype]]，指向它的原型对象，这个属性可以通过 <code>Object.getPrototypeOf(obj)</code> 或 <code>obj.__proto__</code> 来访问。</li>
<li>实际上，构造函数的prototype属性与它创建的实例对象的[[prototype]]属性指向的是同一个对象，即 <code>对象.__proto__ === 函数.prototype</code> 。</li>
<li>如上文所述，原型对象就是用来存放实例中共有的那部分属性。</li>
<li>在JavaScript中，所有的对象都是由它的原型对象继承而来，反之，所有的对象都可以作为原型对象存在。</li>
<li>访问对象的属性时，JavaScript会首先在对象自身的属性内查找，若没有找到，则会跳转到该对象的原型对象中查找。</li>
</ul>
<p>作者：clancysong</p>
<p>链接：<a href="https://juejin.im/post/5a94c0de5188257a8929d837" target="_blank" rel="noopener">https://juejin.im/post/5a94c0de5188257a8929d837</a></p>
<h5 id="原型链："><a href="#原型链：" class="headerlink" title="原型链："></a>原型链：</h5><p>概念：原型链是一种机制，指的是JavaScript每个对象<code>包括原型对象</code>都有一个内置的[[proto]]属性指向创建它的函数对象的原型对象，即prototype属性。</p>
<p>作用：原型链的存在，主要是为了实现对象的<code>继承</code>。</p>
<p><img src="/assets/1556452131357.png" alt="1556452131357"></p>
<h5 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h5><h6 id="1、函数对象"><a href="#1、函数对象" class="headerlink" title="1、函数对象"></a>1、函数对象</h6><p>在JavaScript中，函数即对象。</p>
<h6 id="2、原型对象"><a href="#2、原型对象" class="headerlink" title="2、原型对象"></a>2、原型对象</h6><p>当定义一个函数对象的时候，会包含一个预定义的属性，叫<code>prototype</code>，这就属性称之为原型对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//函数对象</span><br><span class="line">function F()&#123;&#125;;</span><br><span class="line">console.log(F.prototype)</span><br></pre></td></tr></table></figure>
<p><img src="/assets/3843374773-57482aac090f3_articlex.png" alt="图片描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//普通对象</span><br><span class="line">var a = &#123;&#125;;</span><br><span class="line">console.log(a.prototype);//undefined</span><br></pre></td></tr></table></figure>
<p><img src="/assets/49526885-57482e1c601ce_articlex.png" alt="图片描述"></p>
<h6 id="3、-prot"><a href="#3、-prot" class="headerlink" title="3、__prot__"></a>3、__prot__</h6><p>JavaScript在创建对象的时候，都会有一个<code>[[proto]]</code>的内置属性，用于指向创建它的函数对象的<code>prototype</code>。原型对象也有<code>[[proto]]</code>属性。因此在不断的指向中，形成了原型链。</p>
<p>举个例子来说，我们将对象F的原型对象修改一下，就可以清楚看到上述的关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//函数对象</span><br><span class="line">function F()&#123;&#125;;</span><br><span class="line">F.prototype = &#123;</span><br><span class="line">    hello : function()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">var f = new F();</span><br><span class="line">console.log(f.__proto__)</span><br></pre></td></tr></table></figure>
<p><img src="/assets/2484593136-57482d7ec7cc6_articlex.png" alt="图片描述"></p>
<h6 id="4、new"><a href="#4、new" class="headerlink" title="4、new"></a>4、new</h6><p>当使用<code>new</code>去调用构造函数时，相当于执行了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;&#125;;</span><br><span class="line">o.__proto__ = F.prototype;</span><br><span class="line">F.call(o);</span><br></pre></td></tr></table></figure>
<p>因此，在原型链的实现上，new起到了很关键的作用。</p>
<h6 id="5、constructor"><a href="#5、constructor" class="headerlink" title="5、constructor"></a>5、constructor</h6><p>原型对象prototype上都有个预定义的<code>constructor</code>属性，用来引用它的函数对象。这是一种循环引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function F()&#123;&#125;;</span><br><span class="line">F.prototype.constructor === F;</span><br></pre></td></tr></table></figure>
<p><img src="https://segmentfault.com/img/bVwFxe" alt="图片描述"></p>
<p>在实际运用中，经常会有下列的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function F()&#123;&#125;;</span><br><span class="line">F.prototype = &#123;</span><br><span class="line">    constructor : F,</span><br><span class="line">    doSomething : function()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要加<code>constructor</code>是因为重写了原型对象，constructor属性就消失了，需要自己手动补上。</p>
<h6 id="6、原型链的内存结构"><a href="#6、原型链的内存结构" class="headerlink" title="6、原型链的内存结构"></a>6、原型链的内存结构</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function F()&#123;</span><br><span class="line">    this.name = &apos;zhang&apos;;</span><br><span class="line">&#125;;</span><br><span class="line">var f1 = new F();</span><br><span class="line">var f2 = new F();</span><br></pre></td></tr></table></figure>
<p><em>为了严谨起见，区分对象和变量</em></p>
<p><img src="/assets/1556452216853.png" alt="1556452216853"></p>
<p>简单回顾下构造函数,原型和实例的关系:</p>
<blockquote>
<p>每个构造函数(constructor)都有一个原型对象(prototype),原型对象都包含一个指向构造函数的指针,而实例(instance)都包含一个指向原型对象的内部指针.</p>
</blockquote>
<p>JS对象的圈子里有这么个游戏规则:</p>
<blockquote>
<p>如果试图引用对象(实例instance)的某个属性,会首先在对象内部寻找该属性,直至找不到,然后才在该对象的原型(instance.prototype)里去找这个属性.</p>
</blockquote>
<p>如果让原型对象指向另一个类型的实例…..有趣的事情便发生了.</p>
<p>即: constructor1.prototype = instance2</p>
<p>鉴于上述游戏规则生效,如果试图引用constructor1构造的实例instance1的某个属性p1:</p>
<p>1).首先会在instance1内部属性中找一遍;</p>
<p>2).接着会在instance1.<strong>proto</strong>(constructor1.prototype)中找一遍,而constructor1.prototype 实际上是instance2, 也就是说在instance2中寻找该属性p1;</p>
<p>3).如果instance2中还是没有,此时程序不会灰心,它会继续在instance2.<strong>proto</strong>(constructor2.prototype)中寻找…直至Object的原型对象</p>
<blockquote>
<p>搜索轨迹: instance1–&gt; instance2 –&gt; constructor2.prototype…–&gt;Object.prototype</p>
</blockquote>
<p>这种搜索的轨迹,形似一条长链, 又因prototype在这个游戏规则中充当链接的作用,于是我们把这种实例与原型的链条称作 <strong>原型链</strong> . 下面有个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Father()&#123;</span><br><span class="line">    this.property = true;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.getFatherValue = function()&#123;</span><br><span class="line">    return this.property;</span><br><span class="line">&#125;</span><br><span class="line">function Son()&#123;</span><br><span class="line">    this.sonProperty = false;</span><br><span class="line">&#125;</span><br><span class="line">//继承 Father</span><br><span class="line">Son.prototype = new Father();//Son.prototype被重写,导致Son.prototype.constructor也一同被重写</span><br><span class="line">Son.prototype.getSonVaule = function()&#123;</span><br><span class="line">    return this.sonProperty;</span><br><span class="line">&#125;</span><br><span class="line">var instance = new Son();</span><br><span class="line">alert(instance.getFatherValue());//true</span><br><span class="line">12345678910111213141516</span><br></pre></td></tr></table></figure>
<p>instance实例通过原型链找到了Father原型中的getFatherValue方法.</p>
<p>注意: 此时instance.constructor指向的是Father,这是因为Son.prototype中的constructor被重写的缘故.</p>
<h3 id="确定原型和实例的关系"><a href="#确定原型和实例的关系" class="headerlink" title="确定原型和实例的关系"></a>确定原型和实例的关系</h3><p>使用原型链后, 我们怎么去判断原型和实例的这种继承关系呢? 方法一般有两种.</p>
<blockquote>
<p>第一种是使用 <strong>instanceof</strong> 操作符, 只要用这个操作符来测试实例(instance)与原型链中出现过的构造函数,结果就会返回true. 以下几行代码就说明了这点.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(instance instanceof Object);//true</span><br><span class="line">alert(instance instanceof Father);//true</span><br><span class="line">alert(instance instanceof Son);//true</span><br><span class="line">123</span><br></pre></td></tr></table></figure>
<p>由于原型链的关系, 我们可以说instance 是 Object, Father 或 Son中任何一个类型的实例. 因此, 这三个构造函数的结果都返回了true.</p>
<blockquote>
<p>第二种是使用 <strong>isPrototypeOf()</strong> 方法, 同样只要是原型链中出现过的原型,isPrototypeOf() 方法就会返回true, 如下所示.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(Object.prototype.isPrototypeOf(instance));//true</span><br><span class="line">alert(Father.prototype.isPrototypeOf(instance));//true</span><br><span class="line">alert(Son.prototype.isPrototypeOf(instance));//true</span><br><span class="line">123</span><br></pre></td></tr></table></figure>
<p>原理同上.</p>
<h3 id="原型链的问题"><a href="#原型链的问题" class="headerlink" title="原型链的问题"></a>原型链的问题</h3><p>原型链并非十分完美, 它包含如下两个问题.</p>
<blockquote>
<p>问题一: 当原型链中包含引用类型值的原型时,该引用类型值会被所有实例共享;</p>
<p>问题二: 在创建子类型(例如创建Son的实例)时,不能向超类型(例如Father)的构造函数中传递参数.</p>
</blockquote>
<p>有鉴于此, 实践中很少会单独使用原型链.</p>
<p>为此,下面将有一些尝试以弥补原型链的不足.</p>
<h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><p>为解决原型链中上述两个问题, 我们开始使用一种叫做<strong>借用构造函数</strong>(constructor stealing)的技术(也叫经典继承).</p>
<blockquote>
<p>基本思想:即在子类型构造函数的内部调用超类型构造函数.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Father()&#123;</span><br><span class="line">    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">function Son()&#123;</span><br><span class="line">    Father.call(this);//继承了Father,且向父类型传递参数</span><br><span class="line">&#125;</span><br><span class="line">var instance1 = new Son();</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">console.log(instance1.colors);//&quot;red,blue,green,black&quot;</span><br><span class="line"></span><br><span class="line">var instance2 = new Son();</span><br><span class="line">console.log(instance2.colors);//&quot;red,blue,green&quot; 可见引用类型值是独立的</span><br><span class="line">123456789101112</span><br></pre></td></tr></table></figure>
<p>很明显,借用构造函数一举解决了原型链的两大问题:</p>
<p>其一, 保证了原型链中引用类型值的独立,不再被所有实例共享;</p>
<p>其二, 子类型创建时也能够向父类型传递参数.</p>
<p>随之而来的是, 如果仅仅借用构造函数,那么将无法避免构造函数模式存在的问题–方法都在构造函数中定义, 因此函数复用也就不可用了.而且超类型(如Father)中定义的方法,对子类型而言也是不可见的. 考虑此,借用构造函数的技术也很少单独使用.</p>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合继承, 有时候也叫做伪经典继承,指的是将原型链和借用构造函数的技术组合到一块,从而发挥两者之长的一种继承模式.</p>
<blockquote>
<p>基本思路: 使用原型链实现对原型属性和方法的继承,通过借用构造函数来实现对实例属性的继承.</p>
</blockquote>
<p>这样,既通过在原型上定义方法实现了函数复用,又能保证每个实例都有它自己的属性. 如下所示.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function Father(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.sayName = function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">function Son(name,age)&#123;</span><br><span class="line">    Father.call(this,name);//继承实例属性，第一次调用Father()</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Son.prototype = new Father();//继承父类方法,第二次调用Father()</span><br><span class="line">Son.prototype.sayAge = function()&#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;</span><br><span class="line">var instance1 = new Son(&quot;louis&quot;,5);</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">console.log(instance1.colors);//&quot;red,blue,green,black&quot;</span><br><span class="line">instance1.sayName();//louis</span><br><span class="line">instance1.sayAge();//5</span><br><span class="line"></span><br><span class="line">var instance1 = new Son(&quot;zhai&quot;,10);</span><br><span class="line">console.log(instance1.colors);//&quot;red,blue,green&quot;</span><br><span class="line">instance1.sayName();//zhai</span><br><span class="line">instance1.sayAge();//10</span><br><span class="line">12345678910111213141516171819202122232425</span><br></pre></td></tr></table></figure>
<p>组合继承避免了原型链和借用构造函数的缺陷,融合了它们的优点,成为 JavaScript 中最常用的继承模式. 而且, instanceof 和 isPrototypeOf( )也能用于识别基于组合继承创建的对象.</p>
<p>同时我们还注意到组合继承其实调用了两次父类构造函数, 造成了不必要的消耗, 那么怎样才能避免这种不必要的消耗呢, 这个我们将在后面讲到.</p>
<h3 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h3><p>该方法最初由道格拉斯·克罗克福德于2006年在一篇题为 《Prototypal Inheritance in JavaScript》(JavaScript中的原型式继承) 的文章中提出. 他的想法是借助原型可以基于已有的对象创建新对象， 同时还不必因此创建自定义类型. 大意如下:</p>
<blockquote>
<p>在object()函数内部, 先创建一个临时性的构造函数, 然后将传入的对象作为这个构造函数的原型,最后返回了这个临时类型的一个新实例.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function object(o)&#123;</span><br><span class="line">    function F()&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    return new F();</span><br><span class="line">&#125;</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>
<p>从本质上讲, object() 对传入其中的对象执行了一次浅复制. 下面我们来看看为什么是浅复制.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    friends : [&quot;Van&quot;,&quot;Louis&quot;,&quot;Nick&quot;]</span><br><span class="line">&#125;;</span><br><span class="line">var anotherPerson = object(person);</span><br><span class="line">anotherPerson.friends.push(&quot;Rob&quot;);</span><br><span class="line">var yetAnotherPerson = object(person);</span><br><span class="line">yetAnotherPerson.friends.push(&quot;Style&quot;);</span><br><span class="line">alert(person.friends);//&quot;Van,Louis,Nick,Rob,Style&quot;</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure>
<p>在这个例子中,可以作为另一个对象基础的是person对象,于是我们把它传入到object()函数中,然后该函数就会返回一个新对象. 这个新对象将person作为原型,因此它的原型中就包含引用类型值属性. 这意味着person.friends不仅属于person所有,而且也会被anotherPerson以及yetAnotherPerson共享.</p>
<p>在 ECMAScript5 中,通过新增 <strong>object.create()</strong> 方法规范化了上面的原型式继承.</p>
<p><strong>object.create()</strong> 接收两个参数:</p>
<ul>
<li>一个用作新对象原型的对象</li>
<li>(可选的)一个为新对象定义额外属性的对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    friends : [&quot;Van&quot;,&quot;Louis&quot;,&quot;Nick&quot;]</span><br><span class="line">&#125;;</span><br><span class="line">var anotherPerson = Object.create(person);</span><br><span class="line">anotherPerson.friends.push(&quot;Rob&quot;);</span><br><span class="line">var yetAnotherPerson = Object.create(person);</span><br><span class="line">yetAnotherPerson.friends.push(&quot;Style&quot;);</span><br><span class="line">alert(person.friends);//&quot;Van,Louis,Nick,Rob,Style&quot;</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure>
<p><strong>object.create()</strong> 只有一个参数时功能与上述object方法相同, 它的第二个参数与Object.defineProperties()方法的第二个参数格式相同: 每个属性都是通过自己的描述符定义的.以这种方式指定的任何属性都会覆盖原型对象上的同名属性.例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name : &quot;Van&quot;</span><br><span class="line">&#125;;</span><br><span class="line">var anotherPerson = Object.create(person, &#123;</span><br><span class="line">    name : &#123;</span><br><span class="line">        value : &quot;Louis&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">alert(anotherPerson.name);//&quot;Louis&quot;</span><br><span class="line">123456789</span><br></pre></td></tr></table></figure>
<p>目前支持 <strong>Object.create()</strong> 的浏览器有 IE9+, Firefox 4+, Safari 5+, Opera 12+ 和 Chrome.</p>
<p><strong>提醒:</strong> 原型式继承中, 包含引用类型值的属性始终都会共享相应的值, 就像使用原型模式一样.</p>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>寄生式继承是与原型式继承紧密相关的一种思路， 同样是克罗克福德推而广之.</p>
<blockquote>
<p>寄生式继承的思路与(寄生)构造函数和工厂模式类似, 即创建一个仅用于封装继承过程的函数,该函数在内部以某种方式来增强对象,最后再像真的是它做了所有工作一样返回对象. 如下.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function createAnother(original)&#123;</span><br><span class="line">    var clone = object(original);//通过调用object函数创建一个新对象</span><br><span class="line">    clone.sayHi = function()&#123;//以某种方式来增强这个对象</span><br><span class="line">        alert(&quot;hi&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    return clone;//返回这个对象</span><br><span class="line">&#125;</span><br><span class="line">1234567</span><br></pre></td></tr></table></figure>
<p>这个例子中的代码基于person返回了一个新对象–anotherPerson. 新对象不仅具有 person 的所有属性和方法, 而且还被增强了, 拥有了sayH()方法.</p>
<p><strong>注意:</strong> 使用寄生式继承来为对象添加函数, 会由于不能做到函数复用而降低效率;这一点与构造函数模式类似.</p>
<h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>前面讲过,组合继承是 JavaScript 最常用的继承模式; 不过, 它也有自己的不足. 组合继承最大的问题就是无论什么情况下,都会调用两次父类构造函数: 一次是在创建子类型原型的时候, 另一次是在子类型构造函数内部. <strong>寄生组合式继承就是为了降低调用父类构造函数的开销而出现的</strong> .</p>
<blockquote>
<p>其背后的基本思路是: 不必为了指定子类型的原型而调用超类型的构造函数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function extend(subClass,superClass)&#123;</span><br><span class="line">    var prototype = object(superClass.prototype);//创建对象</span><br><span class="line">    prototype.constructor = subClass;//增强对象</span><br><span class="line">    subClass.prototype = prototype;//指定对象</span><br><span class="line">&#125;</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>
<p>extend的高效率体现在它没有调用superClass构造函数,因此避免了在subClass.prototype上面创建不必要,多余的属性. 于此同时,原型链还能保持不变; 因此还能正常使用 instanceof 和 isPrototypeOf() 方法.</p>
<p>以上,寄生组合式继承,集寄生式继承和组合继承的优点于一身,是实现基于类型继承的最有效方法.</p>
<hr>
<p>下面我们来看下extend的另一种更为有效的扩展.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function extend(subClass, superClass) &#123;</span><br><span class="line">  var F = function() &#123;&#125;;</span><br><span class="line">  F.prototype = superClass.prototype;</span><br><span class="line">  subClass.prototype = new F(); </span><br><span class="line">  subClass.prototype.constructor = subClass;</span><br><span class="line"></span><br><span class="line">  subClass.superclass = superClass.prototype;</span><br><span class="line">  if(superClass.prototype.constructor == Object.prototype.constructor) &#123;</span><br><span class="line">    superClass.prototype.constructor = superClass;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">1234567891011</span><br></pre></td></tr></table></figure>
<p>我一直不太明白的是为什么要 “<strong>new F()</strong>“, 既然extend的目的是将子类型的 prototype 指向超类型的 prototype,为什么不直接做如下操作呢?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subClass.prototype = superClass.prototype;//直接指向超类型prototype</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>显然, 基于如上操作, 子类型原型将与超类型原型共用, 根本就没有继承关系.</p>
<h3 id="new-运算符"><a href="#new-运算符" class="headerlink" title="new 运算符"></a>new 运算符</h3><p>为了追本溯源, 我顺便研究了new运算符具体干了什么?发现其实很简单，就干了三件事情.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj  = &#123;&#125;;</span><br><span class="line">obj.__proto__ = F.prototype;</span><br><span class="line">F.call(obj);</span><br><span class="line">123</span><br></pre></td></tr></table></figure>
<p>第一行，我们创建了一个空对象obj;</p>
<p>第二行，我们将这个空对象的<strong>proto</strong>成员指向了F函数对象prototype成员对象;</p>
<p>第三行，我们将F函数对象的this指针替换成obj，然后再调用F函数.</p>
<p>我们可以这么理解: 以 new 操作符调用构造函数的时候，函数内部实际上发生以下变化：</p>
<p>1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。</p>
<p>2、属性和方法被加入到 this 引用的对象中。</p>
<p>3、新创建的对象由 this 所引用，并且最后隐式的返回 this.</p>
<h3 id="proto-属性是指定原型的关键"><a href="#proto-属性是指定原型的关键" class="headerlink" title="proto 属性是指定原型的关键"></a><strong>proto</strong> 属性是指定原型的关键</h3><p>以上, 通过设置 <strong>proto</strong> 属性继承了父类, 如果去掉new 操作, 直接参考如下写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subClass.prototype = superClass.prototype;//直接指向超类型prototype</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>那么, 使用 instanceof 方法判断对象是否是构造器的实例时, 将会出现紊乱.</p>
<p>假如参考如上写法, 那么extend代码应该为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function extend(subClass, superClass) &#123;</span><br><span class="line">  subClass.prototype = superClass.prototype;</span><br><span class="line"></span><br><span class="line">  subClass.superclass = superClass.prototype;</span><br><span class="line">  if(superClass.prototype.constructor == Object.prototype.constructor) &#123;</span><br><span class="line">    superClass.prototype.constructor = superClass;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure>
<p>此时, 请看如下测试:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123;&#125;</span><br><span class="line">function b()&#123;&#125;</span><br><span class="line">extend(b,a);</span><br><span class="line">var c = new a()&#123;&#125;;</span><br><span class="line">console.log(c instanceof a);//true</span><br><span class="line">console.log(c instanceof b);//true</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>
<p>c被认为是a的实例可以理解, 也是对的; 但c却被认为也是b的实例, 这就不对了. 究其原因, instanceof 操作符比较的应该是 c.<strong>proto</strong> 与 构造器.prototype(即 b.prototype 或 a.prototype) 这两者是否相等, 又extend(b,a); 则b.prototype === a.prototype, 故这才打印出上述不合理的输出.</p>
<hr>
<p>那么最终,原型链继承可以这么实现,例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function Father(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.sayName = function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">function Son(name,age)&#123;</span><br><span class="line">    Father.call(this,name);//继承实例属性，第一次调用Father()</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">extend(Son,Father)//继承父类方法,此处并不会第二次调用Father()</span><br><span class="line">Son.prototype.sayAge = function()&#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;</span><br><span class="line">var instance1 = new Son(&quot;louis&quot;,5);</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">console.log(instance1.colors);//&quot;red,blue,green,black&quot;</span><br><span class="line">instance1.sayName();//louis</span><br><span class="line">instance1.sayAge();//5</span><br><span class="line"></span><br><span class="line">var instance1 = new Son(&quot;zhai&quot;,10);</span><br><span class="line">console.log(instance1.colors);//&quot;red,blue,green&quot;</span><br><span class="line">instance1.sayName();//zhai</span><br><span class="line">instance1.sayAge();//10</span><br><span class="line">12345678910111213141516171819202122232425</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展:"></a>扩展:</h3><h4 id="属性查找"><a href="#属性查找" class="headerlink" title="属性查找"></a>属性查找</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用了原型链后, 当查找一个对象的属性时，JavaScript 会向上遍历原型链，直到找到给定名称的属性为止，到查找到达原型链的顶部 - 也就是 Object.prototype - 但是仍然没有找到指定的属性，就会返回 undefined. 此时若想避免原型链查找, 建议使用 **hasOwnProperty** 方法. 因为 **hasOwnProperty** 是 JavaScript 中唯一一个处理属性但是不查找原型链的函数. 如:</span><br><span class="line">1</span><br><span class="line">console.log(instance1.hasOwnProperty(&apos;age&apos;));//true</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>对比: <strong>isPrototypeOf</strong> 则是用来判断该方法所属的对象是不是参数的原型对象，是则返回true，否则返回false。如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(Father.prototype.isPrototypeOf(instance1));//true</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h4 id="instanceof-amp-amp-typeof"><a href="#instanceof-amp-amp-typeof" class="headerlink" title="instanceof &amp;&amp; typeof"></a>instanceof &amp;&amp; typeof</h4><p>上面提到几次提到 instanceof 运算符. 那么到底它是怎么玩的呢? 下面让我们来趴一趴它的使用场景.</p>
<p><strong>instanceof</strong> 运算符是用来在运行时指出对象是否是构造器的一个实例, 例如漏写了new运算符去调用某个构造器, 此时构造器内部可以通过 instanceof 来判断.(java中功能类似)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function f()&#123;</span><br><span class="line">  if(this instanceof arguments.callee)</span><br><span class="line">    console.log(&apos;此处作为构造函数被调用&apos;);</span><br><span class="line">  else</span><br><span class="line">    console.log(&apos;此处作为普通函数被调用&apos;);</span><br><span class="line">&#125;</span><br><span class="line">f();//此处作为普通函数被调用</span><br><span class="line">new f();//此处作为构造函数被调用</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure>
<p>以上, this instanceof <a href="http://louiszhai.github.io/2015/12/15/arguments/" target="_blank" rel="noopener"><code>arguments</code></a>.callee 的值如果为 true 表示是作为构造函数被调用的,如果为 false 则表示是作为普通函数被调用的。</p>
<p>对比: <strong>typeof</strong> 则用以获取一个变量或者表达式的类型, 一般只能返回如下几个结果:</p>
<p>number,boolean,string,function（函数）,object（NULL,数组，对象）,undefined。</p>
<h4 id="new运算符"><a href="#new运算符" class="headerlink" title="new运算符"></a>new运算符</h4><p>此处引用 艾伦的 <a href="http://www.cnblogs.com/aaronjs/archive/2012/07/04/2575570.html" target="_blank" rel="noopener">JS 对象机制深剖——new 运算符</a></p>
<p>接着上述对new运算符的研究, 我们来考察 ECMAScript 语言规范中 <strong>new</strong> 运算符的定义：</p>
<p>The new Operator</p>
<blockquote>
<p>The production <em>NewExpression : new NewExpression</em> is evaluated as follows:Evaluate NewExpression.Call GetValue(Result(1)).If Type(Result(2)) is not Object, throw a TypeError exception.If Result(2) does not implement the internal [<a href="http://www.pushiming.com/blog/2009/10/the-new-operator/#appendix" target="_blank" rel="noopener">[Construc]]</a> method, throw a TypeError exception.Call the [[Construct]] method on Result(2), providing no arguments (that is, an empty list of arguments).Return Result(5).</p>
</blockquote>
<p>其大意是，new 后必须跟一个对象并且此对象必须有一个名为 [[Construct]] 的内部方法（其实这种对象就是构造器），否则会抛出异常</p>
<p>根据这些内容，我们完全可以构造一个伪 [[Construct]] 方法来模拟此流程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function MyObject(age) &#123;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyObject.construct = function() &#123;</span><br><span class="line">    var o = &#123;&#125;, Constructor = MyObject;</span><br><span class="line">    o.__proto__ = Constructor.prototype;</span><br><span class="line">    // FF 支持用户引用内部属性 [[Prototype]]</span><br><span class="line">    Constructor.apply(o, arguments);</span><br><span class="line">    return o;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj1 = new MyObject(10);</span><br><span class="line">var obj2 = MyObject.construct(10);</span><br><span class="line">alert(obj2 instanceof MyObject);// true</span><br><span class="line">123456789101112131415</span><br></pre></td></tr></table></figure>
<hr>
<p>解释：</p>
<p><img src="/assets/1556450087551.png" alt="1556450087551"></p>

            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2019年05月12日 11:46</p>
        <p>原始链接： <a class="post-url" href="/myBlog/2019/02/18/原型链继承/" title="原型链-继承">https://WLL-1017065322.github.io/myBlog/2019/02/18/原型链继承/</a></p>
        <footer>
            <a href="https://WLL-1017065322.github.io/myBlog">
                <img src="/myBlog/images/logo.png" alt="along">
                along
            </a>
        </footer>
    </div>
</div>

      
        
            
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;">赏</a>
</div>

<div id="reward" class="post-modal reward-lay">
    <a class="close" href="javascript:;" id="reward-close">×</a>
    <span class="reward-title">
        <i class="icon icon-quote-left"></i>
        多谢打赏
        <i class="icon icon-quote-right"></i>
    </span>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/myBlog/images/wechat_code.jpg" alt="打赏二维码">
        </div>
        <div class="reward-select">
            
            <label class="reward-select-item checked" data-id="wechat" data-wechat="/myBlog/images/wechat_code.jpg">
                <img class="reward-select-item-wechat" src="/myBlog/images/wechat.png" alt="微信">
            </label>
            
            
            <label class="reward-select-item" data-id="alipay" data-alipay="/myBlog/images/alipay_code.jpg">
                <img class="reward-select-item-alipay" src="/myBlog/images/alipay.png" alt="支付宝">
            </label>
            
        </div>
    </div>
</div>


        
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://WLL-1017065322.github.io/myBlog/2019/02/18/原型链继承/&title=《原型链-继承》 — 阿龙的小型博客&pic=/images/banner.jpg" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://WLL-1017065322.github.io/myBlog/2019/02/18/原型链继承/&title=《原型链-继承》 — 阿龙的小型博客&source=" data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://WLL-1017065322.github.io/myBlog/2019/02/18/原型链继承/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《原型链-继承》 — 阿龙的小型博客&url=https://WLL-1017065322.github.io/myBlog/2019/02/18/原型链继承/&via=https://WLL-1017065322.github.io/myBlog" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://WLL-1017065322.github.io/myBlog/2019/02/18/原型链继承/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://WLL-1017065322.github.io/myBlog/2019/02/18/原型链继承/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
  <li class="article-footer-tags">
    <i class="fa fa-tags"></i>
      
    <a href="/myBlog/tags/javascript/" class="color1">javascript</a>
      
    <a href="/myBlog/tags/原型链/" class="color4">原型链</a>
      
  </li>

        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#前言："><span class="post-toc-text">前言：</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#原型："><span class="post-toc-text">原型：</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#原型链："><span class="post-toc-text">原型链：</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#继承："><span class="post-toc-text">继承：</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#1、函数对象"><span class="post-toc-text">1、函数对象</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#2、原型对象"><span class="post-toc-text">2、原型对象</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#3、-prot"><span class="post-toc-text">3、__prot__</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#4、new"><span class="post-toc-text">4、new</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#5、constructor"><span class="post-toc-text">5、constructor</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#6、原型链的内存结构"><span class="post-toc-text">6、原型链的内存结构</span></a></li></ol></li></ol></li></ol><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#确定原型和实例的关系"><span class="post-toc-text">确定原型和实例的关系</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#原型链的问题"><span class="post-toc-text">原型链的问题</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#借用构造函数"><span class="post-toc-text">借用构造函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#组合继承"><span class="post-toc-text">组合继承</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#原型继承"><span class="post-toc-text">原型继承</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#寄生式继承"><span class="post-toc-text">寄生式继承</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#寄生组合式继承"><span class="post-toc-text">寄生组合式继承</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#new-运算符"><span class="post-toc-text">new 运算符</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#proto-属性是指定原型的关键"><span class="post-toc-text">proto 属性是指定原型的关键</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#扩展"><span class="post-toc-text">扩展:</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#属性查找"><span class="post-toc-text">属性查找</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#instanceof-amp-amp-typeof"><span class="post-toc-text">instanceof &amp;&amp; typeof</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#new运算符"><span class="post-toc-text">new运算符</span></a></li></ol></li>
        </nav>
    </aside>
    

<nav id="article-nav">
  
    <a href="/myBlog/2019/02/19/探究同步异步工作原理/" id="article-nav-newer" class="article-nav-link-wrap">

      <span class="article-nav-title">
        <i class="fa fa-hand-o-left" aria-hidden="true"></i>
        
          探究同步异步工作原理
        
      </span>
    </a>
  
  
    <a href="/myBlog/2019/02/15/闭包/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">闭包</span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>



    
</section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      
<p>
    <span id="busuanzi_container_site_uv" style="display:none">
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style="display:none">
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


      <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2020 along<br>
      </p>
    </div>
  </div>
</footer>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script>
  var mihoConfig = {
      root: "https://WLL-1017065322.github.io/myBlog",
      animate: true,
      isHome: false,
      share: true,
      reward: 1
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            <a class="category-link" href="/myBlog/categories/First/">First</a><a class="category-link" href="/myBlog/categories/canvas/">canvas</a><a class="category-link" href="/myBlog/categories/css/">css</a><a class="category-link" href="/myBlog/categories/hexo/">hexo</a><a class="category-link" href="/myBlog/categories/java/">java</a><a class="category-link" href="/myBlog/categories/javascript/">javascript</a><a class="category-link" href="/myBlog/categories/js/">js</a><a class="category-link" href="/myBlog/categories/node/">node</a><a class="category-link" href="/myBlog/categories/python/">python</a><a class="category-link" href="/myBlog/categories/vue/">vue</a><a class="category-link" href="/myBlog/categories/上线/">上线</a><a class="category-link" href="/myBlog/categories/其他/">其他</a><a class="category-link" href="/myBlog/categories/数据库/">数据库</a>
        </div>
        <div id="sidebar-menu-box-tags">
            <a href="/myBlog/tags/Promise/" style="font-size: 10px;">Promise</a> <a href="/myBlog/tags/Selenium/" style="font-size: 10px;">Selenium</a> <a href="/myBlog/tags/WebDriverWait/" style="font-size: 10px;">WebDriverWait</a> <a href="/myBlog/tags/axios/" style="font-size: 16.67px;">axios</a> <a href="/myBlog/tags/canvas/" style="font-size: 10px;">canvas</a> <a href="/myBlog/tags/chrome/" style="font-size: 11.67px;">chrome</a> <a href="/myBlog/tags/clientHeight/" style="font-size: 10px;">clientHeight</a> <a href="/myBlog/tags/cookie/" style="font-size: 10px;">cookie</a> <a href="/myBlog/tags/css/" style="font-size: 11.67px;">css</a> <a href="/myBlog/tags/eslint/" style="font-size: 11.67px;">eslint</a> <a href="/myBlog/tags/export/" style="font-size: 10px;">export</a> <a href="/myBlog/tags/flex/" style="font-size: 10px;">flex</a> <a href="/myBlog/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/myBlog/tags/java/" style="font-size: 10px;">java</a> <a href="/myBlog/tags/javascript/" style="font-size: 20px;">javascript</a> <a href="/myBlog/tags/javascrpit/" style="font-size: 10px;">javascrpit</a> <a href="/myBlog/tags/js/" style="font-size: 13.33px;">js</a> <a href="/myBlog/tags/linux/" style="font-size: 13.33px;">linux</a> <a href="/myBlog/tags/mongod/" style="font-size: 11.67px;">mongod</a> <a href="/myBlog/tags/nginx/" style="font-size: 11.67px;">nginx</a> <a href="/myBlog/tags/node/" style="font-size: 13.33px;">node</a> <a href="/myBlog/tags/pm2/" style="font-size: 10px;">pm2</a> <a href="/myBlog/tags/python/" style="font-size: 10px;">python</a> <a href="/myBlog/tags/session/" style="font-size: 10px;">session</a> <a href="/myBlog/tags/this/" style="font-size: 10px;">this</a> <a href="/myBlog/tags/vue/" style="font-size: 18.33px;">vue</a> <a href="/myBlog/tags/vue-cli/" style="font-size: 10px;">vue-cli</a> <a href="/myBlog/tags/vue-router/" style="font-size: 15px;">vue-router</a> <a href="/myBlog/tags/vuex/" style="font-size: 10px;">vuex</a> <a href="/myBlog/tags/原型链/" style="font-size: 10px;">原型链</a> <a href="/myBlog/tags/定时器/" style="font-size: 10px;">定时器</a> <a href="/myBlog/tags/数据库/" style="font-size: 11.67px;">数据库</a> <a href="/myBlog/tags/数组/" style="font-size: 11.67px;">数组</a> <a href="/myBlog/tags/瀑布流/" style="font-size: 10px;">瀑布流</a> <a href="/myBlog/tags/爬虫/" style="font-size: 10px;">爬虫</a> <a href="/myBlog/tags/组件/" style="font-size: 10px;">组件</a> <a href="/myBlog/tags/跨域/" style="font-size: 11.67px;">跨域</a> <a href="/myBlog/tags/部署上线/" style="font-size: 16.67px;">部署上线</a> <a href="/myBlog/tags/问题/" style="font-size: 16.67px;">问题</a> <a href="/myBlog/tags/项目/" style="font-size: 11.67px;">项目</a>
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a href="/myBlog/">
                    <i class="fa fa-home"></i><span>主页</span>
                </a>
            </li>
            
            <li>
                <a href="/myBlog/archives">
                    <i class="fa fa-archive"></i><span>档案</span>
                </a>
            </li>
            
            <li>
                <a href="/myBlog/about">
                    <i class="fa fa-user"></i><span>个人信息</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            <a href="/myBlog/tags/Promise/" style="font-size: 10px;">Promise</a> <a href="/myBlog/tags/Selenium/" style="font-size: 10px;">Selenium</a> <a href="/myBlog/tags/WebDriverWait/" style="font-size: 10px;">WebDriverWait</a> <a href="/myBlog/tags/axios/" style="font-size: 16.67px;">axios</a> <a href="/myBlog/tags/canvas/" style="font-size: 10px;">canvas</a> <a href="/myBlog/tags/chrome/" style="font-size: 11.67px;">chrome</a> <a href="/myBlog/tags/clientHeight/" style="font-size: 10px;">clientHeight</a> <a href="/myBlog/tags/cookie/" style="font-size: 10px;">cookie</a> <a href="/myBlog/tags/css/" style="font-size: 11.67px;">css</a> <a href="/myBlog/tags/eslint/" style="font-size: 11.67px;">eslint</a> <a href="/myBlog/tags/export/" style="font-size: 10px;">export</a> <a href="/myBlog/tags/flex/" style="font-size: 10px;">flex</a> <a href="/myBlog/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/myBlog/tags/java/" style="font-size: 10px;">java</a> <a href="/myBlog/tags/javascript/" style="font-size: 20px;">javascript</a> <a href="/myBlog/tags/javascrpit/" style="font-size: 10px;">javascrpit</a> <a href="/myBlog/tags/js/" style="font-size: 13.33px;">js</a> <a href="/myBlog/tags/linux/" style="font-size: 13.33px;">linux</a> <a href="/myBlog/tags/mongod/" style="font-size: 11.67px;">mongod</a> <a href="/myBlog/tags/nginx/" style="font-size: 11.67px;">nginx</a> <a href="/myBlog/tags/node/" style="font-size: 13.33px;">node</a> <a href="/myBlog/tags/pm2/" style="font-size: 10px;">pm2</a> <a href="/myBlog/tags/python/" style="font-size: 10px;">python</a> <a href="/myBlog/tags/session/" style="font-size: 10px;">session</a> <a href="/myBlog/tags/this/" style="font-size: 10px;">this</a> <a href="/myBlog/tags/vue/" style="font-size: 18.33px;">vue</a> <a href="/myBlog/tags/vue-cli/" style="font-size: 10px;">vue-cli</a> <a href="/myBlog/tags/vue-router/" style="font-size: 15px;">vue-router</a> <a href="/myBlog/tags/vuex/" style="font-size: 10px;">vuex</a> <a href="/myBlog/tags/原型链/" style="font-size: 10px;">原型链</a> <a href="/myBlog/tags/定时器/" style="font-size: 10px;">定时器</a> <a href="/myBlog/tags/数据库/" style="font-size: 11.67px;">数据库</a> <a href="/myBlog/tags/数组/" style="font-size: 11.67px;">数组</a> <a href="/myBlog/tags/瀑布流/" style="font-size: 10px;">瀑布流</a> <a href="/myBlog/tags/爬虫/" style="font-size: 10px;">爬虫</a> <a href="/myBlog/tags/组件/" style="font-size: 10px;">组件</a> <a href="/myBlog/tags/跨域/" style="font-size: 11.67px;">跨域</a> <a href="/myBlog/tags/部署上线/" style="font-size: 16.67px;">部署上线</a> <a href="/myBlog/tags/问题/" style="font-size: 16.67px;">问题</a> <a href="/myBlog/tags/项目/" style="font-size: 11.67px;">项目</a>
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>
<script src="/myBlog/js/search.js"></script>
<script src="/myBlog/js/main.js"></script>


  <script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script>
  <div id="particles"></div>
  <script src="/myBlog/js/particles.js"></script>







  <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  <script src="/myBlog/js/animate.js"></script>


  <script src="/myBlog/js/pop-img.js"></script>
  <script>
     $(".article-entry p img").popImg();
  </script>

  </div>
</body>
</html>